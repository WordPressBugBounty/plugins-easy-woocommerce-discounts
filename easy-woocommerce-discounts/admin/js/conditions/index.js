this["ewd"] = this["ewd"] || {}; this["ewd"]["conditions"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 149);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["i18n"]; }());

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(69);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports) {

(function() { module.exports = this["Vue"]; }());

/***/ }),
/* 5 */
/***/ (function(module, exports) {

(function() { module.exports = this["jQuery"]; }());

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = __webpack_require__(14);

var _default = (0, _common.withParams)({
  type: 'required'
}, function (value) {
  if (typeof value === 'string') {
    return (0, _common.req)(value.trim());
  }

  return (0, _common.req)(value);
});

exports.default = _default;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

(function() { module.exports = this["Vuex"]; }());

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(48);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

(function() { module.exports = this["ewd"]["pages"]; }());

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _vue_datepicker_vue_vue_type_template_id_034e8a6e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
/* harmony import */ var _vue_datepicker_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _vue_datepicker_vue_vue_type_style_index_0_id_034e8a6e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(140);
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(
  _vue_datepicker_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _vue_datepicker_vue_vue_type_template_id_034e8a6e_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* render */ "a"],
  _vue_datepicker_vue_vue_type_template_id_034e8a6e_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* staticRenderFns */ "b"],
  false,
  null,
  "034e8a6e",
  null
  
)

/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 11 */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["apiFetch"]; }());

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(81),
    getValue = __webpack_require__(86);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["hooks"]; }());

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "withParams", {
  enumerable: true,
  get: function get() {
    return _withParams.default;
  }
});
exports.regex = exports.ref = exports.len = exports.req = void 0;

var _withParams = _interopRequireDefault(__webpack_require__(40));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var req = function req(value) {
  if (Array.isArray(value)) return !!value.length;

  if (value === undefined || value === null) {
    return false;
  }

  if (value === false) {
    return true;
  }

  if (value instanceof Date) {
    return !isNaN(value.getTime());
  }

  if (_typeof(value) === 'object') {
    for (var _ in value) {
      return true;
    }

    return false;
  }

  return !!String(value).length;
};

exports.req = req;

var len = function len(value) {
  if (Array.isArray(value)) return value.length;

  if (_typeof(value) === 'object') {
    return Object.keys(value).length;
  }

  return String(value).length;
};

exports.len = len;

var ref = function ref(reference, vm, parentVm) {
  return typeof reference === 'function' ? reference.call(vm, parentVm) : parentVm[reference];
};

exports.ref = ref;

var regex = function regex(type, expr) {
  return (0, _withParams.default)({
    type: type
  }, function (value) {
    return !req(value) || expr.test(value);
  });
};

exports.regex = regex;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(71),
    listCacheDelete = __webpack_require__(72),
    listCacheGet = __webpack_require__(73),
    listCacheHas = __webpack_require__(74),
    listCacheSet = __webpack_require__(75);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(46);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(29),
    getRawTag = __webpack_require__(82),
    objectToString = __webpack_require__(83);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(96);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(50),
    baseAssignValue = __webpack_require__(51);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



Object.defineProperty(exports, '__esModule', {
  value: true
});
var _moment = __webpack_require__(139);
var _moment2 = _interopRequireDefault(_moment);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
exports["default"] = {
  props: {
    required: false,
    date: {
      type: Object,
      required: true
    },
    option: {
      type: Object,
      "default": function _default() {
        return {
          type: 'day',
          SundayFirst: false,
          week: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
          month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
          format: 'YYYY-MM-DD',
          color: {
            checked: '#F50057',
            header: '#3f51b5',
            headerText: '#fff'
          },
          wrapperClass: '',
          inputClass: '',
          inputStyle: {
            display: 'inline-block',
            padding: '6px',
            'line-height': '22px',
            'font-size': '16px',
            border: '2px solid #fff',
            'box-shadow': '0 1px 3px 0 rgba(0, 0, 0, 0.2)',
            'border-radius': '2px',
            color: '#5F5F5F'
          },
          placeholder: 'when?',
          buttons: {
            ok: 'OK',
            cancel: 'Cancel',
            clear: 'Clear'
          },
          overlayOpacity: 0.5,
          dismissible: true,
          showClearButton: true,
          disabled: false
        };
      }
    },
    limit: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  },
  data: function data() {
    function hours() {
      var list = [];
      var hour = 24;
      while (hour > 0) {
        hour--;
        list.push({
          checked: false,
          value: hour < 10 ? '0' + hour : hour
        });
      }
      return list;
    }
    function mins() {
      var list = [];
      var min = 60;
      while (min > 0) {
        min--;
        list.push({
          checked: false,
          value: min < 10 ? '0' + min : min
        });
      }
      return list;
    }
    return {
      hours: hours(),
      mins: mins(),
      showInfo: {
        hour: false,
        day: false,
        month: false,
        year: false,
        check: false
      },
      displayInfo: {
        month: ''
      },
      library: {
        week: this.option.week,
        month: this.option.month,
        year: []
      },
      checked: {
        oldtime: '',
        currentMoment: null,
        year: '',
        month: '',
        day: '',
        hour: '00',
        min: '00'
      },
      dayList: [],
      selectedDays: []
    };
  },
  methods: {
    pad: function pad(n) {
      n = Math.floor(n);
      return n < 10 ? '0' + n : n;
    },
    nextMonth: function nextMonth(type) {
      var next = null;
      type === 'next' ? next = (0, _moment2["default"])(this.checked.currentMoment).add(1, 'M') : next = (0, _moment2["default"])(this.checked.currentMoment).add(-1, 'M');
      this.showDay(next);
    },
    showDay: function showDay(time) {
      if (time === undefined || !(0, _moment2["default"])(time, this.option.format).isValid()) {
        this.checked.currentMoment = (0, _moment2["default"])();
      } else {
        this.checked.currentMoment = (0, _moment2["default"])(time, this.option.format);
      }
      this.showOne('day');
      this.checked.year = (0, _moment2["default"])(this.checked.currentMoment).format('YYYY');
      this.checked.month = (0, _moment2["default"])(this.checked.currentMoment).format('MM');
      this.checked.day = (0, _moment2["default"])(this.checked.currentMoment).format('DD');
      this.displayInfo.month = this.library.month[(0, _moment2["default"])(this.checked.currentMoment).month()];
      var days = [];
      var currentMoment = this.checked.currentMoment;
      var firstDay = (0, _moment2["default"])(currentMoment).date(1).day();
      // gettting previous and next month
      // let currentMonth = moment(currentMoment)
      var previousMonth = (0, _moment2["default"])(currentMoment);
      var nextMonth = (0, _moment2["default"])(currentMoment);
      nextMonth.add(1, 'months');
      previousMonth.subtract(1, 'months');
      var monthDays = (0, _moment2["default"])(currentMoment).daysInMonth();
      var oldtime = this.checked.oldtime;
      for (var i = 1; i <= monthDays; ++i) {
        days.push({
          value: i,
          inMonth: true,
          unavailable: false,
          checked: false,
          moment: (0, _moment2["default"])(currentMoment).date(i)
        });
        if (i === Math.ceil((0, _moment2["default"])(currentMoment).format('D')) && (0, _moment2["default"])(oldtime, this.option.format).year() === (0, _moment2["default"])(currentMoment).year() && (0, _moment2["default"])(oldtime, this.option.format).month() === (0, _moment2["default"])(currentMoment).month()) {
          days[i - 1].checked = true;
        }
        this.checkBySelectDays(i, days);
      }
      if (firstDay === 0) firstDay = 7;
      for (var _i = 0; _i < firstDay - (this.option.SundayFirst ? 0 : 1); _i++) {
        var passiveDay = {
          value: previousMonth.daysInMonth() - _i,
          inMonth: false,
          action: 'previous',
          unavailable: false,
          checked: false,
          moment: (0, _moment2["default"])(currentMoment).date(1).subtract(_i + 1, 'days')
        };
        days.unshift(passiveDay);
      }
      if (this.limit.length > 0) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
          for (var _iterator = this.limit[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var li = _step.value;
            switch (li.type) {
              case 'fromto':
                days = this.limitFromTo(li, days);
                break;
              case 'weekday':
                days = this.limitWeekDay(li, days);
                break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      var passiveDaysAtFinal = 42 - days.length;
      for (var _i2 = 1; _i2 <= passiveDaysAtFinal; _i2++) {
        var _passiveDay = {
          value: _i2,
          inMonth: false,
          action: 'next',
          unavailable: false,
          checked: false,
          moment: (0, _moment2["default"])(currentMoment).add(1, 'months').date(_i2)
        };
        days.push(_passiveDay);
      }
      this.dayList = days;
    },
    checkBySelectDays: function checkBySelectDays(d, days) {
      var _this = this;
      this.selectedDays.forEach(function (day) {
        if (_this.checked.year === (0, _moment2["default"])(day).format('YYYY') && _this.checked.month === (0, _moment2["default"])(day).format('MM') && d === Math.ceil((0, _moment2["default"])(day).format('D'))) {
          days[d - 1].checked = true;
        }
      });
    },
    limitWeekDay: function limitWeekDay(limit, days) {
      days.map(function (day) {
        if (limit.available.indexOf(Math.floor(day.moment.format('d'))) === -1) {
          day.unavailable = true;
        }
      });
      return days;
    },
    limitFromTo: function limitFromTo(limit, days) {
      var _this2 = this;
      if (limit.from || limit.to) {
        days.map(function (day) {
          if (_this2.getLimitCondition(limit, day)) {
            day.unavailable = true;
          }
        });
      }
      return days;
    },
    getLimitCondition: function getLimitCondition(limit, day) {
      var tmpMoment = (0, _moment2["default"])(this.checked.year + '-' + this.pad(this.checked.month) + '-' + this.pad(day.value));
      if (limit.from && !limit.to) {
        return !tmpMoment.isAfter(limit.from);
      } else if (!limit.from && limit.to) {
        return !tmpMoment.isBefore(limit.to);
      } else {
        return !tmpMoment.isBetween(limit.from, limit.to);
      }
    },
    checkDay: function checkDay(obj) {
      if (obj.unavailable || obj.value === '') {
        return false;
      }
      if (!obj.inMonth) {
        this.nextMonth(obj.action);
      }
      if (this.option.type === 'day' || this.option.type === 'min') {
        this.dayList.forEach(function (x) {
          x.checked = false;
        });
        this.checked.day = this.pad(obj.value);
        obj.checked = true;
      } else {
        var day = this.pad(obj.value);
        var ctime = this.checked.year + '-' + this.checked.month + '-' + day;
        if (obj.checked === true) {
          obj.checked = false;
          var index = this.selectedDays.indexOf(ctime);
          this.selectedDays.splice(index, 1);
        } else {
          this.selectedDays.push(ctime);
          obj.checked = true;
        }
      }
      switch (this.option.type) {
        case 'day':
          this.picked();
          break;
        case 'min':
          this.showOne('hour');
          // shift activated time items to visible position.
          this.shiftActTime();
          break;
      }
    },
    showYear: function showYear() {
      var _this3 = this;
      var year = (0, _moment2["default"])(this.checked.currentMoment).year();
      this.library.year = [];
      var yearTmp = [];
      for (var i = year - 100; i < year + 5; ++i) {
        yearTmp.push(i);
      }
      this.library.year = yearTmp;
      this.showOne('year');
      this.$nextTick(function () {
        var listDom = document.getElementById('yearList');
        listDom.scrollTop = listDom.scrollHeight - 100;
        _this3.addYear();
      });
    },
    showOne: function showOne(type) {
      switch (type) {
        case 'year':
          this.showInfo.hour = false;
          this.showInfo.day = false;
          this.showInfo.year = true;
          this.showInfo.month = false;
          break;
        case 'month':
          this.showInfo.hour = false;
          this.showInfo.day = false;
          this.showInfo.year = false;
          this.showInfo.month = true;
          break;
        case 'day':
          this.showInfo.hour = false;
          this.showInfo.day = true;
          this.showInfo.year = false;
          this.showInfo.month = false;
          break;
        case 'hour':
          this.showInfo.hour = true;
          this.showInfo.day = false;
          this.showInfo.year = false;
          this.showInfo.month = false;
          break;
        default:
          this.showInfo.day = true;
          this.showInfo.year = false;
          this.showInfo.month = false;
          this.showInfo.hour = false;
      }
    },
    showMonth: function showMonth() {
      this.showOne('month');
    },
    addYear: function addYear() {
      var _this4 = this;
      var listDom = document.getElementById('yearList');
      listDom.addEventListener('scroll', function (e) {
        if (listDom.scrollTop < listDom.scrollHeight - 100) {
          var len = _this4.library.year.length;
          var lastYear = _this4.library.year[len - 1];
          _this4.library.year.push(lastYear + 1);
        }
      }, false);
    },
    setYear: function setYear(year) {
      this.checked.currentMoment = (0, _moment2["default"])(year + '-' + this.checked.month + '-' + this.checked.day);
      this.showDay(this.checked.currentMoment);
    },
    setMonth: function setMonth(month) {
      var mo = this.library.month.indexOf(month) + 1;
      if (mo < 10) {
        mo = '0' + '' + mo;
      }
      this.checked.currentMoment = (0, _moment2["default"])(this.checked.year + '-' + mo + '-' + this.checked.day);
      this.showDay(this.checked.currentMoment);
    },
    showCheck: function showCheck() {
      if (this.date.time === '') {
        this.showDay();
      } else {
        if (this.option.type === 'day' || this.option.type === 'min') {
          this.checked.oldtime = this.date.time;
          this.showDay(this.date.time);
        } else {
          this.selectedDays = JSON.parse(this.date.time);
          if (this.selectedDays.length) {
            this.checked.oldtime = this.selectedDays[0];
            this.showDay(this.selectedDays[0]);
          } else {
            this.showDay();
          }
        }
      }
      this.showInfo.check = true;
    },
    setTime: function setTime(type, obj, list) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;
      try {
        for (var _iterator2 = list[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;
          item.checked = false;
          if (item.value === obj.value) {
            item.checked = true;
            this.checked[type] = item.value;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    },
    picked: function picked() {
      if (this.option.type === 'day' || this.option.type === 'min') {
        var ctime = this.checked.year + '-' + this.checked.month + '-' + this.checked.day + ' ' + this.checked.hour + ':' + this.checked.min;
        this.checked.currentMoment = (0, _moment2["default"])(ctime, 'YYYY-MM-DD HH:mm');
        this.date.time = (0, _moment2["default"])(this.checked.currentMoment).format(this.option.format);
      } else {
        this.date.time = JSON.stringify(this.selectedDays);
      }
      this.showInfo.check = false;
      this.$emit('change', this.date.time);
    },
    dismiss: function dismiss(evt) {
      if (evt.target.className === 'datepicker-overlay') {
        if (this.option.dismissible === undefined || this.option.dismissible) {
          this.showInfo.check = false;
          this.$emit('cancel');
        }
      }
    },
    clear: function clear() {
      this.date.time = '';
      if (this.option.type !== 'day' && this.option.type !== 'min') {
        this.selectedDays = [];
      }
      this.showInfo.check = false;
      this.$emit('change', this.date.time);
    },
    shiftActTime: function shiftActTime() {
      // shift activated time items to visible position.
      this.$nextTick(function () {
        if (!document.querySelector('.hour-item.active')) {
          return false;
        }
        document.querySelector('.hour-box').scrollTop = (document.querySelector('.hour-item.active').offsetTop || 0) - 250;
        document.querySelector('.min-box').scrollTop = (document.querySelector('.min-item.active').offsetTop || 0) - 250;
      });
    }
  }
};

/***/ }),
/* 26 */
/***/ (function(module, exports) {

(function() { module.exports = this["ewd"]["shared"]; }());

/***/ }),
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(52),
    baseKeys = __webpack_require__(110),
    isArrayLike = __webpack_require__(56);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(48);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(32)(module)))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(52),
    baseKeysIn = __webpack_require__(113),
    isArrayLike = __webpack_require__(56);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(118),
    stubArray = __webpack_require__(57);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(122),
    Map = __webpack_require__(28),
    Promise = __webpack_require__(123),
    Set = __webpack_require__(124),
    WeakMap = __webpack_require__(125),
    baseGetTag = __webpack_require__(19),
    toSource = __webpack_require__(49);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(128);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var withParams = process.env.BUILD === 'web' ? __webpack_require__(42).withParams : __webpack_require__(43).withParams;
var _default = withParams;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41)))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withParams = void 0;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};

var fakeWithParams = function fakeWithParams(paramsOrClosure, maybeValidator) {
  if (_typeof(paramsOrClosure) === 'object' && maybeValidator !== undefined) {
    return maybeValidator;
  }

  return paramsOrClosure(function () {});
};

var withParams = root.vuelidate ? root.vuelidate.withParams : fakeWithParams;
exports.withParams = withParams;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pushParams = pushParams;
exports.popParams = popParams;
exports.withParams = withParams;
exports._setTarget = exports.target = void 0;

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var stack = [];
var target = null;
exports.target = target;

var _setTarget = function _setTarget(x) {
  exports.target = target = x;
};

exports._setTarget = _setTarget;

function pushParams() {
  if (target !== null) {
    stack.push(target);
  }

  exports.target = target = {};
}

function popParams() {
  var lastTarget = target;
  var newTarget = exports.target = target = stack.pop() || null;

  if (newTarget) {
    if (!Array.isArray(newTarget.$sub)) {
      newTarget.$sub = [];
    }

    newTarget.$sub.push(lastTarget);
  }

  return lastTarget;
}

function addParams(params) {
  if (_typeof(params) === 'object' && !Array.isArray(params)) {
    exports.target = target = _objectSpread({}, target, params);
  } else {
    throw new Error('params must be an object');
  }
}

function withParamsDirect(params, validator) {
  return withParamsClosure(function (add) {
    return function () {
      add(params);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return validator.apply(this, args);
    };
  });
}

function withParamsClosure(closure) {
  var validator = closure(addParams);
  return function () {
    pushParams();

    try {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return validator.apply(this, args);
    } finally {
      popParams();
    }
  };
}

function withParams(paramsOrClosure, maybeValidator) {
  if (_typeof(paramsOrClosure) === 'object' && maybeValidator !== undefined) {
    return withParamsDirect(paramsOrClosure, maybeValidator);
  }

  return withParamsClosure(paramsOrClosure);
}

/***/ }),
/* 44 */
/***/ (function(module, exports) {

(function() { module.exports = this["VueRouter"]; }());

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ render; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ staticRenderFns; });

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/vue-datepicker.vue?vue&type=template&id=034e8a6e&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"cov-vue-date",class:_vm.option.wrapperClass ? _vm.option.wrapperClass : {}},[_c('div',{staticClass:"datepickbox"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.date.time),expression:"date.time"}],staticClass:"cov-datepicker asnp-text-field",class:_vm.option.inputClass ? _vm.option.inputClass : {},style:(_vm.option.inputStyle ? _vm.option.inputStyle : {}),attrs:{"type":"text","title":"input date","readonly":"readonly","disabled":_vm.option.disabled,"placeholder":_vm.option.placeholder,"required":_vm.required},domProps:{"value":(_vm.date.time)},on:{"click":_vm.showCheck,"focus":_vm.showCheck,"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.date, "time", $event.target.value)}}})]),_vm._v(" "),(_vm.showInfo.check)?_c('div',{staticClass:"datepicker-overlay",style:({
			background: _vm.option.overlayOpacity
				? 'rgba(0,0,0,' + _vm.option.overlayOpacity + ')'
				: 'rgba(0,0,0,0.5)',
		}),on:{"click":function($event){return _vm.dismiss( $event )}}},[_c('div',{staticClass:"cov-date-body",style:({
				'background-color': _vm.option.color
					? _vm.option.color.header
					: '#3f51b5',
			})},[_c('div',{staticClass:"cov-date-monthly"},[_c('div',{staticClass:"cov-date-previous",on:{"click":function($event){return _vm.nextMonth( 'pre' )}}},[_vm._v("\n\t\t\t\t\t\n\t\t\t\t")]),_vm._v(" "),_c('div',{staticClass:"cov-date-caption",style:({
						color: _vm.option.color
							? _vm.option.color.headerText
							: '#fff',
					})},[_c('span',{on:{"click":_vm.showYear}},[_c('small',[_vm._v(_vm._s(_vm.checked.year))])]),_vm._v(" "),_c('br'),_vm._v(" "),_c('span',{on:{"click":_vm.showMonth}},[_vm._v(_vm._s(_vm.displayInfo.month))])]),_vm._v(" "),_c('div',{staticClass:"cov-date-next",on:{"click":function($event){return _vm.nextMonth( 'next' )}}},[_vm._v("\n\t\t\t\t\t\n\t\t\t\t")])]),_vm._v(" "),(_vm.showInfo.day)?_c('div',{staticClass:"cov-date-box"},[_c('div',{staticClass:"cov-picker-box"},[_c('div',{staticClass:"week"},[_c('ul',_vm._l((_vm.library.week),function(weekie){return _c('li',[_vm._v("\n\t\t\t\t\t\t\t\t"+_vm._s(weekie)+"\n\t\t\t\t\t\t\t")])}),0)]),_vm._v(" "),_vm._l((_vm.dayList),function(day){return _c('div',{staticClass:"day",class:{
							checked: day.checked,
							unavailable: day.unavailable,
							'passive-day': ! day.inMonth,
						},style:(day.checked
								? _vm.option.color && _vm.option.color.checkedDay
									? {
											background:
												_vm.option.color.checkedDay,
									  }
									: { background: '#F50057' }
								: {}),attrs:{"track-by":"$index"},on:{"click":function($event){return _vm.checkDay( day )}}},[_vm._v("\n\t\t\t\t\t\t"+_vm._s(day.value)+"\n\t\t\t\t\t")])})],2)]):_vm._e(),_vm._v(" "),(_vm.showInfo.year)?_c('div',{staticClass:"cov-date-box list-box"},[_c('div',{staticClass:"cov-picker-box date-list",attrs:{"id":"yearList"}},_vm._l((_vm.library.year),function(yearItem){return _c('div',{staticClass:"date-item",attrs:{"track-by":"$index"},on:{"click":function($event){return _vm.setYear( yearItem )}}},[_vm._v("\n\t\t\t\t\t\t"+_vm._s(yearItem)+"\n\t\t\t\t\t")])}),0)]):_vm._e(),_vm._v(" "),(_vm.showInfo.month)?_c('div',{staticClass:"cov-date-box list-box"},[_c('div',{staticClass:"cov-picker-box date-list"},_vm._l((_vm.library.month),function(monthItem){return _c('div',{staticClass:"date-item",attrs:{"track-by":"$index"},on:{"click":function($event){return _vm.setMonth( monthItem )}}},[_vm._v("\n\t\t\t\t\t\t"+_vm._s(monthItem)+"\n\t\t\t\t\t")])}),0)]):_vm._e(),_vm._v(" "),(_vm.showInfo.hour)?_c('div',{staticClass:"cov-date-box list-box"},[_c('div',{staticClass:"cov-picker-box date-list"},[_c('div',{staticClass:"watch-box"},[_c('div',{staticClass:"hour-box"},[_c('div',{staticClass:"mui-pciker-rule mui-pciker-rule-ft"}),_vm._v(" "),_c('ul',_vm._l((_vm.hours),function(hitem){return _c('li',{staticClass:"hour-item",class:{ active: hitem.checked },on:{"click":function($event){return _vm.setTime( 'hour', hitem, _vm.hours )}}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(hitem.value)+"\n\t\t\t\t\t\t\t\t")])}),0)]),_vm._v(" "),_c('div',{staticClass:"min-box"},[_c('div',{staticClass:"mui-pciker-rule mui-pciker-rule-ft"}),_vm._v(" "),_vm._l((_vm.mins),function(mitem){return _c('div',{staticClass:"min-item",class:{ active: mitem.checked },on:{"click":function($event){return _vm.setTime( 'min', mitem, _vm.mins )}}},[_vm._v("\n\t\t\t\t\t\t\t\t"+_vm._s(mitem.value)+"\n\t\t\t\t\t\t\t")])})],2)])])]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"button-box"},[(false !== _vm.option.showClearButton)?_c('span',{on:{"click":_vm.clear}},[_vm._v(_vm._s(null != _vm.option.buttons &&
						null != _vm.option.buttons.clear
							? _vm.option.buttons.clear
							: 'Clear'))]):_vm._e(),_vm._v(" "),_c('span',{on:{"click":function($event){_vm.showInfo.check = false}}},[_vm._v(_vm._s(_vm.option.buttons ? _vm.option.buttons.cancel : 'Cancel'))]),_vm._v(" "),_c('span',{on:{"click":_vm.picked}},[_vm._v(_vm._s(_vm.option.buttons ? _vm.option.buttons.ok : 'Ok'))])])])]):_vm._e()])}
var staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/vue-datepicker.vue?vue&type=template&id=034e8a6e&scoped=true&


/***/ }),
/* 46 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(19),
    isObject = __webpack_require__(15);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))

/***/ }),
/* 49 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(51),
    eq = __webpack_require__(46);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(101);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(103),
    isArguments = __webpack_require__(104),
    isArray = __webpack_require__(31),
    isBuffer = __webpack_require__(53),
    isIndex = __webpack_require__(107),
    isTypedArray = __webpack_require__(108);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8),
    stubFalse = __webpack_require__(106);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(32)(module)))

/***/ }),
/* 54 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(47),
    isLength = __webpack_require__(54);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 57 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(59),
    getPrototype = __webpack_require__(60),
    getSymbols = __webpack_require__(37),
    stubArray = __webpack_require__(57);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 59 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(55);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(59),
    isArray = __webpack_require__(31);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = __webpack_require__(14);

var _default = function _default(min) {
  return (0, _common.withParams)({
    type: 'minValue',
    min: min
  }, function (value) {
    return !(0, _common.req)(value) || (!/\s/.test(value) || value instanceof Date) && +value >= +min;
  });
};

exports.default = _default;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

(function() { module.exports = this["ewd"]["validators"]; }());

/***/ }),
/* 68 */
/***/ (function(module, exports) {

(function() { module.exports = this["vuelidate"]; }());

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(70),
    arrayEach = __webpack_require__(100),
    assignValue = __webpack_require__(50),
    baseAssign = __webpack_require__(102),
    baseAssignIn = __webpack_require__(112),
    cloneBuffer = __webpack_require__(115),
    copyArray = __webpack_require__(116),
    copySymbols = __webpack_require__(117),
    copySymbolsIn = __webpack_require__(119),
    getAllKeys = __webpack_require__(120),
    getAllKeysIn = __webpack_require__(121),
    getTag = __webpack_require__(38),
    initCloneArray = __webpack_require__(126),
    initCloneByTag = __webpack_require__(127),
    initCloneObject = __webpack_require__(133),
    isArray = __webpack_require__(31),
    isBuffer = __webpack_require__(53),
    isMap = __webpack_require__(135),
    isObject = __webpack_require__(15),
    isSet = __webpack_require__(137),
    keys = __webpack_require__(30),
    keysIn = __webpack_require__(36);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(17),
    stackClear = __webpack_require__(76),
    stackDelete = __webpack_require__(77),
    stackGet = __webpack_require__(78),
    stackHas = __webpack_require__(79),
    stackSet = __webpack_require__(80);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(18);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(18);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(18);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(18);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(17);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 77 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 78 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 79 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(17),
    Map = __webpack_require__(28),
    MapCache = __webpack_require__(87);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(47),
    isMasked = __webpack_require__(84),
    isObject = __webpack_require__(15),
    toSource = __webpack_require__(49);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(29);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(85);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 86 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(88),
    mapCacheDelete = __webpack_require__(95),
    mapCacheGet = __webpack_require__(97),
    mapCacheHas = __webpack_require__(98),
    mapCacheSet = __webpack_require__(99);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(89),
    ListCache = __webpack_require__(17),
    Map = __webpack_require__(28);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(90),
    hashDelete = __webpack_require__(91),
    hashGet = __webpack_require__(92),
    hashHas = __webpack_require__(93),
    hashSet = __webpack_require__(94);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 100 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(23),
    keys = __webpack_require__(30);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(105),
    isObjectLike = __webpack_require__(16);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(19),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(109),
    baseUnary = __webpack_require__(33),
    nodeUtil = __webpack_require__(34);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(19),
    isLength = __webpack_require__(54),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(35),
    nativeKeys = __webpack_require__(111);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(55);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(23),
    keysIn = __webpack_require__(36);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(15),
    isPrototype = __webpack_require__(35),
    nativeKeysIn = __webpack_require__(114);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(8);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(32)(module)))

/***/ }),
/* 116 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(23),
    getSymbols = __webpack_require__(37);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 118 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(23),
    getSymbolsIn = __webpack_require__(58);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(61),
    getSymbols = __webpack_require__(37),
    keys = __webpack_require__(30);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(61),
    getSymbolsIn = __webpack_require__(58),
    keysIn = __webpack_require__(36);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(12),
    root = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 126 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(39),
    cloneDataView = __webpack_require__(129),
    cloneRegExp = __webpack_require__(130),
    cloneSymbol = __webpack_require__(131),
    cloneTypedArray = __webpack_require__(132);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(8);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(39);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 130 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(29);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(39);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(134),
    getPrototype = __webpack_require__(60),
    isPrototype = __webpack_require__(35);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(15);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(136),
    baseUnary = __webpack_require__(33),
    nodeUtil = __webpack_require__(34);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(38),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(138),
    baseUnary = __webpack_require__(33),
    nodeUtil = __webpack_require__(34);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(38),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 139 */
/***/ (function(module, exports) {

(function() { module.exports = this["moment"]; }());

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_style_index_0_id_034e8a6e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_style_index_0_id_034e8a6e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_vue_datepicker_vue_vue_type_style_index_0_id_034e8a6e_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_1ba6050f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63);
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_1ba6050f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_1ba6050f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Analytics_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Analytics_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Analytics_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/* harmony import */ var _node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_automattic_mini_css_extract_plugin_with_rtl_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_2_2_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 147 */,
/* 148 */,
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "Vue"
var external_Vue_ = __webpack_require__(4);
var external_Vue_default = /*#__PURE__*/__webpack_require__.n(external_Vue_);

// EXTERNAL MODULE: external "Vuex"
var external_Vuex_ = __webpack_require__(7);
var external_Vuex_default = /*#__PURE__*/__webpack_require__.n(external_Vuex_);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/store/mutations.js
/* harmony default export */ var mutations = ({
  ADD_PRODUCTS_LIST: function ADD_PRODUCTS_LIST(state, productsList) {
    if (state.productsList.length) {
      for (var i = 0, max = state.productsList.length; i < max; i++) {
        if (productsList.id == state.productsList[i].id) {
          state.productsList[i] = productsList;
          return;
        }
      }
    }
    state.productsList.push(productsList);
  },
  DELETE_PRODUCTS_LIST: function DELETE_PRODUCTS_LIST(state, id) {
    if (state.productsList.length) {
      for (var i = 0, max = state.productsList.length; i < max; i++) {
        if (id == state.productsList[i].id) {
          state.productsList.splice(i, 1);
          break;
        }
      }
    }
  },
  SET_PRODUCTS_LIST: function SET_PRODUCTS_LIST(state, productsList) {
    Object.assign(state.productsList, productsList);
  },
  ADD_CART_DISCOUNT: function ADD_CART_DISCOUNT(state, discount) {
    if (state.discountList.length) {
      for (var i = 0, max = state.discountList.length; i < max; i++) {
        if (discount.id == state.discountList[i].id) {
          state.discountList[i] = discount;
          return;
        }
      }
    }
    state.discountList.push(discount);
  },
  UPDATE_CART_DISCOUNT: function UPDATE_CART_DISCOUNT(state, discount) {
    if (!state.discountList || !state.discountList.length) {
      return;
    }
    for (var i = 0, max = state.discountList.length; i < max; i++) {
      if (discount.id == state.discountList[i].id) {
        state.discountList[i] = discount;
        return;
      }
    }
  },
  DELETE_CART_DISCOUNT: function DELETE_CART_DISCOUNT(state, id) {
    if (state.discountList.length) {
      for (var i = 0, max = state.discountList.length; i < max; i++) {
        if (id == state.discountList[i].id) {
          state.discountList.splice(i, 1);
          break;
        }
      }
    }
  },
  SET_CART_DISCOUNT_LIST: function SET_CART_DISCOUNT_LIST(state, discountList) {
    Object.assign(state.discountList, discountList);
  },
  ADD_PRICING: function ADD_PRICING(state, pricing) {
    if (state.pricingList.length) {
      for (var i = 0, max = state.pricingList.length; i < max; i++) {
        if (pricing.id == state.pricingList[i].id) {
          state.pricingList[i] = pricing;
          return;
        }
      }
    }
    state.pricingList.push(pricing);
  },
  UPDATE_PRICING: function UPDATE_PRICING(state, pricing) {
    if (!state.pricingList || !state.pricingList.length) {
      return;
    }
    for (var i = 0, max = state.pricingList.length; i < max; i++) {
      if (pricing.id == state.pricingList[i].id) {
        state.pricingList[i] = pricing;
        return;
      }
    }
  },
  SET_PRICING_LIST: function SET_PRICING_LIST(state, pricingList) {
    Object.assign(state.pricingList, pricingList);
  },
  DELETE_PRICING: function DELETE_PRICING(state, id) {
    if (state.pricingList.length) {
      for (var i = 0, max = state.pricingList.length; i < max; i++) {
        if (id == state.pricingList[i].id) {
          state.pricingList.splice(i, 1);
          break;
        }
      }
    }
  },
  ADD_CHECKOUT_FEE: function ADD_CHECKOUT_FEE(state, checkoutFee) {
    if (state.checkoutFeeList.length) {
      for (var i = 0, max = state.checkoutFeeList.length; i < max; i++) {
        if (checkoutFee.id == state.checkoutFeeList[i].id) {
          state.checkoutFeeList[i] = checkoutFee;
          return;
        }
      }
    }
    state.checkoutFeeList.push(checkoutFee);
  },
  UPDATE_CHECKOUT_FEE: function UPDATE_CHECKOUT_FEE(state, checkoutFee) {
    if (!state.checkoutFeeList || !state.checkoutFeeList.length) {
      return;
    }
    for (var i = 0, max = state.checkoutFeeList.length; i < max; i++) {
      if (checkoutFee.id == state.checkoutFeeList[i].id) {
        state.checkoutFeeList[i] = checkoutFee;
        return;
      }
    }
  },
  DELETE_CHECKOUT_FEE: function DELETE_CHECKOUT_FEE(state, id) {
    if (state.checkoutFeeList.length) {
      for (var i = 0, max = state.checkoutFeeList.length; i < max; i++) {
        if (id == state.checkoutFeeList[i].id) {
          state.checkoutFeeList.splice(i, 1);
          break;
        }
      }
    }
  },
  SET_CHECKOUT_FEE_LIST: function SET_CHECKOUT_FEE_LIST(state, checkoutFeeList) {
    Object.assign(state.checkoutFeeList, checkoutFeeList);
  },
  ADD_SHIPPING: function ADD_SHIPPING(state, shipping) {
    if (state.shippingList.length) {
      for (var i = 0, max = state.shippingList.length; i < max; i++) {
        if (shipping.id == state.shippingList[i].id) {
          state.shippingList[i] = shipping;
          return;
        }
      }
    }
    state.shippingList.push(shipping);
  },
  UPDATE_SHIPPING: function UPDATE_SHIPPING(state, shipping) {
    if (!state.shippingList || !state.shippingList.length) {
      return;
    }
    for (var i = 0, max = state.shippingList.length; i < max; i++) {
      if (shipping.id == state.shippingList[i].id) {
        state.shippingList[i] = shipping;
        return;
      }
    }
  },
  DELETE_SHIPPING: function DELETE_SHIPPING(state, id) {
    if (state.shippingList.length) {
      for (var i = 0, max = state.shippingList.length; i < max; i++) {
        if (id == state.shippingList[i].id) {
          state.shippingList.splice(i, 1);
          break;
        }
      }
    }
  },
  SET_SHIPPING_LIST: function SET_SHIPPING_LIST(state, shippingList) {
    Object.assign(state.shippingList, shippingList);
  }
});
// EXTERNAL MODULE: external {"this":["wp","hooks"]}
var external_this_wp_hooks_ = __webpack_require__(13);

// EXTERNAL MODULE: external "jQuery"
var external_jQuery_ = __webpack_require__(5);
var external_jQuery_default = /*#__PURE__*/__webpack_require__.n(external_jQuery_);

// EXTERNAL MODULE: external {"this":["wp","i18n"]}
var external_this_wp_i18n_ = __webpack_require__(0);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/api/constants.js
var NONCE = wcConditions.nonce;
var DISCOUNT_TYPE = 'cart-discount';
var CHECKOUT_FEE_TYPE = 'checkout-fee';
var PRICING_TYPE = 'pricing';
var PRODUCTS_LIST_TYPE = 'products-list';
var SHIPPING_TYPE = 'shipping';
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/api/addons.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }



var getItems = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
    var data,
      response,
      _args = arguments,
      _t;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.p = _context.n) {
        case 0:
          data = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
          _context.p = 1;
          _context.n = 2;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'GET',
            dataType: 'json',
            data: _objectSpread({
              nonce: NONCE,
              action: 'wccs_get_addons'
            }, data)
          });
        case 2:
          response = _context.v;
          if (!response) {
            _context.n = 3;
            break;
          }
          return _context.a(2, response);
        case 3:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on getting items.', 'easy-woocommerce-discounts'));
        case 4:
          _context.p = 4;
          _t = _context.v;
          throw _t;
        case 5:
          return _context.a(2);
      }
    }, _callee, null, [[1, 4]]);
  }));
  return function getItems() {
    return _ref.apply(this, arguments);
  };
}();
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/store/addons.js

var shouldFetchData = function shouldFetchData(state, data) {
  if (!state || !state.loaded || data.force) {
    return true;
  }
  return false;
};
/* harmony default export */ var addons = ({
  namespaced: true,
  state: {
    isFetching: false,
    items: [],
    loaded: false
  },
  mutations: {
    setIsFetching: function setIsFetching(state, isFetching) {
      return state.isFetching = isFetching;
    },
    loaded: function loaded(state, value) {
      return state.loaded = null != value ? value : true;
    },
    setItems: function setItems(state, items) {
      return state.items = items;
    }
  },
  actions: {
    fetchItems: function fetchItems(_ref, data) {
      var dispatch = _ref.dispatch,
        commit = _ref.commit,
        state = _ref.state;
      commit('setIsFetching', true);
      getItems(data).then(function (resposne) {
        commit('setIsFetching', false);
        commit('setItems', resposne.items || []);
        commit('loaded');
      })["catch"](function (error) {
        commit('setIsFetching', false);
        console.log(error.message || 'Error occurred in getting items.');
      });
    },
    fetchItemsIfNeeded: function fetchItemsIfNeeded(_ref2, data) {
      var dispatch = _ref2.dispatch,
        state = _ref2.state;
      if (shouldFetchData(state, data)) {
        dispatch('fetchItems', data);
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/store/message.js
/* harmony default export */ var store_message = ({
  namespaced: true,
  state: {
    message: '',
    type: '',
    show: false,
    timeout: 3000
  },
  mutations: {
    setMessage: function setMessage(state, payload) {
      state.message = payload.message;
      state.type = payload.type;
      state.show = true;
      state.timeout = (payload === null || payload === void 0 ? void 0 : payload.timeout) || 3000;
    },
    hideMessage: function hideMessage(state) {
      state.show = false;
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/store/index.js






external_Vue_default.a.use(external_Vuex_default.a);
function createStore(productsList, discountList, pricingList, shippingList) {
  return Object(external_this_wp_hooks_["applyFilters"])('wccs_store', new external_Vuex_default.a.Store({
    strict: true,
    modules: Object(external_this_wp_hooks_["applyFilters"])('wccs_store_modules', {
      addons: addons,
      message: store_message
    }),
    state: {
      productsList: productsList,
      discountList: discountList,
      pricingList: pricingList,
      shippingList: shippingList
    },
    mutations: mutations
  }));
}
// EXTERNAL MODULE: external "VueRouter"
var external_VueRouter_ = __webpack_require__(44);
var external_VueRouter_default = /*#__PURE__*/__webpack_require__.n(external_VueRouter_);

// EXTERNAL MODULE: external {"this":["ewd","pages"]}
var external_this_ewd_pages_ = __webpack_require__(9);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/ProductsList.vue?vue&type=template&id=37c2fa32&
var ProductsListvue_type_template_id_37c2fa32_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-products-list"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Products', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":"/products/new"}},[_vm._v(_vm._s(_vm.__( 'Add New', 'easy-woocommerce-discounts' )))])],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.productsList.length),expression:"productsList.length"}],staticClass:"asnp-flex asnp-flex-col"},[_c('div',{staticClass:"asnp-my-2 asnp-overflow-x-auto sm:asnp-mx-6 lg:asnp-mx-8"},[_c('div',{staticClass:"asnp-py-2 asnp-align-middle asnp-inline-block asnp-min-w-full sm:asnp-px-6 lg:asnp-px-8"},[_c('div',{staticClass:"asnp-shadow asnp-overflow-hidden asnp-border-b asnp-border-gray-200 sm:asnp-rounded-lg"},[_c('table',{staticClass:"asnp-min-w-full asnp-divide-y asnp-divide-gray-200",attrs:{"id":"wccs-products-list"}},[_c('thead',{staticClass:"asnp-bg-gray-50"},[_c('tr',[_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}}),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'ID',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Name',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Shortcode',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Actions',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")])])]),_vm._v(" "),_c('tbody',{staticClass:"asnp-bg-white asnp-divide-y asnp-divide-gray-200"},_vm._l((_vm.productsList),function(products){return _c('tr',{key:products.id},[_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"}),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(products.id)+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"hover:asnp-text-indigo-500 focus:asnp-outline-none focus:asnp-shadow-none",attrs:{"to":'/products/' + products.id}},[_vm._v(_vm._s(products.name))])],1),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_vm._v("\n\t\t\t\t\t\t\t\t\t[wccs_products_list id=\""+_vm._s(products.id)+"\"]\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-flex asnp-space-x-1 asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/products/' + products.id,"title":_vm.__(
												'Edit',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-edit",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"title":_vm.__(
												'Duplicate',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.duplicate( products.id )}}},[_c('i',{staticClass:"fa fa-copy",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-delete",attrs:{"title":_vm.__(
												'Delete',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.showDeleteWarning( products.id )}}},[_c('i',{staticClass:"fa fa-remove",attrs:{"aria-hidden":"true"}})])],1)])}),0)])])])])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.productsList.length),expression:"! productsList.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' ),"style-object":{ width: '600px', 'margin-top': '20px' }}})],1),_vm._v(" "),(_vm.showDeleteModal)?_c('modal',{on:{"apply":function($event){return _vm.deleteProducts()},"cancel":function($event){_vm.showDeleteModal = false}}}):_vm._e()],1)}
var staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ProductsList.vue?vue&type=template&id=37c2fa32&

// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__(2);
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/api/condition.js
function condition_typeof(o) { "@babel/helpers - typeof"; return condition_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, condition_typeof(o); }
function condition_regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return condition_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (condition_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, condition_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, condition_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), condition_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", condition_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), condition_regeneratorDefine2(u), condition_regeneratorDefine2(u, o, "Generator"), condition_regeneratorDefine2(u, n, function () { return this; }), condition_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (condition_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function condition_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } condition_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { condition_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, condition_regeneratorDefine2(e, r, n, t); }
function condition_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function condition_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? condition_ownKeys(Object(t), !0).forEach(function (r) { condition_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : condition_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function condition_defineProperty(e, r, t) { return (r = condition_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function condition_toPropertyKey(t) { var i = condition_toPrimitive(t, "string"); return "symbol" == condition_typeof(i) ? i : i + ""; }
function condition_toPrimitive(t, r) { if ("object" != condition_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != condition_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function condition_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function condition_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { condition_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { condition_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }



var condition_save = /*#__PURE__*/function () {
  var _ref = condition_asyncToGenerator(/*#__PURE__*/condition_regenerator().m(function _callee(data) {
    var response, _t;
    return condition_regenerator().w(function (_context) {
      while (1) switch (_context.p = _context.n) {
        case 0:
          if (data) {
            _context.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Data is required.', 'easy-woocommerce-discounts'));
        case 1:
          if (data.type) {
            _context.n = 2;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Type is required.', 'easy-woocommerce-discounts'));
        case 2:
          _context.p = 2;
          _context.n = 3;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'POST',
            dataType: 'json',
            data: condition_objectSpread({
              nonce: NONCE,
              action: 'wccs_save_condition'
            }, data)
          });
        case 3:
          response = _context.v;
          if (!response) {
            _context.n = 4;
            break;
          }
          return _context.a(2, response);
        case 4:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on saving the item.', 'easy-woocommerce-discounts'));
        case 5:
          _context.p = 5;
          _t = _context.v;
          throw _t;
        case 6:
          return _context.a(2);
      }
    }, _callee, null, [[2, 5]]);
  }));
  return function save(_x) {
    return _ref.apply(this, arguments);
  };
}();
var update = /*#__PURE__*/function () {
  var _ref2 = condition_asyncToGenerator(/*#__PURE__*/condition_regenerator().m(function _callee2(data) {
    var response, _t2;
    return condition_regenerator().w(function (_context2) {
      while (1) switch (_context2.p = _context2.n) {
        case 0:
          if (data) {
            _context2.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Data is required to update an item.', 'easy-woocommerce-discounts'));
        case 1:
          if (!(!data.id || isNaN(data.id * 1) || 0 >= data.id * 1)) {
            _context2.n = 2;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Item ID is required to update it.', 'easy-woocommerce-discounts'));
        case 2:
          if (data.type) {
            _context2.n = 3;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Type is required.', 'easy-woocommerce-discounts'));
        case 3:
          _context2.p = 3;
          _context2.n = 4;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'POST',
            dataType: 'json',
            data: condition_objectSpread({
              nonce: NONCE,
              action: 'wccs_update_condition'
            }, data)
          });
        case 4:
          response = _context2.v;
          if (!response) {
            _context2.n = 5;
            break;
          }
          return _context2.a(2, response);
        case 5:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on updating the item.', 'ewd-auto-add-products'));
        case 6:
          _context2.p = 6;
          _t2 = _context2.v;
          throw _t2;
        case 7:
          return _context2.a(2);
      }
    }, _callee2, null, [[3, 6]]);
  }));
  return function update(_x2) {
    return _ref2.apply(this, arguments);
  };
}();
var condition_deleteItem = /*#__PURE__*/function () {
  var _ref3 = condition_asyncToGenerator(/*#__PURE__*/condition_regenerator().m(function _callee3(data) {
    var response, _t3;
    return condition_regenerator().w(function (_context3) {
      while (1) switch (_context3.p = _context3.n) {
        case 0:
          data.id = null != data.id ? data.id * 1 : 0;
          if (!(isNaN(data.id) || 0 >= data.id)) {
            _context3.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('ID is required to delete an item.', 'easy-woocommerce-discounts'));
        case 1:
          if (data.type) {
            _context3.n = 2;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Type is required.', 'easy-woocommerce-discounts'));
        case 2:
          _context3.p = 2;
          _context3.n = 3;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'GET',
            dataType: 'json',
            data: condition_objectSpread({
              nonce: NONCE,
              action: 'wccs_delete_condition'
            }, data)
          });
        case 3:
          response = _context3.v;
          if (!response) {
            _context3.n = 4;
            break;
          }
          return _context3.a(2, response);
        case 4:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on deleting the item.', 'easy-woocommerce-discounts'));
        case 5:
          _context3.p = 5;
          _t3 = _context3.v;
          throw _t3;
        case 6:
          return _context3.a(2);
      }
    }, _callee3, null, [[2, 5]]);
  }));
  return function deleteItem(_x3) {
    return _ref3.apply(this, arguments);
  };
}();
var condition_duplicate = /*#__PURE__*/function () {
  var _ref4 = condition_asyncToGenerator(/*#__PURE__*/condition_regenerator().m(function _callee4(data) {
    var response, _t4;
    return condition_regenerator().w(function (_context4) {
      while (1) switch (_context4.p = _context4.n) {
        case 0:
          data.id = null != data.id ? data.id * 1 : 0;
          if (!(isNaN(data.id) || 0 >= data.id)) {
            _context4.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('ID is required to duplicate an item.', 'easy-woocommerce-discounts'));
        case 1:
          if (data.type) {
            _context4.n = 2;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Type is required.', 'easy-woocommerce-discounts'));
        case 2:
          _context4.p = 2;
          _context4.n = 3;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'POST',
            dataType: 'json',
            data: condition_objectSpread({
              nonce: NONCE,
              action: 'wccs_duplicate_condition'
            }, data)
          });
        case 3:
          response = _context4.v;
          if (!response) {
            _context4.n = 4;
            break;
          }
          return _context4.a(2, response);
        case 4:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on duplicating the item.', 'easy-woocommerce-discounts'));
        case 5:
          _context4.p = 5;
          _t4 = _context4.v;
          throw _t4;
        case 6:
          return _context4.a(2);
      }
    }, _callee4, null, [[2, 5]]);
  }));
  return function duplicate(_x4) {
    return _ref4.apply(this, arguments);
  };
}();
var reorder = /*#__PURE__*/function () {
  var _ref5 = condition_asyncToGenerator(/*#__PURE__*/condition_regenerator().m(function _callee5(data) {
    var response, _t5;
    return condition_regenerator().w(function (_context5) {
      while (1) switch (_context5.p = _context5.n) {
        case 0:
          if (!(!data || !data.conditions || !data.conditions.length)) {
            _context5.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Items is required for reordering.', 'easy-woocommerce-discounts'));
        case 1:
          if (data.type) {
            _context5.n = 2;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Type is required.', 'easy-woocommerce-discounts'));
        case 2:
          _context5.p = 2;
          _context5.n = 3;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'POST',
            dataType: 'json',
            data: condition_objectSpread({
              nonce: NONCE,
              action: 'wccs_update_conditions_ordering'
            }, data)
          });
        case 3:
          response = _context5.v;
          if (!response) {
            _context5.n = 4;
            break;
          }
          return _context5.a(2, response);
        case 4:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on duplicating the item.', 'easy-woocommerce-discounts'));
        case 5:
          _context5.p = 5;
          _t5 = _context5.v;
          throw _t5;
        case 6:
          return _context5.a(2);
      }
    }, _callee5, null, [[2, 5]]);
  }));
  return function reorder(_x5) {
    return _ref5.apply(this, arguments);
  };
}();
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/ProductsList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var ProductsListvue_type_script_lang_js_ = ({
  name: 'products-list',
  data: function data() {
    return {
      productsList: cloneDeep_default()(this.$store.state.productsList),
      showLoading: false,
      showDeleteModal: false,
      deleteId: 0
    };
  },
  methods: {
    showDeleteWarning: function showDeleteWarning(id) {
      this.deleteId = id;
      this.showDeleteModal = true;
    },
    deleteProducts: function deleteProducts() {
      var _this = this;
      this.showDeleteModal = false;
      if (!this.deleteId) {
        return;
      }
      this.showLoading = true;
      condition_deleteItem({
        id: this.deleteId,
        type: PRODUCTS_LIST_TYPE
      }).then(function (response) {
        if (1 == response.success) {
          _this.$store.commit('DELETE_PRODUCTS_LIST', _this.deleteId);
          _this.productsList = cloneDeep_default()(_this.$store.state.productsList);
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
      });
    },
    duplicate: function duplicate(id) {
      var _this2 = this;
      this.showLoading = true;
      condition_duplicate({
        id: id,
        type: PRODUCTS_LIST_TYPE
      }).then(function (response) {
        if (1 == response.success && response.conditions) {
          _this2.$store.commit('SET_PRODUCTS_LIST', response.conditions);
          _this2.productsList = cloneDeep_default()(_this2.$store.state.productsList);
        }
        _this2.showLoading = false;
      })["catch"](function (error) {
        _this2.showLoading = false;
      });
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ProductsList.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_ProductsListvue_type_script_lang_js_ = (ProductsListvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ProductsList.vue





/* normalize component */

var ProductsList_component = Object(componentNormalizer["a" /* default */])(
  views_ProductsListvue_type_script_lang_js_,
  ProductsListvue_type_template_id_37c2fa32_render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductsList = (ProductsList_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/ProductsView.vue?vue&type=template&id=5eaae9c3&
var ProductsViewvue_type_template_id_5eaae9c3_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-products-view"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Products', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-secondary wccs-page-title-action",attrs:{"to":"/products-list","tag":"button"}},[_vm._v(_vm._s(_vm.__( 'Cancel', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary wccs-page-title-action",attrs:{"type":"button"},on:{"click":_vm.saveConditions}},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Save', 'easy-woocommerce-discounts' ))+"\n\t\t")])],1),_vm._v(" "),(_vm.saleBadgesAdv)?_c('product-labels'):_vm._e(),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSave),expression:"showSave"}],attrs:{"type":"danger","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Please save changes.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.saveErrors),expression:"saveErrors"}],attrs:{"type":"danger","title":_vm.__( 'Warning!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There are some errors in the form please fix them and save it again.',
					'easy-woocommerce-discounts'
				),"dismissable":true},on:{"dismiss":function($event){_vm.saveErrors = false}}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.savedSuccessfully),expression:"savedSuccessfully"}],attrs:{"type":"success","title":_vm.__( 'Success!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Saved successfully.', 'easy-woocommerce-discounts' ),"dismissable":true},on:{"dismiss":function($event){_vm.savedSuccessfully = false}}})],1),_vm._v(" "),_c('div',{staticClass:"asnp-mt-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Name', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.products.name),expression:"products.name"}],staticClass:"asnp-block asnp-text-field",class:{
					'wccs-field-error': _vm.$v.products.name.$error,
				},attrs:{"type":"text"},domProps:{"value":(_vm.products.name)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.products, "name", $event.target.value)},function($event){return _vm.$v.products.name.$touch()}]}}),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.products.name.required),expression:"! $v.products.name.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Paginate', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.products.paginate )},on:{"input":function($event){return _vm.setToggle( $event, 'paginate', 'true', 'false' )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'If enabled it will paginate products otherwise it will show all of the products without pagination.',
					'easy-woocommerce-discounts'
				)))])])]),_vm._v(" "),_c('h3',{staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Include products', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-mb-4"},[_vm._v("\n\t\t"+_vm._s(_vm.__(
				'Products that will be included in products list result.',
				'easy-woocommerce-discounts'
			))+"\n\t")]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.products.include.length),expression:"! products.include.length"}],attrs:{"type":_vm.productsAlertType,"title":_vm.productsAlertTitle,"message":_vm.__(
					'There is not any product',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('transition-group',{attrs:{"name":"list-fade","mode":"out-in","tag":"div"}},_vm._l((_vm.products.include),function(include,index){return _c('products-select-item',{key:_vm.getKey( include, 'include' ),attrs:{"products":include,"index":index,"hiddenOptions":[
				'product_variations_in_list',
				'product_variations_not_in_list',
				'product_attributes' ],"ignoreGroups":[ 'product_properties' ],"type":"include"},on:{"productsUpdated":function ( products ) { return _vm.onIncludeProductUpdated( products, index ); },"deleteItem":function($event){return _vm.onDeleteItem( 'include', index )}}})}),1),_vm._v(" "),_c('p',[_c('button',{staticClass:"asnp-btn asnp-btn-primary",on:{"click":_vm.addNewIncludeProducts}},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Add', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('h3',{staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Exclude products', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-mb-4"},[_vm._v("\n\t\t"+_vm._s(_vm.__(
				'Products that will be excluded from results of products list.',
				'easy-woocommerce-discounts'
			))+"\n\t")]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.products.exclude.length),expression:"! products.exclude.length"}],attrs:{"type":_vm.productsAlertType,"title":_vm.productsAlertTitle,"message":_vm.__(
					'There is not any product',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('transition-group',{attrs:{"name":"list-fade","mode":"out-in","tag":"div"}},_vm._l((_vm.products.exclude),function(exclude,index){return _c('products-select-item',{key:_vm.getKey( exclude, 'exclude' ),attrs:{"products":exclude,"index":index,"hiddenOptions":[
				'all_products',
				'product_variations_in_list',
				'product_variations_not_in_list',
				'product_attributes' ],"ignoreGroups":[ 'product_properties' ],"type":"exclude"},on:{"productsUpdated":function ( products ) { return _vm.onExcludeProductUpdated( products, index ); },"deleteItem":function($event){return _vm.onDeleteItem( 'exclude', index )}}})}),1),_vm._v(" "),_c('p',[_c('button',{staticClass:"asnp-btn asnp-btn-primary",on:{"click":_vm.addNewExcludeProducts}},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Add', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Date Time', 'easy-woocommerce-discounts' ))+"\n\t\t\t"),_c('current-time')],1)]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.products.date_time.length),expression:"! products.date_time.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any date time.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('date-time-container',{attrs:{"items":_vm.products.date_time},on:{"dateTimeUpdated":_vm.onDateTimeItemUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewDateTime,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Conditions', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.products.conditions.length),expression:"! products.conditions.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any condition.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('conditions-container',{attrs:{"items":_vm.products.conditions,"ignoreGroups":_vm.ignoreGroups},on:{"conditionUpdated":_vm.onConditionUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewCondition,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}})],1)}
var ProductsViewvue_type_template_id_5eaae9c3_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ProductsView.vue?vue&type=template&id=5eaae9c3&

// EXTERNAL MODULE: ./node_modules/vuelidate/lib/validators/required.js
var required = __webpack_require__(6);
var required_default = /*#__PURE__*/__webpack_require__.n(required);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelectItem.vue?vue&type=template&id=1cfb1942&
var ProductsSelectItemvue_type_template_id_1cfb1942_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"wccs-products-select-item wccs-dropdown-item"},[_c('div',{class:_vm.bodyClass},[_c('products-select',{attrs:{"products":_vm.myProducts,"hidden-rows":_vm.hiddenRows,"ignoreGroups":_vm.ignoreGroups,"hiddenOptions":_vm.hiddenOptions},on:{"productsUpdated":_vm.onProductsUpdated}}),_vm._v(" "),_c('span',{staticClass:"wccs-dropdown-item-control wccs-products-select-item-delete fa fa-trash",attrs:{"title":_vm.__( 'Delete', 'easy-woocommerce-discounts' )},on:{"click":_vm.deleteItem}})],1)])}
var ProductsSelectItemvue_type_template_id_1cfb1942_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectItem.vue?vue&type=template&id=1cfb1942&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelect.vue?vue&type=template&id=70520e48&
var ProductsSelectvue_type_template_id_70520e48_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"wccs-dropdown-content"},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showRow( 'quantity' )),expression:"showRow( 'quantity' )"}],staticClass:"wccs-dropdown-element"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.myProducts.quantity),expression:"myProducts.quantity"}],staticClass:"asnp-text-field",attrs:{"type":"number","placeholder":_vm.__( 'Quantity', 'easy-woocommerce-discounts' )},domProps:{"value":(_vm.myProducts.quantity)},on:{"change":_vm.onChange,"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.myProducts, "quantity", $event.target.value)}}})]),_vm._v(" "),_c('div',{staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"options":_vm.getProductsOptions()},on:{"input":_vm.onChange},model:{value:(_vm.myProducts.item),callback:function ($$v) {_vm.$set(_vm.myProducts, "item", $$v)},expression:"myProducts.item"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showUnionType),expression:"showUnionType"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myProducts.union_type),expression:"myProducts.union_type"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myProducts, "union_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"at_least_one_of"}},[_vm._v(_vm._s(_vm.__( 'At least one of', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"all_of"}},[_vm._v(_vm._s(_vm.__( 'All of', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"only"}},[_vm._v(_vm._s(_vm.__( 'Only', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"none_of"}},[_vm._v(_vm._s(_vm.__( 'None of', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showProducts),expression:"showProducts"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"is-ajax":true,"ajax-type":"products","multiple":true,"minimum-input-length":3},on:{"input":_vm.onChange},model:{value:(_vm.myProducts.products),callback:function ($$v) {_vm.$set(_vm.myProducts, "products", $$v)},expression:"myProducts.products"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showVariations),expression:"showVariations"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"is-ajax":true,"ajax-type":"variations","multiple":true,"minimum-input-length":3},on:{"input":_vm.onChange},model:{value:(_vm.myProducts.variations),callback:function ($$v) {_vm.$set(_vm.myProducts, "variations", $$v)},expression:"myProducts.variations"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCategories),expression:"showCategories"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"is-ajax":true,"ajax-type":"categories","multiple":true,"minimum-input-length":3},on:{"input":_vm.onChange},model:{value:(_vm.myProducts.categories),callback:function ($$v) {_vm.$set(_vm.myProducts, "categories", $$v)},expression:"myProducts.categories"}})],1)])}
var ProductsSelectvue_type_template_id_70520e48_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelect.vue?vue&type=template&id=70520e48&

// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/components/vue-datepicker.vue
var vue_datepicker = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Select2.vue?vue&type=template&id=35bab97c&
var Select2vue_type_template_id_35bab97c_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:("wccs-select2-container " + (this.className))},[_c('img',{directives:[{name:"show",rawName:"v-show",value:(_vm.loading),expression:"loading"}],staticClass:"waiting asnp-border-0 asnp-ml-1",attrs:{"alt":"processing","src":"images/spinner.gif"}}),_vm._v(" "),_c('select',{directives:[{name:"show",rawName:"v-show",value:(! _vm.loading),expression:"! loading"}],ref:"select",staticClass:"asnp-select-field",style:(_vm.styleObject),attrs:{"id":_vm.id,"multiple":_vm.isMultiple}},_vm._l((_vm.defaultOptions),function(option){return _c('option',{key:option.id,attrs:{"selected":"selected","disabled":option.disabled || false},domProps:{"value":option.id}},[_vm._v(_vm._s(option.text))])}),0)])}
var Select2vue_type_template_id_35bab97c_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Select2.vue?vue&type=template&id=35bab97c&

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/api/options.js
function options_typeof(o) { "@babel/helpers - typeof"; return options_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, options_typeof(o); }
function options_regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return options_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (options_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, options_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, options_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), options_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", options_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), options_regeneratorDefine2(u), options_regeneratorDefine2(u, o, "Generator"), options_regeneratorDefine2(u, n, function () { return this; }), options_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (options_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function options_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } options_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { options_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, options_regeneratorDefine2(e, r, n, t); }
function options_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function options_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? options_ownKeys(Object(t), !0).forEach(function (r) { options_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : options_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function options_defineProperty(e, r, t) { return (r = options_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function options_toPropertyKey(t) { var i = options_toPrimitive(t, "string"); return "symbol" == options_typeof(i) ? i : i + ""; }
function options_toPrimitive(t, r) { if ("object" != options_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != options_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function options_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function options_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { options_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { options_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }



var options_getItems = /*#__PURE__*/function () {
  var _ref = options_asyncToGenerator(/*#__PURE__*/options_regenerator().m(function _callee(data) {
    var response, _t;
    return options_regenerator().w(function (_context) {
      while (1) switch (_context.p = _context.n) {
        case 0:
          if (data) {
            _context.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Data is required.', 'easy-woocommerce-discounts'));
        case 1:
          _context.p = 1;
          _context.n = 2;
          return external_jQuery_default.a.ajax({
            url: ajaxurl,
            type: 'POST',
            dataType: 'json',
            data: options_objectSpread({
              nonce: NONCE,
              action: 'wccs_select_options'
            }, data)
          });
        case 2:
          response = _context.v;
          if (!response) {
            _context.n = 3;
            break;
          }
          return _context.a(2, response);
        case 3:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on getting items.', 'easy-woocommerce-discounts'));
        case 4:
          _context.p = 4;
          _t = _context.v;
          throw _t;
        case 5:
          return _context.a(2);
      }
    }, _callee, null, [[1, 4]]);
  }));
  return function getItems(_x) {
    return _ref.apply(this, arguments);
  };
}();
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Select2.vue?vue&type=script&lang=js&
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var Select2vue_type_script_lang_js_ = ({
  name: 'select2',
  props: {
    id: {
      type: String,
      "default": ''
    },
    options: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    value: {
      type: [String, Number, Array]
    },
    multiple: {
      type: Boolean,
      "default": false
    },
    styleObject: {
      type: Object,
      "default": function _default() {
        return {
          width: '100%'
        };
      }
    },
    isAjax: {
      type: Boolean,
      "default": false
    },
    minimumInputLength: {
      type: Number,
      "default": 3
    },
    ajaxType: {
      type: String,
      "default": ''
    },
    placeholder: {
      type: String,
      "default": ''
    },
    allowClear: {
      type: Boolean,
      "default": false
    },
    className: {
      type: String,
      "default": ''
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  data: function data() {
    return {
      defaultOptions: [],
      loading: false
    };
  },
  computed: {
    isMultiple: function isMultiple() {
      return true === this.multiple || 'true' === this.multiple || 1 === this.multiple || '1' === this.multiple;
    }
  },
  mounted: function mounted() {
    var _this = this;
    this.getDefaultOptions().then(function (result) {
      _this.init();
    })["catch"](function (err) {});
  },
  methods: {
    getDefaultOptions: function getDefaultOptions() {
      var _this2 = this;
      if (this.isAjax && this.ajaxType) {
        if (this.value) {
          this.loading = true;
          return options_getItems({
            options: this.value,
            type: this.ajaxType
          }).then(function (response) {
            _this2.loading = false;
            _this2.defaultOptions = response.items ? response.items : [];
            return Promise.resolve(true);
          })["catch"](function (error) {
            _this2.loading = false;
            return Promise.reject(error);
          });
        }
      }
      return Promise.resolve(true);
    },
    init: function init() {
      var vm = this;
      var $el = jQuery(this.$refs.select);
      if (this.isAjax) {
        $el.select2({
          ajax: {
            url: ajaxurl,
            dataType: 'json',
            delay: 250,
            data: function data(params) {
              return {
                term: params.term,
                type: vm.ajaxType,
                action: 'wccs_select_autocomplete',
                nonce: vm.wccsNonce
              };
            },
            processResults: function processResults(data) {
              return {
                results: data && data.items ? data.items : []
              };
            }
          },
          minimumInputLength: this.minimumInputLength,
          cache: true,
          placeholder: this.placeholder,
          allowClear: this.allowClear,
          disabled: this.disabled
        });
      } else {
        $el.select2({
          data: this.options,
          placeholder: this.placeholder,
          allowClear: this.allowClear,
          disabled: this.disabled
        });
        $el.val(this.value);
      }
      $el.trigger('change')
      // emit event on change.
      .on('change', function () {
        vm.$emit('input', jQuery(this).val());
      });
    }
  },
  watch: {
    value: function value(_value) {
      if (this.isMultiple) {
        if (_value && (null == jQuery(this.$refs.select).val() || _toConsumableArray(_value).sort().join(',') !== _toConsumableArray(jQuery(this.$refs.select).val()).sort().join(','))) {
          jQuery(this.$refs.select).val(_value).trigger('change');
        } else if ('' === _value && (null == jQuery(this.$refs.select).val() || '' !== _toConsumableArray(jQuery(this.$refs.select).val()).sort().join(','))) {
          jQuery(this.$refs.select).val('').trigger('change');
        }
      } else {
        jQuery(this.$refs.select).val(_value).trigger('change');
      }
    },
    options: function options(_options) {
      // update options
      jQuery(this.$refs.select).select2({
        data: _options
      });
    },
    disabled: function disabled(value) {
      var $el = jQuery(this.$refs.select);

      // Update the select element's disabled property directly
      $el.prop('disabled', value);

      // Refresh the select2 UI
      $el.trigger('change.select2');
    }
  },
  destroyed: function destroyed() {
    jQuery(this.$refs.select).off().select2('destroy');
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Select2.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Select2vue_type_script_lang_js_ = (Select2vue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Select2.vue





/* normalize component */

var Select2_component = Object(componentNormalizer["a" /* default */])(
  components_Select2vue_type_script_lang_js_,
  Select2vue_type_template_id_35bab97c_render,
  Select2vue_type_template_id_35bab97c_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Select2 = (Select2_component.exports);
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/mixins/DateTimeMixin.js
function DateTimeMixin_typeof(o) { "@babel/helpers - typeof"; return DateTimeMixin_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, DateTimeMixin_typeof(o); }
/* harmony default export */ var DateTimeMixin = ({
  methods: {
    onDateTimeTypeChange: function onDateTimeTypeChange() {
      if ('date' === this.myDateTimeCondition.type) {
        this.myDateTimeCondition.start.time = this.myDateTimeCondition.start.time.substr(0, 10);
        this.myDateTimeCondition.end.time = this.myDateTimeCondition.end.time.substr(0, 10);
      }
    },
    getDays: function getDays() {
      return [{
        id: 'Saturday',
        text: 'Saturday'
      }, {
        id: 'Sunday',
        text: 'Sunday'
      }, {
        id: 'Monday',
        text: 'Monday'
      }, {
        id: 'Tuesday',
        text: 'Tuesday'
      }, {
        id: 'Wednesday',
        text: 'Wednesday'
      }, {
        id: 'Thursday',
        text: 'Thursday'
      }, {
        id: 'Friday',
        text: 'Friday'
      }];
    },
    getDateOption: function getDateOption(options) {
      options = options && DateTimeMixin_typeof(options) === 'object' && Object === options.constructor ? options : {};
      return Object.assign({}, {
        type: 'day',
        week: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
        month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        format: 'YYYY-MM-DD'
      }, options);
    },
    getDateTimeOption: function getDateTimeOption(options) {
      options = options && DateTimeMixin_typeof(options) === 'object' && Object === options.constructor ? options : {};
      return Object.assign({}, {
        type: 'min',
        week: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
        month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        format: 'YYYY-MM-DD HH:mm'
      }, options);
    },
    getMultiDayOption: function getMultiDayOption(options) {
      options = options && DateTimeMixin_typeof(options) === 'object' && Object === options.constructor ? options : {};
      return Object.assign({}, {
        type: 'multi-day',
        week: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
        month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        format: 'YYYY-MM-DD'
      }, options);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelect.vue?vue&type=script&lang=js&
function ProductsSelectvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return ProductsSelectvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, ProductsSelectvue_type_script_lang_js_typeof(o); }
function ProductsSelectvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function ProductsSelectvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ProductsSelectvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { ProductsSelectvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ProductsSelectvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function ProductsSelectvue_type_script_lang_js_defineProperty(e, r, t) { return (r = ProductsSelectvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function ProductsSelectvue_type_script_lang_js_toPropertyKey(t) { var i = ProductsSelectvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == ProductsSelectvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function ProductsSelectvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != ProductsSelectvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != ProductsSelectvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var ProductsSelectvue_type_script_lang_js_ = ({
  name: 'products-select',
  mixins: [DateTimeMixin],
  props: {
    products: {
      type: Object
    },
    hiddenRows: {
      type: Array,
      "default": function _default() {
        return ['quantity'];
      }
    },
    hiddenOptions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    ignoreGroups: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  },
  data: function data() {
    var myProducts = ProductsSelectvue_type_script_lang_js_objectSpread(ProductsSelectvue_type_script_lang_js_objectSpread({}, {
      attributes: '',
      meta_field_key: '',
      meta_field_condition: 'empty',
      meta_field_value: '',
      math_operation_type: 'less_than',
      number_value_2: '',
      yes_no: 'yes'
    }), this.products);
    return {
      myProducts: myProducts,
      productsArray: ['products_in_list', 'products_not_in_list'],
      categoriesArray: ['categories_in_list', 'categories_not_in_list'],
      topProductsArray: ['top_seller_products', 'top_earner_products', 'top_free_products'],
      limitArray: ['top_seller_products', 'top_earner_products', 'top_free_products', 'featured_products', 'onsale_products', 'top_rated_products', 'recently_viewed_products', 'similar_products_to_customer_bought_products', 'similar_products_to_customer_cart_products'],
      mathOperationTypeArray: ['product_regular_price', 'product_display_price', 'product_stock_quantity'],
      numberTwoArray: ['product_regular_price', 'product_display_price', 'product_stock_quantity'],
      productsOptions: null
    };
  },
  components: {
    select2: Select2,
    'date-picker': vue_datepicker["default"]
  },
  methods: {
    onChange: function onChange() {
      if (!this.showProducts) {
        this.myProducts.products = '';
      }
      if (!this.showVariations) {
        this.products.variations = '';
      }
      if (!this.showCategories) {
        this.myProducts.categories = '';
      }
      if (!this.showAttributes) {
        this.myProducts.attributes = '';
      }
      if (!this.showTags) {
        this.myProducts.tags = '';
      }
      if ('date' === this.myProducts.time_type) {
        this.myProducts.start.time = this.myProducts.start.time.substr(0, 10);
        this.myProducts.end.time = this.myProducts.end.time.substr(0, 10);
      }
      if (!this.showStartDate && !this.showStartDateTime) {
        this.myProducts.start.time = '';
      }
      if (!this.showEndDate && !this.showEndDateTime) {
        this.myProducts.end.time = '';
      }
      this.$emit('productsUpdated', this.myProducts);
    },
    showRow: function showRow(row) {
      return -1 == this.hiddenRows.indexOf(row);
    },
    showOption: function showOption(option) {
      return -1 == this.hiddenOptions.indexOf(option);
    },
    getProductsOptions: function getProductsOptions() {
      var _this = this;
      if (null != this.productsOptions) {
        return this.productsOptions;
      }
      var options = [{
        id: 'products_of',
        text: Object(external_this_wp_i18n_["__"])('Products of', 'easy-woocommerce-discounts'),
        children: [{
          id: 'categories_in_list',
          text: Object(external_this_wp_i18n_["__"])('Categories in list', 'easy-woocommerce-discounts')
        }, {
          id: 'categories_not_in_list',
          text: Object(external_this_wp_i18n_["__"])('Categories not in list', 'easy-woocommerce-discounts')
        }]
      }, {
        id: 'products',
        text: Object(external_this_wp_i18n_["__"])('Products', 'easy-woocommerce-discounts'),
        children: [{
          id: 'all_products',
          text: Object(external_this_wp_i18n_["__"])('All products', 'easy-woocommerce-discounts')
        }, {
          id: 'products_in_list',
          text: Object(external_this_wp_i18n_["__"])('Products in list', 'easy-woocommerce-discounts')
        }, {
          id: 'products_not_in_list',
          text: Object(external_this_wp_i18n_["__"])('Products not in list', 'easy-woocommerce-discounts')
        }, {
          id: 'product_variations_in_list',
          text: Object(external_this_wp_i18n_["__"])('Product variations in list', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_variations_not_in_list',
          text: Object(external_this_wp_i18n_["__"])('Product variations not in list', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'discounted_products',
          text: Object(external_this_wp_i18n_["__"])('Discounted Products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_attributes',
          text: Object(external_this_wp_i18n_["__"])('Product attributes', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'products_have_tags',
          text: Object(external_this_wp_i18n_["__"])('Products have tags', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'featured_products',
          text: Object(external_this_wp_i18n_["__"])('Featured products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'onsale_products',
          text: Object(external_this_wp_i18n_["__"])('On-sale products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'top_rated_products',
          text: Object(external_this_wp_i18n_["__"])('Top rated products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'recently_viewed_products',
          text: Object(external_this_wp_i18n_["__"])('Recently viewed products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'products_added',
          text: Object(external_this_wp_i18n_["__"])('Products added', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'top_seller_products',
          text: Object(external_this_wp_i18n_["__"])('Top seller products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'top_earner_products',
          text: Object(external_this_wp_i18n_["__"])('Top earner products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'top_free_products',
          text: Object(external_this_wp_i18n_["__"])('Top free products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'similar_products_to_customer_bought_products',
          text: Object(external_this_wp_i18n_["__"])('Similar products to customer bought products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'similar_products_to_customer_cart_products',
          text: Object(external_this_wp_i18n_["__"])('Similar products to customer cart products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'product_properties',
        text: Object(external_this_wp_i18n_["__"])('Product Properties', 'easy-woocommerce-discounts'),
        children: [{
          id: 'product_regular_price',
          text: Object(external_this_wp_i18n_["__"])('Product regular price', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_display_price',
          text: Object(external_this_wp_i18n_["__"])('Product display price', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_is_on_sale',
          text: Object(external_this_wp_i18n_["__"])('Product is on sale', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_stock_quantity',
          text: Object(external_this_wp_i18n_["__"])('Product stock quantity', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_meta_field',
          text: Object(external_this_wp_i18n_["__"])('Product meta field', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }];

      // Product custom taxonomies.
      if (wcConditions.taxonomies && Object.keys(wcConditions.taxonomies).length) {
        var taxonomies = [];
        for (var taxonomy in wcConditions.taxonomies) {
          taxonomies.push({
            id: 'taxonomy_' + wcConditions.taxonomies[taxonomy].name,
            text: wcConditions.taxonomies[taxonomy].label,
            disabled: true
          });
        }
        options.push({
          id: 'product_taxonomies',
          text: Object(external_this_wp_i18n_["__"])('Product Taxonomies', 'easy-woocommerce-discounts'),
          children: taxonomies
        });
      }
      if ((!this.ignoreGroups || !this.ignoreGroups.length) && (!this.hiddenOptions || !this.hiddenOptions.length)) {
        return options;
      }

      // Filtering options.
      this.productsOptions = [];
      options.map(function (group) {
        if (-1 === _this.ignoreGroups.indexOf(group.id)) {
          group.children = group.children.filter(function (item) {
            return -1 === _this.hiddenOptions.indexOf(item.id);
          });
          _this.productsOptions.push(group);
        }
      });
      return this.productsOptions;
    }
  },
  computed: {
    showProducts: function showProducts() {
      return -1 != this.productsArray.indexOf(this.myProducts.item);
    },
    showVariations: function showVariations() {
      return 'product_variations_in_list' === this.myProducts.item || 'product_variations_not_in_list' === this.myProducts.item;
    },
    showCategories: function showCategories() {
      return -1 != this.categoriesArray.indexOf(this.myProducts.item);
    },
    showAttributes: function showAttributes() {
      return 'product_attributes' === this.myProducts.item;
    },
    showTags: function showTags() {
      return 'products_have_tags' === this.myProducts.item;
    },
    showMathOperationType: function showMathOperationType() {
      return -1 != this.mathOperationTypeArray.indexOf(this.myProducts.item);
    },
    showNumberTwo: function showNumberTwo() {
      return -1 != this.numberTwoArray.indexOf(this.myProducts.item);
    },
    showMetaField: function showMetaField() {
      return 'product_meta_field' === this.myProducts.item;
    },
    showMetaFieldValue: function showMetaFieldValue() {
      return this.showMetaField && -1 != ['contains', 'does_not_contain', 'begins_with', 'ends_with', 'equal_to', 'not_equal_to', 'less_than', 'less_equal_to', 'greater_than', 'greater_equal_to'].indexOf(this.myProducts.meta_field_condition);
    },
    showYesNo: function showYesNo() {
      return 'product_is_on_sale' === this.myProducts.item;
    },
    showUnionType: function showUnionType() {
      return -1 != ['products_have_tags', 'product_attributes'].indexOf(this.myProducts.item);
    },
    showTopProductsFilters: function showTopProductsFilters() {
      return -1 != this.topProductsArray.indexOf(this.myProducts.item);
    },
    showLimit: function showLimit() {
      return -1 != this.limitArray.indexOf(this.myProducts.item);
    },
    showTimeType: function showTimeType() {
      return 'products_added' === this.myProducts.item;
    },
    showNumberOne: function showNumberOne() {
      return this.showTimeType && -1 != ['day', 'week', 'month', 'year'].indexOf(this.myProducts.time_type);
    },
    showCurrent: function showCurrent() {
      return this.showTimeType && 'current' === this.myProducts.time_type;
    },
    showStartDate: function showStartDate() {
      return this.showTimeType && 'date' === this.myProducts.time_type;
    },
    showEndDate: function showEndDate() {
      return this.showTimeType && 'date' === this.myProducts.time_type;
    },
    showStartDateTime: function showStartDateTime() {
      return this.showTimeType && 'date_time' === this.myProducts.time_type;
    },
    showEndDateTime: function showEndDateTime() {
      return this.showTimeType && 'date_time' === this.myProducts.time_type;
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelect.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ProductsSelectvue_type_script_lang_js_ = (ProductsSelectvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelect.vue





/* normalize component */

var ProductsSelect_component = Object(componentNormalizer["a" /* default */])(
  components_ProductsSelectvue_type_script_lang_js_,
  ProductsSelectvue_type_template_id_70520e48_render,
  ProductsSelectvue_type_template_id_70520e48_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductsSelect = (ProductsSelect_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelectItem.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ProductsSelectItemvue_type_script_lang_js_ = ({
  name: 'products-select-item',
  props: {
    products: {
      type: Object
    },
    type: {
      type: String
    },
    hiddenRows: {
      type: Array,
      "default": function _default() {
        return ['quantity'];
      }
    },
    hiddenOptions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    ignoreGroups: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  },
  data: function data() {
    return {
      myProducts: this.products
    };
  },
  components: {
    'products-select': ProductsSelect
  },
  methods: {
    deleteItem: function deleteItem() {
      this.$emit('deleteItem', this.type);
    },
    onProductsUpdated: function onProductsUpdated(products) {
      this.myProducts = products;
      this.$emit('productsUpdated', this.myProducts);
    }
  },
  computed: {
    name: function name() {
      if (!/taxonomy_/g.test(this.myProducts.item)) {
        return this.myProducts.item;
      }
      var taxonomy = this.myProducts.item.replace('taxonomy_', '');
      if (null != wcConditions.taxonomies[taxonomy]) {
        return wcConditions.taxonomies[taxonomy].label;
      }
      return this.myProducts.item;
    },
    headClass: function headClass() {
      return 'wccs-products-select-item-head wccs-products-select-' + this.type + ' wccs-dropdown-item-head';
    },
    bodyClass: function bodyClass() {
      return 'wccs-products-select-item-body wccs-products-select-' + this.type + ' wccs-dropdown-item-body';
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectItem.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ProductsSelectItemvue_type_script_lang_js_ = (ProductsSelectItemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectItem.vue





/* normalize component */

var ProductsSelectItem_component = Object(componentNormalizer["a" /* default */])(
  components_ProductsSelectItemvue_type_script_lang_js_,
  ProductsSelectItemvue_type_template_id_1cfb1942_render,
  ProductsSelectItemvue_type_template_id_1cfb1942_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductsSelectItem = (ProductsSelectItem_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/DateTimeContainer.vue?vue&type=template&id=081ca986&
var DateTimeContainervue_type_template_id_081ca986_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-date-time-container"},[_vm._l((_vm.items),function(item,index){return _c('div',{key:'date-time-group-' + index},[(0 < index)?_c('div',{staticClass:"asnp-group-separator asnp-text-center asnp-text-lg asnp-text-gray-400 asnp-font-bold asnp-py-1"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'OR', 'easy-woocommerce-discounts' ))+"\n\t\t")]):_vm._e(),_vm._v(" "),_c('date-time-group',{attrs:{"items":item},on:{"dateTimeUpdated":function ( dateTime, itemIndex ) { return _vm.$emit( 'dateTimeUpdated', index, dateTime, itemIndex ); },"deleteItem":function ( itemIndex ) { return _vm.$emit( 'deleteItem', 'dateTime', itemIndex, index ); },"addItem":function($event){return _vm.$emit( 'addItem', index )},"deleteGroup":function($event){return _vm.$emit( 'deleteGroup', index, 'dateTime' )}}})],1)}),_vm._v(" "),_c('div',{staticClass:"asnp-mx-2"},[_c('button',{staticClass:"asnp-btn asnp-btn-primary",on:{"click":function($event){return _vm.$emit( 'addGroup', 'dateTime' )}}},[_vm._v("\n\t\t\t"+_vm._s(_vm.sprintf(
					_vm.__( '%s OR New Group', 'easy-woocommerce-discounts' ),
					'+'
				))+"\n\t\t")])])],2)}
var DateTimeContainervue_type_template_id_081ca986_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeContainer.vue?vue&type=template&id=081ca986&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/DateTimeGroup.vue?vue&type=template&id=5c96d61f&
var DateTimeGroupvue_type_template_id_5c96d61f_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-date-time-group asnp-border-dashed asnp-border asnp-border-gray-500 asnp-rounded-md asnp-px-2 asnp-py-4 asnp-mb-2"},[_c('transition-group',{attrs:{"name":"list-fade","mode":"out-in","tag":"div"}},_vm._l((_vm.items),function(dateTime,index){return _c('date-time-item',{key:_vm.getKey( dateTime, 'dateTime' ),attrs:{"dateTime":dateTime,"index":index},on:{"dateTimeUpdated":function ( dateTime ) { return _vm.$emit( 'dateTimeUpdated', dateTime, index ); },"deleteItem":function($event){return _vm.$emit( 'deleteItem', index )}}})}),1),_vm._v(" "),_c('div',[_c('button',{staticClass:"asnp-btn asnp-btn-secondary",on:{"click":function($event){return _vm.$emit( 'addItem' )}}},[_vm._v("\n\t\t\t"+_vm._s(_vm.sprintf(
					_vm.__( '%s And New Rule', 'easy-woocommerce-discounts' ),
					'+'
				))+"\n\t\t")]),_vm._v(" "),_c('span',{staticClass:"asnp-float-right asnp-cursor-pointer asnp-my-2 asnp-text-lg asnp-text-rose-500 hover:asnp-text-rose-600 fa fa-trash",attrs:{"title":_vm.__( 'Delete Group', 'easy-woocommerce-discounts' )},on:{"click":function($event){return _vm.$emit( 'deleteGroup' )}}})])],1)}
var DateTimeGroupvue_type_template_id_5c96d61f_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeGroup.vue?vue&type=template&id=5c96d61f&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/DateTimeItem.vue?vue&type=template&id=503d0458&
var DateTimeItemvue_type_template_id_503d0458_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"wccs-date-time-item wccs-dropdown-item"},[_c('div',{staticClass:"wccs-date-time-item-body wccs-dropdown-item-body"},[_c('div',{staticClass:"wccs-dropdown-content"},[_c('div',{staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myDateTimeCondition.type),expression:"myDateTimeCondition.type"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myDateTimeCondition, "type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onDateTimeTypeChange]}},[_c('option',{attrs:{"value":"date"}},[_vm._v(_vm._s(_vm.__( 'Date', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"date_time"}},[_vm._v(_vm._s(_vm.__( 'Date Time', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"specific_date"}},[_vm._v(_vm._s(_vm.__( 'Specific Date', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"time"}},[_vm._v(_vm._s(_vm.__( 'Time', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"days"}},[_vm._v(_vm._s(_vm.__( 'Days', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('date_time' === _vm.myDateTimeCondition.type),expression:"'date_time' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myDateTimeCondition.start,"option":_vm.getDateTimeOption( {
							placeholder: _vm.__(
								'Start',
								'easy-woocommerce-discounts'
							),
						} )}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('date_time' === _vm.myDateTimeCondition.type),expression:"'date_time' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myDateTimeCondition.end,"option":_vm.getDateTimeOption( {
							placeholder: _vm.__(
								'End',
								'easy-woocommerce-discounts'
							),
						} )}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('date' === _vm.myDateTimeCondition.type),expression:"'date' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myDateTimeCondition.start,"option":_vm.getDateOption( {
							placeholder: _vm.__(
								'Start',
								'easy-woocommerce-discounts'
							),
						} )}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('date' === _vm.myDateTimeCondition.type),expression:"'date' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myDateTimeCondition.end,"option":_vm.getDateOption( {
							placeholder: _vm.__(
								'End',
								'easy-woocommerce-discounts'
							),
						} )}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('time' === _vm.myDateTimeCondition.type),expression:"'time' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myDateTimeCondition.start_time),expression:"myDateTimeCondition.start_time"}],staticClass:"asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myDateTimeCondition, "start_time", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('option',{attrs:{"value":"00:00"}},[_vm._v("12:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"1:00"}},[_vm._v("1:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"2:00"}},[_vm._v("2:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"3:00"}},[_vm._v("3:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"4:00"}},[_vm._v("4:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"5:00"}},[_vm._v("5:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"6:00"}},[_vm._v("6:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"7:00"}},[_vm._v("7:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"8:00"}},[_vm._v("8:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"9:00"}},[_vm._v("9:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"10:00"}},[_vm._v("10:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"11:00"}},[_vm._v("11:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"12:00"}},[_vm._v("12:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"13:00"}},[_vm._v("1:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"14:00"}},[_vm._v("2:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"15:00"}},[_vm._v("3:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"16:00"}},[_vm._v("4:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"17:00"}},[_vm._v("5:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"18:00"}},[_vm._v("6:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"19:00"}},[_vm._v("7:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"20:00"}},[_vm._v("8:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"21:00"}},[_vm._v("9:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"22:00"}},[_vm._v("10:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"23:00"}},[_vm._v("11:00 pm")])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('time' === _vm.myDateTimeCondition.type),expression:"'time' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myDateTimeCondition.end_time),expression:"myDateTimeCondition.end_time"}],staticClass:"asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myDateTimeCondition, "end_time", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('option',{attrs:{"value":"00:00"}},[_vm._v("12:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"1:00"}},[_vm._v("1:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"2:00"}},[_vm._v("2:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"3:00"}},[_vm._v("3:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"4:00"}},[_vm._v("4:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"5:00"}},[_vm._v("5:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"6:00"}},[_vm._v("6:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"7:00"}},[_vm._v("7:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"8:00"}},[_vm._v("8:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"9:00"}},[_vm._v("9:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"10:00"}},[_vm._v("10:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"11:00"}},[_vm._v("11:00 am")]),_vm._v(" "),_c('option',{attrs:{"value":"12:00"}},[_vm._v("12:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"13:00"}},[_vm._v("1:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"14:00"}},[_vm._v("2:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"15:00"}},[_vm._v("3:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"16:00"}},[_vm._v("4:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"17:00"}},[_vm._v("5:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"18:00"}},[_vm._v("6:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"19:00"}},[_vm._v("7:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"20:00"}},[_vm._v("8:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"21:00"}},[_vm._v("9:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"22:00"}},[_vm._v("10:00 pm")]),_vm._v(" "),_c('option',{attrs:{"value":"23:00"}},[_vm._v("11:00 pm")])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('specific_date' === _vm.myDateTimeCondition.type),expression:"'specific_date' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myDateTimeCondition.date,"option":_vm.getMultiDayOption( {
							placeholder: _vm.__(
								'Date',
								'easy-woocommerce-discounts'
							),
						} )}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:('days' === _vm.myDateTimeCondition.type),expression:"'days' === myDateTimeCondition.type"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"options":_vm.getDays(),"multiple":true},model:{value:(_vm.myDateTimeCondition.days),callback:function ($$v) {_vm.$set(_vm.myDateTimeCondition, "days", $$v)},expression:"myDateTimeCondition.days"}})],1)]),_vm._v(" "),_c('span',{staticClass:"wccs-dropdown-item-control wccs-date-time-item-delete fa fa-trash",attrs:{"title":_vm.__( 'Delete', 'easy-woocommerce-discounts' )},on:{"click":_vm.deleteItem}})])])}
var DateTimeItemvue_type_template_id_503d0458_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeItem.vue?vue&type=template&id=503d0458&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/DateTimeItem.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var DateTimeItemvue_type_script_lang_js_ = ({
  name: 'date-time-item',
  mixins: [DateTimeMixin],
  props: {
    dateTime: {
      type: Object
    },
    index: {
      type: Number
    }
  },
  data: function data() {
    return {
      myDateTimeCondition: this.dateTime
    };
  },
  components: {
    Select2: Select2,
    'date-picker': vue_datepicker["default"]
  },
  methods: {
    deleteItem: function deleteItem() {
      this.$emit('deleteItem', 'dateTime', this.index);
    }
  },
  watch: {
    myDateTimeCondition: {
      handler: function handler(dateTime) {
        if (-1 === ['date', 'date_time'].indexOf(dateTime.type)) {
          dateTime.start.time = dateTime.end.time = '';
        }
        if ('specific_date' !== dateTime.type) {
          dateTime.date.time = '';
        }
        if ('days' !== dateTime.type) {
          dateTime.days = '';
        }
        if ('time' !== dateTime.type) {
          dateTime.start_time = dateTime.end_time = '00:00';
        }
        this.myDateTimeCondition = dateTime;
        this.$emit('dateTimeUpdated', this.myDateTimeCondition, this.index);
      },
      deep: true
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeItem.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_DateTimeItemvue_type_script_lang_js_ = (DateTimeItemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeItem.vue





/* normalize component */

var DateTimeItem_component = Object(componentNormalizer["a" /* default */])(
  components_DateTimeItemvue_type_script_lang_js_,
  DateTimeItemvue_type_template_id_503d0458_render,
  DateTimeItemvue_type_template_id_503d0458_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var DateTimeItem = (DateTimeItem_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/DateTimeGroup.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var DateTimeGroupvue_type_script_lang_js_ = ({
  components: {
    DateTimeItem: DateTimeItem
  },
  props: {
    items: {
      type: Array
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeGroup.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_DateTimeGroupvue_type_script_lang_js_ = (DateTimeGroupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeGroup.vue





/* normalize component */

var DateTimeGroup_component = Object(componentNormalizer["a" /* default */])(
  components_DateTimeGroupvue_type_script_lang_js_,
  DateTimeGroupvue_type_template_id_5c96d61f_render,
  DateTimeGroupvue_type_template_id_5c96d61f_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var DateTimeGroup = (DateTimeGroup_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/DateTimeContainer.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var DateTimeContainervue_type_script_lang_js_ = ({
  name: 'date-time-container',
  components: {
    DateTimeGroup: DateTimeGroup
  },
  props: {
    items: {
      type: Array
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeContainer.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_DateTimeContainervue_type_script_lang_js_ = (DateTimeContainervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/DateTimeContainer.vue





/* normalize component */

var DateTimeContainer_component = Object(componentNormalizer["a" /* default */])(
  components_DateTimeContainervue_type_script_lang_js_,
  DateTimeContainervue_type_template_id_081ca986_render,
  DateTimeContainervue_type_template_id_081ca986_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var DateTimeContainer = (DateTimeContainer_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ConditionsContainer.vue?vue&type=template&id=140f18e0&
var ConditionsContainervue_type_template_id_140f18e0_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-conditions-container"},[_vm._l((_vm.items),function(item,index){return _c('div',{key:'conditions-group-' + index},[(0 < index)?_c('div',{staticClass:"asnp-group-separator asnp-text-center asnp-text-lg asnp-text-gray-400 asnp-font-bold asnp-py-1"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'OR', 'easy-woocommerce-discounts' ))+"\n\t\t")]):_vm._e(),_vm._v(" "),_c('conditions-group',{attrs:{"items":item,"ignoreGroups":_vm.ignoreGroups,"ignoreItems":_vm.ignoreItems},on:{"conditionUpdated":function ( condition, itemIndex ) { return _vm.$emit( 'conditionUpdated', index, condition, itemIndex ); },"deleteItem":function ( itemIndex ) { return _vm.$emit( 'deleteItem', 'condition', itemIndex, index ); },"addItem":function($event){return _vm.$emit( 'addItem', index )},"deleteGroup":function($event){return _vm.$emit( 'deleteGroup', index, 'condition' )}}})],1)}),_vm._v(" "),_c('div',{staticClass:"asnp-mx-2"},[_c('button',{staticClass:"asnp-btn asnp-btn-primary",on:{"click":function($event){return _vm.$emit( 'addGroup', 'condition' )}}},[_vm._v("\n\t\t\t"+_vm._s(_vm.sprintf(
					_vm.__( '%s OR New Group', 'easy-woocommerce-discounts' ),
					'+'
				))+"\n\t\t")])])],2)}
var ConditionsContainervue_type_template_id_140f18e0_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionsContainer.vue?vue&type=template&id=140f18e0&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ConditionsGroup.vue?vue&type=template&id=1212b346&
var ConditionsGroupvue_type_template_id_1212b346_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-conditions-group asnp-border-dashed asnp-border asnp-border-gray-500 asnp-rounded-md asnp-px-2 asnp-py-4 asnp-mb-2"},[_c('transition-group',{attrs:{"name":"list-fade","mode":"out-in","tag":"div"}},_vm._l((_vm.items),function(condition,index){return _c('condition-item',{key:_vm.getKey( condition, 'condition' ),attrs:{"condition":condition,"index":index,"ignoreGroups":_vm.ignoreGroups,"ignoreItems":_vm.ignoreItems},on:{"conditionUpdated":function ( condition ) { return _vm.$emit( 'conditionUpdated', condition, index ); },"deleteItem":function($event){return _vm.$emit( 'deleteItem', index )}}})}),1),_vm._v(" "),_c('div',[_c('button',{staticClass:"asnp-btn asnp-btn-secondary",on:{"click":function($event){return _vm.$emit( 'addItem' )}}},[_vm._v("\n\t\t\t"+_vm._s(_vm.sprintf(
					_vm.__( '%s And New Rule', 'easy-woocommerce-discounts' ),
					'+'
				))+"\n\t\t")]),_vm._v(" "),_c('span',{staticClass:"asnp-float-right asnp-cursor-pointer asnp-my-2 asnp-text-lg asnp-text-rose-500 hover:asnp-text-rose-600 fa fa-trash",attrs:{"title":_vm.__( 'Delete Group', 'easy-woocommerce-discounts' )},on:{"click":function($event){return _vm.$emit( 'deleteGroup' )}}})])],1)}
var ConditionsGroupvue_type_template_id_1212b346_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionsGroup.vue?vue&type=template&id=1212b346&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ConditionItem.vue?vue&type=template&id=6535762a&
var ConditionItemvue_type_template_id_6535762a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"wccs-pricing-condition wccs-dropdown-item"},[_c('div',{staticClass:"wccs-pricing-condition-body wccs-dropdown-item-body"},[_c('condition',{attrs:{"condition":_vm.myCondition,"ignore-groups":_vm.ignoreGroups,"ignore-items":_vm.ignoreItems,"enabledItems":_vm.enabledItems},on:{"conditionUpdated":_vm.onConditionUpdated}}),_vm._v(" "),_c('span',{staticClass:"wccs-dropdown-item-control wccs-pricing-condition-delete fa fa-trash",attrs:{"title":_vm.__( 'Delete', 'easy-woocommerce-discounts' )},on:{"click":_vm.deleteItem}})],1)])}
var ConditionItemvue_type_template_id_6535762a_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionItem.vue?vue&type=template&id=6535762a&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Condition.vue?vue&type=template&id=148c3efc&
var Conditionvue_type_template_id_148c3efc_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"wccs-dropdown-content"},[_c('div',{staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"options":_vm.conditionOptions},on:{"input":_vm.onChange},model:{value:(_vm.myCondition.condition),callback:function ($$v) {_vm.$set(_vm.myCondition, "condition", $$v)},expression:"myCondition.condition"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showBeforeAfter),expression:"showBeforeAfter"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.before_after),expression:"myCondition.before_after"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "before_after", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"before"}},[_vm._v(_vm._s(_vm.__( 'Before', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"after"}},[_vm._v(_vm._s(_vm.__( 'After', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showTimeType),expression:"showTimeType"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.time_type),expression:"myCondition.time_type"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "time_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.showTimeTypeAllTime),expression:"showTimeTypeAllTime"}],attrs:{"value":"all_time"}},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'All time', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('option',{attrs:{"value":"date"}},[_vm._v(_vm._s(_vm.__( 'Date', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"date_time"}},[_vm._v(_vm._s(_vm.__( 'Date Time', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"current"}},[_vm._v(_vm._s(_vm.__( 'Current', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"day"}},[_vm._v(_vm._s(_vm.daysText))]),_vm._v(" "),_c('option',{attrs:{"value":"week"}},[_vm._v(_vm._s(_vm.weeksText))]),_vm._v(" "),_c('option',{attrs:{"value":"month"}},[_vm._v(_vm._s(_vm.monthsText))]),_vm._v(" "),_c('option',{attrs:{"value":"year"}},[_vm._v(_vm._s(_vm.yearsText))]),_vm._v(" "),_c('option',{attrs:{"value":"previous_days"}},[_vm._v(_vm._s(_vm.__( 'Previous days', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"previous_weeks"}},[_vm._v(_vm._s(_vm.__( 'Previous weeks', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"previous_months"}},[_vm._v(_vm._s(_vm.__( 'Previous months', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"previous_years"}},[_vm._v(_vm._s(_vm.__( 'Previous years', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showNumberOne),expression:"showNumberOne"}],staticClass:"wccs-dropdown-element"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.number_value_1),expression:"myCondition.number_value_1"}],staticClass:"asnp-text-field",attrs:{"type":"number"},domProps:{"value":(_vm.myCondition.number_value_1)},on:{"change":_vm.onChange,"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.myCondition, "number_value_1", $event.target.value)}}})]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCurrent),expression:"showCurrent"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.current),expression:"myCondition.current"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "current", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"day"}},[_vm._v(_vm._s(_vm.__( 'Day', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"week"}},[_vm._v(_vm._s(_vm.__( 'Week', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"month"}},[_vm._v(_vm._s(_vm.__( 'Month', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"year"}},[_vm._v(_vm._s(_vm.__( 'Year', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showStartDate),expression:"showStartDate"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myCondition.start,"option":_vm.getDateOption( {
					placeholder: _vm.__(
						'After',
						'easy-woocommerce-discounts'
					),
				} )},on:{"change":_vm.onChange}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showEndDate),expression:"showEndDate"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myCondition.end,"option":_vm.getDateOption( {
					placeholder: _vm.__(
						'Before',
						'easy-woocommerce-discounts'
					),
				} )},on:{"change":_vm.onChange}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showStartDateTime),expression:"showStartDateTime"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myCondition.start,"option":_vm.getDateTimeOption( {
					placeholder: _vm.__(
						'After',
						'easy-woocommerce-discounts'
					),
				} )},on:{"change":_vm.onChange}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showEndDateTime),expression:"showEndDateTime"}],staticClass:"wccs-dropdown-element"},[_c('date-picker',{attrs:{"date":_vm.myCondition.end,"option":_vm.getDateTimeOption( {
					placeholder: _vm.__(
						'Before',
						'easy-woocommerce-discounts'
					),
				} )},on:{"change":_vm.onChange}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showUnionType),expression:"showUnionType"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.union_type),expression:"myCondition.union_type"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "union_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"at_least_one_of"}},[_vm._v(_vm._s(_vm.__( 'At least one of', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"at_least_number_of"}},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'At least number of', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('option',{attrs:{"value":"all_of"}},[_vm._v(_vm._s(_vm.__( 'All of', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"only"}},[_vm._v(_vm._s(_vm.__( 'Only', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"none_of"}},[_vm._v(_vm._s(_vm.__( 'None of', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCouponsCondition),expression:"showCouponsCondition"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.coupon_condition),expression:"myCondition.coupon_condition"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "coupon_condition", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"at_least_one_of_any"}},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'At least one of any',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")]),_vm._v(" "),_c('option',{attrs:{"value":"at_least_one_of_selected"}},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'At least one of selected',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")]),_vm._v(" "),_c('option',{attrs:{"value":"all_of_selected"}},[_vm._v(_vm._s(_vm.__( 'All of selected', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"only_selected"}},[_vm._v(_vm._s(_vm.__( 'Only selected', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"none_of_selected"}},[_vm._v(_vm._s(_vm.__( 'None of selected', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"none_at_all"}},[_vm._v(_vm._s(_vm.__( 'None at all', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSelectType),expression:"showSelectType"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.select_type),expression:"myCondition.select_type"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "select_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"selected"}},[_vm._v(_vm._s(_vm.__( 'Selected', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"not_selected"}},[_vm._v(_vm._s(_vm.__( 'Not selected', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showMatch),expression:"showMatch"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.match),expression:"myCondition.match"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "match", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"match"}},[_vm._v(_vm._s(_vm.__( 'Match', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"not_match"}},[_vm._v(_vm._s(_vm.__( 'Not match', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showProducts),expression:"showProducts"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"is-ajax":true,"ajax-type":"products","multiple":true,"minimum-input-length":3},on:{"input":_vm.onChange},model:{value:(_vm.myCondition.products),callback:function ($$v) {_vm.$set(_vm.myCondition, "products", $$v)},expression:"myCondition.products"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showVariations),expression:"showVariations"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"is-ajax":true,"ajax-type":"variations","multiple":true,"minimum-input-length":3},on:{"input":_vm.onChange},model:{value:(_vm.myCondition.variations),callback:function ($$v) {_vm.$set(_vm.myCondition, "variations", $$v)},expression:"myCondition.variations"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showCategories),expression:"showCategories"}],staticClass:"wccs-dropdown-element"},[_c('select2',{attrs:{"is-ajax":true,"ajax-type":"categories","multiple":true,"minimum-input-length":3},on:{"input":_vm.onChange},model:{value:(_vm.myCondition.categories),callback:function ($$v) {_vm.$set(_vm.myCondition, "categories", $$v)},expression:"myCondition.categories"}})],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showMathOperationType),expression:"showMathOperationType"}],staticClass:"wccs-dropdown-element"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.math_operation_type),expression:"myCondition.math_operation_type"}],staticClass:"asnp-select-field",on:{"change":[function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.myCondition, "math_operation_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])},_vm.onChange]}},[_c('option',{attrs:{"value":"less_than"}},[_vm._v(_vm._s(_vm.__( 'Less than', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"less_equal_to"}},[_vm._v(_vm._s(_vm.__( 'Less equal to', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"greater_than"}},[_vm._v(_vm._s(_vm.__( 'Greater than', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"greater_equal_to"}},[_vm._v(_vm._s(_vm.__( 'Greater equal to', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"equal_to"}},[_vm._v(_vm._s(_vm.__( 'Equal to', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"not_equal_to"}},[_vm._v(_vm._s(_vm.__( 'Not equal to', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showNumberTwo),expression:"showNumberTwo"}],staticClass:"wccs-dropdown-element"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.myCondition.number_value_2),expression:"myCondition.number_value_2"}],staticClass:"asnp-text-field",attrs:{"type":"number"},domProps:{"value":(_vm.myCondition.number_value_2)},on:{"change":_vm.onChange,"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.myCondition, "number_value_2", $event.target.value)}}})])])}
var Conditionvue_type_template_id_148c3efc_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Condition.vue?vue&type=template&id=148c3efc&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Condition.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ var Conditionvue_type_script_lang_js_ = ({
  name: 'condition',
  mixins: [DateTimeMixin],
  props: {
    condition: {
      type: Object
    },
    ignoreGroups: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    ignoreItems: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    enabledItems: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  },
  data: function data() {
    var myCondition = this.condition;
    if (null == myCondition.meta_field_key) {
      myCondition = Object.assign({}, myCondition, {
        meta_field_key: '',
        meta_field_condition: 'empty',
        meta_field_value: '',
        attributes: '',
        coupon_condition: 'at_least_one_of_any',
        coupons: '',
        before_after: 'before'
      });
    }
    if (null == myCondition.match) {
      myCondition.match = 'match';
    }
    return {
      myCondition: myCondition,
      productsArray: ['products_in_cart', 'bought_products', 'quantity_of_products', 'quantity_of_bought_products', 'amount_of_bought_products', 'subtotal_of_products_include_tax', 'subtotal_of_products_exclude_tax'],
      variationsArray: ['product_variations_in_cart', 'bought_product_variations', 'quantity_of_variations', 'subtotal_of_variations_include_tax', 'subtotal_of_variations_exclude_tax', 'quantity_of_bought_variations', 'amount_of_bought_variations'],
      categoriesArray: ['product_categories_in_cart', 'bought_product_categories', 'subtotal_of_categories_include_tax', 'subtotal_of_categories_exclude_tax', 'quantity_of_categories', 'quantity_of_bought_categories', 'amount_of_bought_categories'],
      tagsArray: ['product_tags_in_cart', 'bought_product_tags', 'subtotal_of_tags_include_tax', 'subtotal_of_tags_exclude_tax', 'quantity_of_tags', 'quantity_of_bought_tags', 'amount_of_bought_tags'],
      attributesArray: ['product_attributes_in_cart', 'bought_product_attributes', 'subtotal_of_attributes_include_tax', 'subtotal_of_attributes_exclude_tax', 'quantity_of_attributes', 'quantity_of_bought_attributes', 'amount_of_bought_attributes'],
      selectTypeArray: ['customers', 'roles', 'user_capability', 'shipping_country', 'shipping_state', 'shipping_zone', 'payment_method', 'shipping_method'],
      unionTypeArray: ['products_in_cart', 'product_variations_in_cart', 'featured_products_in_cart', 'onsale_products_in_cart', 'product_categories_in_cart', 'product_tags_in_cart', 'product_attributes_in_cart', 'bought_products', 'bought_product_variations', 'bought_product_categories', 'bought_product_tags', 'bought_product_attributes', 'bought_featured_products', 'bought_onsale_products'],
      timeTypeArray: ['money_spent', 'number_of_orders', 'average_money_spent_per_order', 'last_order_date', 'number_of_products_reviews', 'bought_products', 'bought_product_variations', 'bought_product_categories', 'bought_product_attributes', 'bought_product_tags', 'bought_featured_products', 'bought_onsale_products', 'quantity_of_bought_products', 'quantity_of_bought_variations', 'quantity_of_bought_categories', 'quantity_of_bought_attributes', 'quantity_of_bought_tags', 'amount_of_bought_products', 'amount_of_bought_variations', 'amount_of_bought_categories', 'amount_of_bought_attributes', 'amount_of_bought_tags'],
      mathOperationTypeArray: ['money_spent', 'average_money_spent_per_order', 'number_of_orders', 'number_of_reviews', 'last_order_amount', 'number_of_products_reviews', 'number_of_cart_items', 'subtotal_including_tax', 'subtotal_excluding_tax', 'subtotal_including_tax_excluding_coupons', 'subtotal_excluding_tax_excluding_coupons', 'quantity_of_cart_items', 'cart_total_weight', 'subtotal_of_products_include_tax', 'subtotal_of_products_exclude_tax', 'subtotal_of_variations_include_tax', 'subtotal_of_variations_exclude_tax', 'subtotal_of_categories_include_tax', 'subtotal_of_categories_exclude_tax', 'subtotal_of_attributes_include_tax', 'subtotal_of_attributes_exclude_tax', 'subtotal_of_tags_include_tax', 'subtotal_of_tags_exclude_tax', 'quantity_of_products', 'quantity_of_variations', 'quantity_of_categories', 'quantity_of_attributes', 'quantity_of_tags', 'quantity_of_bought_products', 'quantity_of_bought_variations', 'quantity_of_bought_categories', 'quantity_of_bought_attributes', 'quantity_of_bought_tags', 'amount_of_bought_products', 'amount_of_bought_variations', 'amount_of_bought_categories', 'amount_of_bought_attributes', 'amount_of_bought_tags'],
      numberTwoArray: ['money_spent', 'average_money_spent_per_order', 'number_of_orders', 'number_of_reviews', 'last_order_amount', 'number_of_products_reviews', 'number_of_cart_items', 'subtotal_including_tax', 'subtotal_excluding_tax', 'subtotal_including_tax_excluding_coupons', 'subtotal_excluding_tax_excluding_coupons', 'quantity_of_cart_items', 'cart_total_weight', 'subtotal_of_products_include_tax', 'subtotal_of_products_exclude_tax', 'subtotal_of_variations_include_tax', 'subtotal_of_variations_exclude_tax', 'subtotal_of_categories_include_tax', 'subtotal_of_categories_exclude_tax', 'subtotal_of_attributes_include_tax', 'subtotal_of_attributes_exclude_tax', 'subtotal_of_tags_include_tax', 'subtotal_of_tags_exclude_tax', 'quantity_of_products', 'quantity_of_variations', 'quantity_of_categories', 'quantity_of_attributes', 'quantity_of_tags', 'quantity_of_bought_products', 'quantity_of_bought_variations', 'quantity_of_bought_categories', 'quantity_of_bought_attributes', 'quantity_of_bought_tags', 'amount_of_bought_products', 'amount_of_bought_variations', 'amount_of_bought_categories', 'amount_of_bought_attributes', 'amount_of_bought_tags', 'user_usage_limit']
    };
  },
  components: {
    select2: Select2,
    'date-picker': vue_datepicker["default"]
  },
  methods: {
    onChange: function onChange() {
      var resets = {
        showCustomers: 'customers',
        showRoles: 'roles',
        showProducts: 'products',
        showCategories: 'categories',
        showVariations: 'variations',
        showTags: 'tags',
        showAttributes: 'attributes',
        showCountries: 'countries',
        showStates: 'states',
        showZones: 'zones',
        showShippingMethods: 'shipping_methods',
        showPaymentMethods: 'payment_methods',
        showPostCode: 'post_code'
      };
      for (var prop in resets) {
        if (resets.hasOwnProperty(prop)) {
          if (!this[prop] && this.myCondition[resets[prop]]) {
            this.myCondition[resets[prop]] = '';
          }
        }
      }
      if (!this.showTimeTypeAllTime && 'all_time' === this.myCondition.time_type) {
        this.myCondition.time_type = 'date';
      }
      if ('date' === this.myCondition.time_type) {
        this.myCondition.start.time = this.myCondition.start.time.substr(0, 10);
        this.myCondition.end.time = this.myCondition.end.time.substr(0, 10);
      }
      if (!this.showStartDate && !this.showStartDateTime) {
        this.myCondition.start.time = '';
      }
      if (!this.showEndDate && !this.showEndDateTime) {
        this.myCondition.end.time = '';
      }
      this.$emit('conditionUpdated', this.myCondition);
    }
  },
  computed: {
    is_or_are: function is_or_are() {
      switch (this.myCondition.condition) {
        case 'last_order_amount':
        case 'subtotal_including_tax':
        case 'subtotal_excluding_tax':
        case 'subtotal_including_tax_excluding_coupons':
        case 'subtotal_excluding_tax_excluding_coupons':
          return Object(external_this_wp_i18n_["__"])('Is', 'easy-woocommerce-discounts');
        default:
          return Object(external_this_wp_i18n_["__"])('Are', 'easy-woocommerce-discounts');
      }
    },
    showCustomers: function showCustomers() {
      return 'customers' === this.myCondition.condition;
    },
    showRoles: function showRoles() {
      return 'roles' === this.myCondition.condition;
    },
    showProducts: function showProducts() {
      return -1 != this.productsArray.indexOf(this.myCondition.condition);
    },
    showVariations: function showVariations() {
      return -1 != this.variationsArray.indexOf(this.myCondition.condition);
    },
    showCategories: function showCategories() {
      return -1 != this.categoriesArray.indexOf(this.myCondition.condition);
    },
    showTags: function showTags() {
      return -1 != this.tagsArray.indexOf(this.myCondition.condition);
    },
    showAttributes: function showAttributes() {
      return -1 != this.attributesArray.indexOf(this.myCondition.condition);
    },
    showCouponsCondition: function showCouponsCondition() {
      return 'coupons_applied' === this.myCondition.condition;
    },
    showCoupons: function showCoupons() {
      return this.showCouponsCondition && -1 != ['at_least_one_of_selected', 'all_of_selected', 'only_selected', 'none_of_selected'].indexOf(this.myCondition.coupon_condition);
    },
    showCapabilities: function showCapabilities() {
      return 'user_capability' === this.myCondition.condition;
    },
    showSelectType: function showSelectType() {
      return -1 != this.selectTypeArray.indexOf(this.myCondition.condition);
    },
    showUnionType: function showUnionType() {
      return -1 != this.unionTypeArray.indexOf(this.myCondition.condition);
    },
    showMathOperationType: function showMathOperationType() {
      return -1 != this.mathOperationTypeArray.indexOf(this.myCondition.condition);
    },
    showTimeType: function showTimeType() {
      return -1 != this.timeTypeArray.indexOf(this.myCondition.condition);
    },
    showTimeTypeAllTime: function showTimeTypeAllTime() {
      return 'last_order_date' !== this.myCondition.condition;
    },
    showNumberOne: function showNumberOne() {
      return this.showTimeType && -1 != ['day', 'week', 'month', 'year'].indexOf(this.myCondition.time_type);
    },
    showNumberTwo: function showNumberTwo() {
      return -1 != this.numberTwoArray.indexOf(this.myCondition.condition);
    },
    showCurrent: function showCurrent() {
      return this.showTimeType && 'current' === this.myCondition.time_type;
    },
    showStartDate: function showStartDate() {
      return this.showTimeType && 'date' === this.myCondition.time_type;
    },
    showEndDate: function showEndDate() {
      return this.showTimeType && 'date' === this.myCondition.time_type;
    },
    showStartDateTime: function showStartDateTime() {
      return this.showTimeType && 'date_time' === this.myCondition.time_type;
    },
    showEndDateTime: function showEndDateTime() {
      return this.showTimeType && 'date_time' === this.myCondition.time_type;
    },
    showBeforeAfter: function showBeforeAfter() {
      return 'last_order_date' === this.myCondition.condition && -1 != ['current', 'day', 'week', 'month', 'year'].indexOf(this.myCondition.time_type);
    },
    showMetaField: function showMetaField() {
      return 'user_meta' === this.myCondition.condition;
    },
    showMetaFieldValue: function showMetaFieldValue() {
      return this.showMetaField && -1 != ['contains', 'does_not_contain', 'begins_with', 'ends_with', 'equal_to', 'not_equal_to', 'less_than', 'less_equal_to', 'greater_than', 'greater_equal_to'].indexOf(this.myCondition.meta_field_condition);
    },
    showCountries: function showCountries() {
      return 'shipping_country' === this.myCondition.condition;
    },
    showStates: function showStates() {
      return 'shipping_state' === this.myCondition.condition;
    },
    showZones: function showZones() {
      return 'shipping_zone' === this.myCondition.condition;
    },
    showShippingMethods: function showShippingMethods() {
      return 'shipping_method' === this.myCondition.condition;
    },
    showPaymentMethods: function showPaymentMethods() {
      return 'payment_method' === this.myCondition.condition;
    },
    showPostCode: function showPostCode() {
      return 'shipping_postcode' === this.myCondition.condition;
    },
    showMatch: function showMatch() {
      return 'shipping_postcode' === this.myCondition.condition;
    },
    daysText: function daysText() {
      if ('last_order_date' === this.myCondition.condition) {
        return Object(external_this_wp_i18n_["__"])('Days ago', 'easy-woocommerce-discounts');
      }
      return Object(external_this_wp_i18n_["__"])('After days ago', 'easy-woocommerce-discounts');
    },
    weeksText: function weeksText() {
      if ('last_order_date' === this.myCondition.condition) {
        return Object(external_this_wp_i18n_["__"])('Weeks ago', 'easy-woocommerce-discounts');
      }
      return Object(external_this_wp_i18n_["__"])('After weeks ago', 'easy-woocommerce-discounts');
    },
    monthsText: function monthsText() {
      if ('last_order_date' === this.myCondition.condition) {
        return Object(external_this_wp_i18n_["__"])('Months ago', 'easy-woocommerce-discounts');
      }
      return Object(external_this_wp_i18n_["__"])('After months ago', 'easy-woocommerce-discounts');
    },
    yearsText: function yearsText() {
      if ('last_order_date' === this.myCondition.condition) {
        return Object(external_this_wp_i18n_["__"])('Years ago', 'easy-woocommerce-discounts');
      }
      return Object(external_this_wp_i18n_["__"])('After years ago', 'easy-woocommerce-discounts');
    },
    conditionOptions: function conditionOptions() {
      var _this = this;
      var values = [{
        id: 'cart',
        text: Object(external_this_wp_i18n_["__"])('Cart', 'easy-woocommerce-discounts'),
        children: [{
          id: 'cart_total_weight',
          text: Object(external_this_wp_i18n_["__"])('Cart total weight', 'easy-woocommerce-discounts'),
          disabled: -1 === this.enabledItems.indexOf('cart_total_weight')
        }, {
          id: 'number_of_cart_items',
          text: Object(external_this_wp_i18n_["__"])('Number of cart items', 'easy-woocommerce-discounts'),
          disabled: -1 === this.enabledItems.indexOf('number_of_cart_items')
        }, {
          id: 'subtotal_including_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal including tax', 'easy-woocommerce-discounts'),
          disabled: -1 === this.enabledItems.indexOf('subtotal_including_tax')
        }, {
          id: 'subtotal_excluding_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal excluding tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_including_tax_excluding_coupons',
          text: Object(external_this_wp_i18n_["__"])('Subtotal including tax excluding coupons', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_excluding_tax_excluding_coupons',
          text: Object(external_this_wp_i18n_["__"])('Subtotal excluding tax excluding coupons', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_cart_items',
          text: Object(external_this_wp_i18n_["__"])('Quantity of cart items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'coupons_applied',
          text: Object(external_this_wp_i18n_["__"])('Coupons applied', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'max_width_of_cart_items',
          text: Object(external_this_wp_i18n_["__"])('Maximum width of cart items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'max_height_of_cart_items',
          text: Object(external_this_wp_i18n_["__"])('Maximum height of cart items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'max_length_of_cart_items',
          text: Object(external_this_wp_i18n_["__"])('Maximum length of cart items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'min_stock_of_cart_items',
          text: Object(external_this_wp_i18n_["__"])('Minimum stock quantity of cart items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'customer',
        text: Object(external_this_wp_i18n_["__"])('Customer', 'easy-woocommerce-discounts'),
        children: [{
          id: 'customers',
          text: Object(external_this_wp_i18n_["__"])('Customers', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'roles',
          text: Object(external_this_wp_i18n_["__"])('Roles', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'is_logged_in',
          text: Object(external_this_wp_i18n_["__"])('Is logged in', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'user_capability',
          text: Object(external_this_wp_i18n_["__"])('User capability', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'user_meta',
          text: Object(external_this_wp_i18n_["__"])('User meta', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'email',
          text: Object(external_this_wp_i18n_["__"])('Email', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'user_usage_limit',
          text: Object(external_this_wp_i18n_["__"])('User usage limit', 'easy-woocommerce-discounts')
        }]
      }, {
        id: 'customer_value',
        text: Object(external_this_wp_i18n_["__"])('Customer value', 'easy-woocommerce-discounts'),
        children: [{
          id: 'money_spent',
          text: Object(external_this_wp_i18n_["__"])('Money spent', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'number_of_orders',
          text: Object(external_this_wp_i18n_["__"])('Number of orders', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'last_order_amount',
          text: Object(external_this_wp_i18n_["__"])('Last order amount', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'average_money_spent_per_order',
          text: Object(external_this_wp_i18n_["__"])('Average money spent per order', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'last_order_date',
          text: Object(external_this_wp_i18n_["__"])('Last order date', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'number_of_products_reviews',
          text: Object(external_this_wp_i18n_["__"])('Number of products reviews', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'cart_items',
        text: Object(external_this_wp_i18n_["__"])('Cart items', 'easy-woocommerce-discounts'),
        children: [{
          id: 'products_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Products in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_variations_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Product variations in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'featured_products_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Featured products in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'onsale_products_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Onsale products in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_categories_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Product categories in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_attributes_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Product attributes in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_tags_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Product tags in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_classes_in_cart',
          text: Object(external_this_wp_i18n_["__"])('Shipping classes in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'cart_items_subtotal',
        text: Object(external_this_wp_i18n_["__"])('Cart items subtotal', 'easy-woocommerce-discounts'),
        children: [{
          id: 'subtotal_of_products_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of products include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_products_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of products exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_variations_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of variations include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_variations_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of variations exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_categories_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of categories include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_categories_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of categories exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_attributes_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of attributes include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_attributes_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of attributes exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_tags_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of tags include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_tags_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of tags exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_regular_products_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of regular products include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_regular_products_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of regular products exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_onsale_products_include_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of onsale products include tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'subtotal_of_onsale_products_exclude_tax',
          text: Object(external_this_wp_i18n_["__"])('Subtotal of onsale products exclude tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'cart_items_quantity',
        text: Object(external_this_wp_i18n_["__"])('Cart items quantity', 'easy-woocommerce-discounts'),
        children: [{
          id: 'quantity_of_products',
          text: Object(external_this_wp_i18n_["__"])('Quantity of products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_variations',
          text: Object(external_this_wp_i18n_["__"])('Quantity of variations', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_categories',
          text: Object(external_this_wp_i18n_["__"])('Quantity of categories', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_attributes',
          text: Object(external_this_wp_i18n_["__"])('Quantity of attributes', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_tags',
          text: Object(external_this_wp_i18n_["__"])('Quantity of tags', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'purchase_history',
        text: Object(external_this_wp_i18n_["__"])('Purchase history', 'easy-woocommerce-discounts'),
        children: [{
          id: 'bought_products',
          text: Object(external_this_wp_i18n_["__"])('Bought products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'bought_product_variations',
          text: Object(external_this_wp_i18n_["__"])('Bought variations', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'bought_product_categories',
          text: Object(external_this_wp_i18n_["__"])('Bought categories', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'bought_product_attributes',
          text: Object(external_this_wp_i18n_["__"])('Bought product attributes', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'bought_product_tags',
          text: Object(external_this_wp_i18n_["__"])('Bought product tags', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'bought_featured_products',
          text: Object(external_this_wp_i18n_["__"])('Bought featured products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'bought_onsale_products',
          text: Object(external_this_wp_i18n_["__"])('Bought onsale products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'purchase_history_quantity',
        text: Object(external_this_wp_i18n_["__"])('Purchase history quantity', 'easy-woocommerce-discounts'),
        children: [{
          id: 'quantity_of_bought_products',
          text: Object(external_this_wp_i18n_["__"])('Quantity of bought products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_bought_variations',
          text: Object(external_this_wp_i18n_["__"])('Quantity of bought variations', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_bought_categories',
          text: Object(external_this_wp_i18n_["__"])('Quantity of bought categories', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_bought_attributes',
          text: Object(external_this_wp_i18n_["__"])('Quantity of bought attributes', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_bought_tags',
          text: Object(external_this_wp_i18n_["__"])('Quantity of bought tags', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'purchase_history_amount',
        text: Object(external_this_wp_i18n_["__"])('Purchase history amount', 'easy-woocommerce-discounts'),
        children: [{
          id: 'amount_of_bought_products',
          text: Object(external_this_wp_i18n_["__"])('Amount of bought products', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'amount_of_bought_variations',
          text: Object(external_this_wp_i18n_["__"])('Amount of bought variations', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'amount_of_bought_categories',
          text: Object(external_this_wp_i18n_["__"])('Amount of bought categories', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'amount_of_bought_attributes',
          text: Object(external_this_wp_i18n_["__"])('Amount of bought attributes', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'amount_of_bought_tags',
          text: Object(external_this_wp_i18n_["__"])('Amount of bought tags', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'checkout',
        text: Object(external_this_wp_i18n_["__"])('Checkout', 'easy-woocommerce-discounts'),
        children: [{
          id: 'payment_method',
          text: Object(external_this_wp_i18n_["__"])('Payment method', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_method',
          text: Object(external_this_wp_i18n_["__"])('Shipping method', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'shipping_address',
        text: Object(external_this_wp_i18n_["__"])('Shipping Address', 'easy-woocommerce-discounts'),
        children: [{
          id: 'shipping_country',
          text: Object(external_this_wp_i18n_["__"])('Shipping country', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_state',
          text: Object(external_this_wp_i18n_["__"])('Shipping state', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_city',
          text: Object(external_this_wp_i18n_["__"])('Shipping city', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_postcode',
          text: Object(external_this_wp_i18n_["__"])('Shipping postcode', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_zone',
          text: Object(external_this_wp_i18n_["__"])('Shipping zone', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'shipping_package',
        text: Object(external_this_wp_i18n_["__"])('Shipping package', 'easy-woocommerce-discounts'),
        children: [{
          id: 'package_total_weight',
          text: Object(external_this_wp_i18n_["__"])('Package total weight', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'number_of_package_items',
          text: Object(external_this_wp_i18n_["__"])('Number of package items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'quantity_of_package_items',
          text: Object(external_this_wp_i18n_["__"])('Quantity of package items', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }, {
        id: 'shipping_package_items',
        text: Object(external_this_wp_i18n_["__"])('Shipping package items', 'easy-woocommerce-discounts'),
        children: [{
          id: 'products_in_package',
          text: Object(external_this_wp_i18n_["__"])('Products in package', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_variations_in_package',
          text: Object(external_this_wp_i18n_["__"])('Product variations in package', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_categories_in_package',
          text: Object(external_this_wp_i18n_["__"])('Product categories in package', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_attributes_in_package',
          text: Object(external_this_wp_i18n_["__"])('Product attributes in package', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'product_tags_in_package',
          text: Object(external_this_wp_i18n_["__"])('Product tags in package', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }, {
          id: 'shipping_classes_in_package',
          text: Object(external_this_wp_i18n_["__"])('Shipping classes in package', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
          disabled: true
        }]
      }];

      // Product custom taxonomies.
      if (wcConditions.taxonomies && Object.keys(wcConditions.taxonomies).length) {
        var taxonomies = [];
        for (var taxonomy in wcConditions.taxonomies) {
          taxonomies.push({
            id: 'taxonomy_in_cart__' + wcConditions.taxonomies[taxonomy].name,
            text: wcConditions.taxonomies[taxonomy].label + ' ' + Object(external_this_wp_i18n_["__"])('in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
          taxonomies.push({
            id: 'taxonomy_subtotal_including_tax__' + wcConditions.taxonomies[taxonomy].name,
            text: wcConditions.taxonomies[taxonomy].label + ' ' + Object(external_this_wp_i18n_["__"])('subtotal including tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
          taxonomies.push({
            id: 'taxonomy_subtotal_excluding_tax__' + wcConditions.taxonomies[taxonomy].name,
            text: wcConditions.taxonomies[taxonomy].label + ' ' + Object(external_this_wp_i18n_["__"])('subtotal excluding tax', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
          taxonomies.push({
            id: 'taxonomy_quantity_in_cart__' + wcConditions.taxonomies[taxonomy].name,
            text: wcConditions.taxonomies[taxonomy].label + ' ' + Object(external_this_wp_i18n_["__"])('quantity in cart', 'easy-woocommerce-discounts') + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
          taxonomies.push({
            id: 'taxonomy_bought__' + wcConditions.taxonomies[taxonomy].name,
            text: Object(external_this_wp_i18n_["__"])('Bought', 'easy-woocommerce-discounts') + ' ' + wcConditions.taxonomies[taxonomy].label + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
          taxonomies.push({
            id: 'taxonomy_bought_amount__' + wcConditions.taxonomies[taxonomy].name,
            text: Object(external_this_wp_i18n_["__"])('Amount of bought', 'easy-woocommerce-discounts') + ' ' + wcConditions.taxonomies[taxonomy].label + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
          taxonomies.push({
            id: 'taxonomy_bought_quantity__' + wcConditions.taxonomies[taxonomy].name,
            text: Object(external_this_wp_i18n_["__"])('Quantity of bought', 'easy-woocommerce-discounts') + ' ' + wcConditions.taxonomies[taxonomy].label + ' - ' + Object(external_this_wp_i18n_["__"])('PRO Version', 'easy-woocommerce-discounts'),
            disabled: true
          });
        }
        values.push({
          id: 'product_taxonomies',
          text: Object(external_this_wp_i18n_["__"])('Product Taxonomies', 'easy-woocommerce-discounts'),
          children: taxonomies
        });
      }
      if ((!this.ignoreGroups || !this.ignoreGroups.length) && (!this.ignoreItems || !this.ignoreItems.length)) {
        return values;
      }
      var retValues = [];
      values.map(function (group) {
        if (-1 === _this.ignoreGroups.indexOf(group.id)) {
          group.children = group.children.filter(function (item) {
            return -1 === _this.ignoreItems.indexOf(item.id);
          });
          retValues.push(group);
        }
      });
      return retValues;
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Condition.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Conditionvue_type_script_lang_js_ = (Conditionvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Condition.vue





/* normalize component */

var Condition_component = Object(componentNormalizer["a" /* default */])(
  components_Conditionvue_type_script_lang_js_,
  Conditionvue_type_template_id_148c3efc_render,
  Conditionvue_type_template_id_148c3efc_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Condition = (Condition_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ConditionItem.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ConditionItemvue_type_script_lang_js_ = ({
  name: 'condition-item',
  props: {
    condition: {
      type: Object
    },
    index: {
      type: Number
    },
    ignoreGroups: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    ignoreItems: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    enabledItems: {
      type: Array,
      "default": function _default() {
        return ['cart_total_weight', 'number_of_cart_items', 'subtotal_including_tax'];
      }
    }
  },
  data: function data() {
    return {
      myCondition: this.condition
    };
  },
  components: {
    condition: Condition
  },
  methods: {
    deleteItem: function deleteItem() {
      this.$emit('deleteItem', 'condition', this.index);
    },
    onConditionUpdated: function onConditionUpdated(condition) {
      this.myCondition = condition;
      this.$emit('conditionUpdated', this.myCondition, this.index);
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionItem.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ConditionItemvue_type_script_lang_js_ = (ConditionItemvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionItem.vue





/* normalize component */

var ConditionItem_component = Object(componentNormalizer["a" /* default */])(
  components_ConditionItemvue_type_script_lang_js_,
  ConditionItemvue_type_template_id_6535762a_render,
  ConditionItemvue_type_template_id_6535762a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ConditionItem = (ConditionItem_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ConditionsGroup.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ConditionsGroupvue_type_script_lang_js_ = ({
  components: {
    ConditionItem: ConditionItem
  },
  props: {
    items: {
      type: Array
    },
    ignoreGroups: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    ignoreItems: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionsGroup.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ConditionsGroupvue_type_script_lang_js_ = (ConditionsGroupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionsGroup.vue





/* normalize component */

var ConditionsGroup_component = Object(componentNormalizer["a" /* default */])(
  components_ConditionsGroupvue_type_script_lang_js_,
  ConditionsGroupvue_type_template_id_1212b346_render,
  ConditionsGroupvue_type_template_id_1212b346_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ConditionsGroup = (ConditionsGroup_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ConditionsContainer.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ConditionsContainervue_type_script_lang_js_ = ({
  name: 'conditions-container',
  components: {
    ConditionsGroup: ConditionsGroup
  },
  props: {
    items: {
      type: Array
    },
    ignoreGroups: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    ignoreItems: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionsContainer.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ConditionsContainervue_type_script_lang_js_ = (ConditionsContainervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ConditionsContainer.vue





/* normalize component */

var ConditionsContainer_component = Object(componentNormalizer["a" /* default */])(
  components_ConditionsContainervue_type_script_lang_js_,
  ConditionsContainervue_type_template_id_140f18e0_render,
  ConditionsContainervue_type_template_id_140f18e0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ConditionsContainer = (ConditionsContainer_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/ProductsView.vue?vue&type=script&lang=js&
function ProductsViewvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return ProductsViewvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, ProductsViewvue_type_script_lang_js_typeof(o); }
function ProductsViewvue_type_script_lang_js_toConsumableArray(r) { return ProductsViewvue_type_script_lang_js_arrayWithoutHoles(r) || ProductsViewvue_type_script_lang_js_iterableToArray(r) || ProductsViewvue_type_script_lang_js_unsupportedIterableToArray(r) || ProductsViewvue_type_script_lang_js_nonIterableSpread(); }
function ProductsViewvue_type_script_lang_js_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ProductsViewvue_type_script_lang_js_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return ProductsViewvue_type_script_lang_js_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ProductsViewvue_type_script_lang_js_arrayLikeToArray(r, a) : void 0; } }
function ProductsViewvue_type_script_lang_js_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function ProductsViewvue_type_script_lang_js_arrayWithoutHoles(r) { if (Array.isArray(r)) return ProductsViewvue_type_script_lang_js_arrayLikeToArray(r); }
function ProductsViewvue_type_script_lang_js_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ProductsViewvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function ProductsViewvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ProductsViewvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { ProductsViewvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ProductsViewvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function ProductsViewvue_type_script_lang_js_defineProperty(e, r, t) { return (r = ProductsViewvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function ProductsViewvue_type_script_lang_js_toPropertyKey(t) { var i = ProductsViewvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == ProductsViewvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function ProductsViewvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != ProductsViewvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != ProductsViewvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//










/* harmony default export */ var ProductsViewvue_type_script_lang_js_ = ({
  name: 'products-view',
  components: {
    ProductsSelectItem: ProductsSelectItem,
    Select2: Select2,
    DateTimeContainer: DateTimeContainer,
    ConditionsContainer: ConditionsContainer
  },
  data: function data() {
    var products = {
        name: 'Products',
        include: [],
        exclude: [],
        date_time: [],
        conditions: [],
        ordering: 0,
        paginate: 'true'
      },
      id = 'new' !== this.$route.params.id ? parseInt(this.$route.params.id) : 0;
    if (id > 0) {
      for (var i = 0, max = this.$store.state.productsList.length; i < max; i++) {
        if (id == this.$store.state.productsList[i].id) {
          var item = cloneDeep_default()(this.$store.state.productsList[i]);
          products = ProductsViewvue_type_script_lang_js_objectSpread(ProductsViewvue_type_script_lang_js_objectSpread({}, products), item);
          break;
        }
      }
    }
    return {
      id: id,
      products: products,
      ordering: products.ordering,
      showSave: false,
      savedSuccessfully: false,
      saveErrors: false,
      showLoading: false,
      ignoreGroups: ['shipping_package', 'shipping_package_items']
    };
  },
  methods: {
    onIncludeProductUpdated: function onIncludeProductUpdated(products, index) {
      this.products.include[index] = products;
    },
    onExcludeProductUpdated: function onExcludeProductUpdated(products, index) {
      this.products.exclude[index] = products;
    },
    onDateTimeItemUpdated: function onDateTimeItemUpdated(groupIndex, dateTime, index) {
      this.products.date_time[groupIndex][index] = dateTime;
    },
    onConditionUpdated: function onConditionUpdated(groupIndex, condition, index) {
      this.products.conditions[groupIndex][index] = condition;
    },
    onDeleteItem: function onDeleteItem(type, index) {
      var items, group;
      switch (type) {
        case 'dateTime':
          items = ProductsViewvue_type_script_lang_js_toConsumableArray(this.products.date_time);
          group = ProductsViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.products.date_time = items;
          break;
        case 'condition':
          items = ProductsViewvue_type_script_lang_js_toConsumableArray(this.products.conditions);
          group = ProductsViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.products.conditions = items;
          break;
        case 'include':
          this.products.include.splice(index, 1);
          break;
        case 'exclude':
          this.products.exclude.splice(index, 1);
          break;
        default:
          break;
      }
    },
    onAddGroup: function onAddGroup(type) {
      switch (type) {
        case 'condition':
          this.products.conditions = [].concat(ProductsViewvue_type_script_lang_js_toConsumableArray(this.products.conditions), [[this.initialCondition()]]);
          break;
        case 'dateTime':
          this.products.date_time = [].concat(ProductsViewvue_type_script_lang_js_toConsumableArray(this.products.date_time), [[this.initialDateTime()]]);
          break;
      }
    },
    onDeleteGroup: function onDeleteGroup(index, type) {
      var items;
      switch (type) {
        case 'condition':
          items = ProductsViewvue_type_script_lang_js_toConsumableArray(this.products.conditions);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.products.conditions = items;
          break;
        case 'dateTime':
          items = ProductsViewvue_type_script_lang_js_toConsumableArray(this.products.date_time);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.products.date_time = items;
          break;
      }
    },
    addNewIncludeProducts: function addNewIncludeProducts() {
      this.products.include.push(this.initialProducts());
    },
    addNewExcludeProducts: function addNewExcludeProducts() {
      this.products.exclude.push(this.initialProducts());
    },
    addNewDateTime: function addNewDateTime(index) {
      this.products.date_time[index].push(this.initialDateTime());
    },
    addNewCondition: function addNewCondition(index) {
      this.products.conditions[index].push(this.initialCondition());
    },
    setToggle: function setToggle(value, prop) {
      var trueValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var falseValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      this.products = Object.assign({}, this.products, ProductsViewvue_type_script_lang_js_defineProperty({}, prop, value ? trueValue : falseValue));
    },
    checkErrors: function checkErrors() {
      if (!this.products.name.trim().length) {
        return this.saveErrors = true;
      } else if ('danger' === this.productsAlertType) {
        return this.saveErrors = true;
      }
      return this.saveErrors = false;
    },
    saveConditions: function saveConditions() {
      var _this = this;
      if (this.checkErrors()) {
        return;
      }
      this.savedSuccessfully = false;
      this.showLoading = true;
      condition_save({
        type: PRODUCTS_LIST_TYPE,
        id: this.id,
        include: this.products.include,
        exclude: this.products.exclude,
        date_time: this.products.date_time,
        conditions: this.products.conditions,
        name: this.products.name,
        paginate: this.products.paginate,
        ordering: this.ordering
      }).then(function (response) {
        if (1 == response.success) {
          if (!_this.id) {
            _this.ordering = parseInt(response.condition.ordering);
            _this.id = parseInt(response.condition.id);
          }
          _this.$store.commit('ADD_PRODUCTS_LIST', response.condition);
          _this.showSave = false;
          _this.savedSuccessfully = true;
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
        console.log(error);
      });
    }
  },
  computed: {
    productsAlertType: function productsAlertType() {
      return !this.products.include.length && !this.products.exclude.length ? 'danger' : 'info';
    },
    productsAlertTitle: function productsAlertTitle() {
      return !this.products.include.length && !this.products.exclude.length ? Object(external_this_wp_i18n_["__"])('Warning!', 'easy-woocommerce-discounts') : Object(external_this_wp_i18n_["__"])('Info!', 'easy-woocommerce-discounts');
    }
  },
  watch: {
    products: {
      handler: function handler(newProducts) {
        if (this.id > 0) {
          this.showSave = true;
        }
      },
      deep: true
    }
  },
  validations: {
    products: {
      name: {
        required: required_default.a
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ProductsView.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_ProductsViewvue_type_script_lang_js_ = (ProductsViewvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ProductsView.vue





/* normalize component */

var ProductsView_component = Object(componentNormalizer["a" /* default */])(
  views_ProductsViewvue_type_script_lang_js_,
  ProductsViewvue_type_template_id_5eaae9c3_render,
  ProductsViewvue_type_template_id_5eaae9c3_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductsView = (ProductsView_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/DiscountList.vue?vue&type=template&id=51065d22&
var DiscountListvue_type_template_id_51065d22_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-discount-list"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Discounts', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":"/discount/new"}},[_vm._v(_vm._s(_vm.__( 'Add New', 'easy-woocommerce-discounts' )))])],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.discountList.length),expression:"discountList.length"}],staticClass:"asnp-flex asnp-flex-col"},[_c('div',{staticClass:"asnp-my-2 asnp-overflow-x-auto sm:asnp-mx-6 lg:asnp-mx-8"},[_c('div',{staticClass:"asnp-py-2 asnp-align-middle asnp-inline-block asnp-min-w-full sm:asnp-px-6 lg:asnp-px-8"},[_c('div',{staticClass:"asnp-shadow asnp-overflow-hidden asnp-border-b asnp-border-gray-200 sm:asnp-rounded-lg"},[_c('table',{staticClass:"asnp-min-w-full asnp-divide-y asnp-divide-gray-200",attrs:{"id":"discounts-list"}},[_c('thead',{staticClass:"asnp-bg-gray-50"},[_c('tr',[_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}}),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'ID',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Name',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Apply Mode',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Status',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Actions',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")])])]),_vm._v(" "),_c('tbody',{directives:[{name:"sortable",rawName:"v-sortable",value:({
								handle: '.reorder-discount-list',
								onUpdate: _vm.updateOrders,
							}),expression:"{\n\t\t\t\t\t\t\t\thandle: '.reorder-discount-list',\n\t\t\t\t\t\t\t\tonUpdate: updateOrders,\n\t\t\t\t\t\t\t}"}],staticClass:"asnp-bg-white asnp-divide-y asnp-divide-gray-200"},_vm._l((_vm.discountList),function(discount,index){return _c('tr',{key:discount.id},[_vm._m(0,true),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(discount.id)+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"hover:asnp-text-indigo-500 focus:asnp-outline-none focus:asnp-shadow-none",attrs:{"to":'/discount/' + discount.id}},[_vm._v(_vm._s(discount.name +
											( null !=
												discount.private_note &&
											discount.private_note.length
												? ' | ' +
												  discount.private_note
												: '' )))])],1),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('select',{staticClass:"asnp-select-field",domProps:{"value":discount.apply_mode},on:{"change":function($event){return _vm.updateData( index, discount, {
												apply_mode:
													$event.target.value,
											} )}}},[_c('optgroup',{attrs:{"label":_vm.__(
													'Non Exclusive',
													'easy-woocommerce-discounts'
												)}},[_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__(
													'Apply with other applicable rules',
													'easy-woocommerce-discounts'
												)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__(
													'Exclusive',
													'easy-woocommerce-discounts'
												)}},[_c('option',{attrs:{"value":"individually"}},[_vm._v(_vm._s(_vm.__(
													'Apply this rule and disregard other rules',
													'easy-woocommerce-discounts'
												)))]),_vm._v(" "),_c('option',{attrs:{"value":"applicable_not_exists"}},[_vm._v(_vm._s(_vm.__(
														'Apply if other rules are not applicable',
														'easy-woocommerce-discounts'
													)))])])])]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('toggle',{attrs:{"value":_vm.toBool( discount.status )},on:{"input":function($event){return _vm.updateData( index, discount, {
												status: $event ? 1 : 0,
											} )}}})],1),_vm._v(" "),_c('td',{staticClass:"asnp-inline-flex asnp-space-x-1 asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/discount/' + discount.id,"title":_vm.__(
												'Edit',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-edit",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"title":_vm.__(
												'Duplicate',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.duplicate( discount.id )}}},[_c('i',{staticClass:"fa fa-copy",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/analytics/' + discount.id,"title":_vm.__(
												'Analytics',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-bar-chart",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-delete",attrs:{"title":_vm.__(
												'Delete',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.showDeleteWarning( discount.id )}}},[_c('i',{staticClass:"fa fa-remove",attrs:{"aria-hidden":"true"}})])],1)])}),0)])])])])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.discountList.length),expression:"! discountList.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),(_vm.showDeleteModal)?_c('modal',{on:{"apply":function($event){return _vm.deleteCartDiscount()},"cancel":function($event){_vm.showDeleteModal = false}}}):_vm._e()],1)}
var DiscountListvue_type_template_id_51065d22_staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('i',{staticClass:"fa fa-reorder reorder-discount-list",attrs:{"aria-hidden":"true"}})])}]


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/DiscountList.vue?vue&type=template&id=51065d22&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/DiscountList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var DiscountListvue_type_script_lang_js_ = ({
  name: 'discount-list',
  data: function data() {
    return {
      discountList: cloneDeep_default()(this.$store.state.discountList),
      showLoading: false,
      showDeleteModal: false,
      deleteId: 0
    };
  },
  methods: {
    showDeleteWarning: function showDeleteWarning(id) {
      this.deleteId = id;
      this.showDeleteModal = true;
    },
    deleteCartDiscount: function deleteCartDiscount() {
      var _this = this;
      this.showDeleteModal = false;
      if (!this.deleteId) {
        return;
      }
      this.showLoading = true;
      condition_deleteItem({
        id: this.deleteId,
        type: DISCOUNT_TYPE
      }).then(function (response) {
        if (1 == response.success) {
          _this.$store.commit('DELETE_CART_DISCOUNT', _this.deleteId);
          _this.discountList = cloneDeep_default()(_this.$store.state.discountList);
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
      });
    },
    updateOrders: function updateOrders(event) {
      var _this2 = this;
      this.discountList.splice(event.newIndex, 0, this.discountList.splice(event.oldIndex, 1)[0]);
      var conditions = [];
      this.discountList.forEach(function (value, index) {
        value.ordering = index + 1;
        conditions.push({
          id: value.id,
          ordering: value.ordering
        });
      });
      if (conditions.length) {
        this.showLoading = true;
        reorder({
          conditions: conditions,
          type: DISCOUNT_TYPE
        }).then(function (response) {
          if (1 == response.success && response.conditions) {
            _this2.$store.commit('SET_CART_DISCOUNT_LIST', response.conditions);
            _this2.discountList = cloneDeep_default()(_this2.$store.state.discountList);
          }
          _this2.showLoading = false;
        })["catch"](function (error) {
          _this2.showLoading = false;
        });
      }
    },
    updateData: function updateData(index, discount, data) {
      var _this3 = this;
      this.showLoading = true;
      this.discountList[index] = Object.assign({}, discount, data);
      update({
        id: discount.id,
        type: DISCOUNT_TYPE,
        data: data
      }).then(function (response) {
        if (1 == response.success) {
          _this3.$store.commit('UPDATE_CART_DISCOUNT', response.condition);
        }
        _this3.discountList = cloneDeep_default()(_this3.$store.state.discountList);
      })["catch"](function (error) {
        _this3.discountList[index] = discount;
      })["finally"](function () {
        _this3.showLoading = false;
      });
    },
    duplicate: function duplicate(id) {
      var _this4 = this;
      this.showLoading = true;
      condition_duplicate({
        id: id,
        type: DISCOUNT_TYPE
      }).then(function (response) {
        if (1 == response.success && response.conditions) {
          _this4.$store.commit('SET_CART_DISCOUNT_LIST', response.conditions);
          _this4.discountList = cloneDeep_default()(_this4.$store.state.discountList);
        }
        _this4.showLoading = false;
      })["catch"](function (error) {
        _this4.showLoading = false;
      });
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/DiscountList.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_DiscountListvue_type_script_lang_js_ = (DiscountListvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/DiscountList.vue





/* normalize component */

var DiscountList_component = Object(componentNormalizer["a" /* default */])(
  views_DiscountListvue_type_script_lang_js_,
  DiscountListvue_type_template_id_51065d22_render,
  DiscountListvue_type_template_id_51065d22_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var DiscountList = (DiscountList_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/DiscountView.vue?vue&type=template&id=9f94a96e&
var DiscountViewvue_type_template_id_9f94a96e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-discount-view"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Discount', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-secondary wccs-page-title-action",attrs:{"to":"/discount-list","tag":"button"}},[_vm._v(_vm._s(_vm.__( 'Cancel', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary wccs-page-title-action",attrs:{"type":"button"},on:{"click":_vm.saveDiscount}},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Save', 'easy-woocommerce-discounts' ))+"\n\t\t")])],1),_vm._v(" "),(_vm.saleBadgesAdv)?_c('product-labels'):_vm._e(),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSave),expression:"showSave"}],attrs:{"type":"danger","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Please save changes.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.saveErrors),expression:"saveErrors"}],attrs:{"type":"danger","title":_vm.__( 'Warning!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There are some errors in the form please fix them and save it again.',
					'easy-woocommerce-discounts'
				),"dismissable":true},on:{"dismiss":function($event){_vm.saveErrors = false}}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.savedSuccessfully),expression:"savedSuccessfully"}],attrs:{"type":"success","title":_vm.__( 'Success!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Saved successfully.', 'easy-woocommerce-discounts' ),"dismissable":true},on:{"dismiss":function($event){_vm.savedSuccessfully = false}}})],1),_vm._v(" "),_c('div',{staticClass:"asnp-mt-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Name', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.discount.name),expression:"discount.name"}],staticClass:"asnp-block asnp-text-field",class:{
					'wccs-field-error': _vm.$v.discount.name.$error,
				},attrs:{"type":"text"},domProps:{"value":(_vm.discount.name)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.discount, "name", $event.target.value)},function($event){return _vm.$v.discount.name.$touch()}]}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__( 'Enter a unique name.', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.discount.name.required),expression:"! $v.discount.name.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Private Note', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.discount.private_note),expression:"discount.private_note"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"text"},domProps:{"value":(_vm.discount.private_note)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.discount, "private_note", $event.target.value)}}})]),_vm._v(" "),_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Status', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.discount.status )},on:{"input":function($event){return _vm.setToggle( $event, 'status', 1, 0 )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Enable or disable the rule.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Manual Coupon', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.discount.manual )},on:{"input":function($event){return _vm.setToggle( $event, 'manual', 1, 0 )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'User should enter the discount name manually to the cart to get the discount.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Apply Mode', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.discount.apply_mode),expression:"discount.apply_mode"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.discount, "apply_mode", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Non Exclusive', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__(
							'Apply with other applicable rules',
							'easy-woocommerce-discounts'
						)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Exclusive', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"individually"}},[_vm._v(_vm._s(_vm.__(
							'Apply this rule and disregard other rules',
							'easy-woocommerce-discounts'
						)))]),_vm._v(" "),_c('option',{attrs:{"value":"applicable_not_exists"}},[_vm._v(_vm._s(_vm.__(
							'Apply if other rules are not applicable',
							'easy-woocommerce-discounts'
						)))])])])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Discount Type', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.discount.discount_type),expression:"discount.discount_type"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.discount, "discount_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Discount', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"price"}},[_vm._v(_vm._s(_vm.__( 'Price discount', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"percentage"}},[_vm._v(_vm._s(_vm.__(
							'Percentage discount',
							'easy-woocommerce-discounts'
						)))]),_vm._v(" "),_c('option',{attrs:{"value":"fixed_price","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Fixed price discount',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO Version', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__(
							'Discount Per Item',
							'easy-woocommerce-discounts'
						)}},[_c('option',{attrs:{"value":"price_discount_per_item"}},[_vm._v(_vm._s(_vm.__(
							'Price discount per item',
							'easy-woocommerce-discounts'
						)))]),_vm._v(" "),_c('option',{attrs:{"value":"percentage_discount_per_item"}},[_vm._v(_vm._s(_vm.__(
							'Percentage discount per item',
							'easy-woocommerce-discounts'
						)))])]),_vm._v(" "),(_vm.wcSubscriptions)?_c('optgroup',{attrs:{"label":_vm.__(
							'Recurring Discount',
							'easy-woocommerce-discounts'
						)}},[_c('option',{attrs:{"value":"recurring_fee","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Recurring price discount',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO Version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"recurring_percent","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Recurring percentage discount',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO Version', 'easy-woocommerce-discounts' )))])]):_vm._e()]),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%1$sNote:%2$s The %1$sFixed price discount%2$s amount will apply to the whole cart in the backend even if you select specific items.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}})]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Discount Amount', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.discount.discount_amount),expression:"discount.discount_amount"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
					'wccs-field-error': _vm.$v.discount.discount_amount.$error,
				},attrs:{"type":"number"},domProps:{"value":(_vm.discount.discount_amount)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.discount, "discount_amount", $event.target.value)},function($event){return _vm.$v.discount.discount_amount.$touch()}]}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.sprintf(
					_vm.__(
						'Discount amount can be greater or equal to %d.',
						'easy-woocommerce-discounts'
					),
					0
				)))]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.discount.discount_amount.required),expression:"! $v.discount.discount_amount.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.discount.discount_amount.minValue),expression:"! $v.discount.discount_amount.minValue"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__(
						'Please enter a valid value.',
						'easy-woocommerce-discounts'
					)))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Usage Limit', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.discount.usage_limit),expression:"discount.usage_limit"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
				},attrs:{"type":"number"},domProps:{"value":(_vm.discount.usage_limit)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.discount, "usage_limit", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Leave blank for unlimited usage. To set a usage limit for individual users, please refer to the "User usage limit" condition in the conditions list.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),(! _vm.toBool( _vm.discount.manual ))?_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Url Coupon', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.urlCoupon},on:{"input":function ( value ) { return ( _vm.urlCoupon = value ); }}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(_vm.urlCouponDesc)}})]):_vm._e(),_vm._v(" "),(_vm.showUrlCouponFields)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Coupon URL', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{class:{
					'asnp-block': true,
					'asnp-text-field': true,
				},attrs:{"type":"url","readonly":"1","placeholder":"PRO Version and URL Coupons addon are required"}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Visiting this link will automatically applies the coupon code to the cart.',
					'easy-woocommerce-discounts'
				)))])]):_vm._e(),_vm._v(" "),(_vm.showUrlCouponFields)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Code Override', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{class:{
					'asnp-block': true,
					'asnp-text-field': true,
				},attrs:{"type":"text","readonly":"1","placeholder":"PRO Version and URL Coupons addon are required"}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Override the coupon code value in the coupon code URL.',
					'easy-woocommerce-discounts'
				)))]),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Leave blank to ignore it.',
					'easy-woocommerce-discounts'
				)))])]):_vm._e(),_vm._v(" "),(_vm.showUrlCouponFields)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Redirect to URL', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{class:{
					'asnp-block': true,
					'asnp-text-field': true,
				},attrs:{"type":"url","readonly":"1","placeholder":"PRO Version and URL Coupons addon are required"}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'URL coupon redirect URL.',
					'easy-woocommerce-discounts'
				)))])]):_vm._e(),_vm._v(" "),(_vm.showUrlCouponFields)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Custom Success Message', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('textarea',{staticClass:"asnp-textarea-field",attrs:{"rows":"3","readonly":"1","placeholder":"PRO Version and URL Coupons addon are required"}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Message that will be displayed when coupon applied successfully.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")]),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Leave it blank to use the default message.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]):_vm._e()]),_vm._v(" "),_c('h3',{directives:[{name:"show",rawName:"v-show",value:(_vm.showItems),expression:"showItems"}],staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Items', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.showItems && ! _vm.discount.items.length),expression:"showItems && ! discount.items.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Applies to all items.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),(_vm.showItems)?_c('products-select-container',{attrs:{"items":_vm.discount.items,"keyName":"product","hiddenRows":[ 'quantity' ],"hiddenOptions":_vm.hiddenOptions,"type":"item"},on:{"productsUpdated":_vm.onItemUpdated,"deleteItem":_vm.onDeleteItem,"itemAdded":_vm.addNewItem,"groupAdded":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}):_vm._e(),_vm._v(" "),_c('h3',{directives:[{name:"show",rawName:"v-show",value:(_vm.showItems),expression:"showItems"}],staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Excluded Products', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('p',{directives:[{name:"show",rawName:"v-show",value:(_vm.showItems),expression:"showItems"}],staticClass:"asnp-mb-4"},[_vm._v("\n\t\t"+_vm._s(_vm.__(
				'Exclude products from this rule.',
				'easy-woocommerce-discounts'
			))+"\n\t")]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.showItems && ! _vm.discount.exclude_items.length),expression:"showItems && ! discount.exclude_items.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),(_vm.showItems)?_c('products-select-container',{attrs:{"items":_vm.discount.exclude_items,"keyName":"excludeProduct","hiddenRows":[ 'quantity' ],"hiddenOptions":_vm.excludeItemsHiddenOptions,"type":"excluded"},on:{"productsUpdated":_vm.onExcludedItemUpdated,"deleteItem":_vm.onDeleteItem,"itemAdded":_vm.addNewExcludedProducts,"groupAdded":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Date Time', 'easy-woocommerce-discounts' ))+"\n\t\t\t"),_c('current-time')],1)]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.discount.date_time.length),expression:"! discount.date_time.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any date time.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('date-time-container',{attrs:{"items":_vm.discount.date_time},on:{"dateTimeUpdated":_vm.onDateTimeItemUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewDateTime,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Conditions', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.discount.conditions.length),expression:"! discount.conditions.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any condition.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('conditions-container',{attrs:{"items":_vm.discount.conditions,"ignoreGroups":_vm.ignoreGroups,"ignoreItems":_vm.ignoreItems},on:{"conditionUpdated":_vm.onDiscountConditionUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewCondition,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}})],1)}
var DiscountViewvue_type_template_id_9f94a96e_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/DiscountView.vue?vue&type=template&id=9f94a96e&

// EXTERNAL MODULE: ./node_modules/vuelidate/lib/validators/minValue.js
var minValue = __webpack_require__(66);
var minValue_default = /*#__PURE__*/__webpack_require__.n(minValue);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelectContainer.vue?vue&type=template&id=6b2dee60&
var ProductsSelectContainervue_type_template_id_6b2dee60_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-products-select-container"},[_vm._l((_vm.items),function(item,index){return _c('div',{key:'products-select-group-' + index},[(0 < index)?_c('div',{staticClass:"asnp-group-separator asnp-text-center asnp-text-lg asnp-text-gray-400 asnp-font-bold asnp-py-1"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'OR', 'easy-woocommerce-discounts' ))+"\n\t\t")]):_vm._e(),_vm._v(" "),_c('products-select-group',{attrs:{"items":item,"keyName":_vm.keyName,"hiddenRows":_vm.hiddenRows,"hiddenOptions":_vm.hiddenOptions,"type":_vm.type},on:{"productsUpdated":function ( products, productsIndex ) { return _vm.$emit(
						'productsUpdated',
						index,
						products,
						productsIndex
					); },"deleteItem":function ( type, productsIndex ) { return _vm.$emit( 'deleteItem', type, productsIndex, index ); },"itemAdded":function($event){return _vm.$emit( 'itemAdded', index )},"deleteGroup":function($event){return _vm.$emit( 'deleteGroup', index, _vm.type )}}})],1)}),_vm._v(" "),_c('div',{staticClass:"asnp-mx-2"},[_c('button',{staticClass:"asnp-btn asnp-btn-primary",on:{"click":function($event){return _vm.$emit( 'groupAdded', _vm.type )}}},[_vm._v("\n\t\t\t"+_vm._s(_vm.sprintf(
					_vm.__( '%s OR New Group', 'easy-woocommerce-discounts' ),
					'+'
				))+"\n\t\t")])])],2)}
var ProductsSelectContainervue_type_template_id_6b2dee60_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectContainer.vue?vue&type=template&id=6b2dee60&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelectGroup.vue?vue&type=template&id=9204dd2e&
var ProductsSelectGroupvue_type_template_id_9204dd2e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-products-select-group asnp-border-dashed asnp-border asnp-border-gray-500 asnp-rounded-md asnp-px-2 asnp-py-4 asnp-mb-2"},[_c('transition-group',{attrs:{"name":"list-fade","mode":"out-in","tag":"div"}},_vm._l((_vm.items),function(item,index){return _c('products-select-item',{key:_vm.getKey( item, _vm.keyName ),attrs:{"products":item,"index":index,"hiddenRows":_vm.hiddenRows,"hiddenOptions":_vm.hiddenOptions,"type":_vm.type},on:{"productsUpdated":function ( products ) { return _vm.$emit( 'productsUpdated', products, index ); },"deleteItem":function ( type ) { return _vm.$emit( 'deleteItem', type, index ); }}})}),1),_vm._v(" "),_c('div',[_c('button',{staticClass:"asnp-btn asnp-btn-secondary",on:{"click":function($event){return _vm.$emit( 'itemAdded' )}}},[_vm._v("\n\t\t\t"+_vm._s(_vm.sprintf(
					_vm.__( '%s And New Rule', 'easy-woocommerce-discounts' ),
					'+'
				))+"\n\t\t")]),_vm._v(" "),_c('span',{staticClass:"asnp-float-right asnp-cursor-pointer asnp-my-2 asnp-text-lg asnp-text-rose-500 hover:asnp-text-rose-600 fa fa-trash",attrs:{"title":_vm.__( 'Delete Group', 'easy-woocommerce-discounts' )},on:{"click":function($event){return _vm.$emit( 'deleteGroup' )}}})])],1)}
var ProductsSelectGroupvue_type_template_id_9204dd2e_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectGroup.vue?vue&type=template&id=9204dd2e&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelectGroup.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ProductsSelectGroupvue_type_script_lang_js_ = ({
  components: {
    ProductsSelectItem: ProductsSelectItem
  },
  props: {
    items: {
      type: Array
    },
    hiddenOptions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    hiddenRows: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    keyName: {
      type: String
    },
    type: {
      type: String
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectGroup.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ProductsSelectGroupvue_type_script_lang_js_ = (ProductsSelectGroupvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectGroup.vue





/* normalize component */

var ProductsSelectGroup_component = Object(componentNormalizer["a" /* default */])(
  components_ProductsSelectGroupvue_type_script_lang_js_,
  ProductsSelectGroupvue_type_template_id_9204dd2e_render,
  ProductsSelectGroupvue_type_template_id_9204dd2e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductsSelectGroup = (ProductsSelectGroup_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductsSelectContainer.vue?vue&type=script&lang=js&
function ProductsSelectContainervue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return ProductsSelectContainervue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, ProductsSelectContainervue_type_script_lang_js_typeof(o); }
function ProductsSelectContainervue_type_script_lang_js_defineProperty(e, r, t) { return (r = ProductsSelectContainervue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function ProductsSelectContainervue_type_script_lang_js_toPropertyKey(t) { var i = ProductsSelectContainervue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == ProductsSelectContainervue_type_script_lang_js_typeof(i) ? i : i + ""; }
function ProductsSelectContainervue_type_script_lang_js_toPrimitive(t, r) { if ("object" != ProductsSelectContainervue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != ProductsSelectContainervue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var ProductsSelectContainervue_type_script_lang_js_ = ({
  name: 'products-select-container',
  components: {
    ProductsSelectGroup: ProductsSelectGroup
  },
  props: ProductsSelectContainervue_type_script_lang_js_defineProperty(ProductsSelectContainervue_type_script_lang_js_defineProperty({
    items: {
      type: Array
    },
    keyName: {
      type: String
    },
    hiddenOptions: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    hiddenRows: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  }, "keyName", {
    type: String
  }), "type", {
    type: String
  })
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectContainer.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ProductsSelectContainervue_type_script_lang_js_ = (ProductsSelectContainervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductsSelectContainer.vue





/* normalize component */

var ProductsSelectContainer_component = Object(componentNormalizer["a" /* default */])(
  components_ProductsSelectContainervue_type_script_lang_js_,
  ProductsSelectContainervue_type_template_id_6b2dee60_render,
  ProductsSelectContainervue_type_template_id_6b2dee60_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductsSelectContainer = (ProductsSelectContainer_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/DiscountView.vue?vue&type=script&lang=js&
function DiscountViewvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return DiscountViewvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, DiscountViewvue_type_script_lang_js_typeof(o); }
function DiscountViewvue_type_script_lang_js_toConsumableArray(r) { return DiscountViewvue_type_script_lang_js_arrayWithoutHoles(r) || DiscountViewvue_type_script_lang_js_iterableToArray(r) || DiscountViewvue_type_script_lang_js_unsupportedIterableToArray(r) || DiscountViewvue_type_script_lang_js_nonIterableSpread(); }
function DiscountViewvue_type_script_lang_js_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function DiscountViewvue_type_script_lang_js_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return DiscountViewvue_type_script_lang_js_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? DiscountViewvue_type_script_lang_js_arrayLikeToArray(r, a) : void 0; } }
function DiscountViewvue_type_script_lang_js_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function DiscountViewvue_type_script_lang_js_arrayWithoutHoles(r) { if (Array.isArray(r)) return DiscountViewvue_type_script_lang_js_arrayLikeToArray(r); }
function DiscountViewvue_type_script_lang_js_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function DiscountViewvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function DiscountViewvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? DiscountViewvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { DiscountViewvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : DiscountViewvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function DiscountViewvue_type_script_lang_js_defineProperty(e, r, t) { return (r = DiscountViewvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function DiscountViewvue_type_script_lang_js_toPropertyKey(t) { var i = DiscountViewvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == DiscountViewvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function DiscountViewvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != DiscountViewvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != DiscountViewvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//










/* harmony default export */ var DiscountViewvue_type_script_lang_js_ = ({
  name: 'discount-view',
  components: {
    ProductsSelectContainer: ProductsSelectContainer,
    DateTimeContainer: DateTimeContainer,
    ConditionsContainer: ConditionsContainer
  },
  data: function data() {
    var discount = {
        name: 'discount',
        private_note: '',
        status: 1,
        manual: 0,
        apply_mode: 'all',
        items: [],
        exclude_items: [],
        date_time: [],
        conditions: [],
        discount_type: 'percentage',
        discount_amount: '',
        usage_limit: '',
        ordering: 0
      },
      id = 'new' !== this.$route.params.id ? parseInt(this.$route.params.id) : 0;
    if (id > 0) {
      for (var i = 0, max = this.$store.state.discountList.length; i < max; i++) {
        if (id == this.$store.state.discountList[i].id) {
          var item = cloneDeep_default()(this.$store.state.discountList[i]);
          discount = DiscountViewvue_type_script_lang_js_objectSpread(DiscountViewvue_type_script_lang_js_objectSpread({}, discount), item);
          break;
        }
      }
    }
    return {
      id: id,
      discount: discount,
      ordering: discount.ordering,
      showSave: false,
      savedDiscount: null,
      savedSuccessfully: false,
      saveErrors: false,
      showLoading: false,
      hiddenOptions: ['discounted_products', 'recently_viewed_products', 'similar_products_to_customer_cart_products'],
      ignoreGroups: ['shipping_package', 'shipping_package_items'],
      ignoreItems: ['subtotal_including_tax_excluding_coupons', 'subtotal_excluding_tax_excluding_coupons'],
      excludeItemsHiddenOptions: ['all_products', 'products_not_in_list', 'product_variations_not_in_list', 'recently_viewed_products', 'discounted_products', 'similar_products_to_customer_cart_products'],
      urlCoupon: false
    };
  },
  computed: {
    showItems: function showItems() {
      return -1 < ['price_discount_per_item', 'percentage_discount_per_item'].indexOf(this.discount.discount_type);
    },
    showUrlCouponFields: function showUrlCouponFields() {
      return this.toBool(this.urlCoupon) && !this.toBool(this.discount.manual);
    },
    urlCouponDesc: function urlCouponDesc() {
      return Object(external_this_wp_i18n_["sprintf"])(Object(external_this_wp_i18n_["__"])('Requires %1$s + %2$s.', 'easy-woocommerce-discounts'), '<a href="https://www.asanaplugins.com/product/woocommerce-dynamic-pricing-and-discounts-plugin/" target="_blank" class="asnp-underline asnp-italic">PRO version</a>', '<a href="https://www.asanaplugins.com/product/url-coupons-for-woocommerce/" target="_blank" class="asnp-underline asnp-italic">URL Coupons addon</a>');
    }
  },
  methods: {
    onItemUpdated: function onItemUpdated(groupIndex, products, index) {
      this.discount.items[groupIndex][index] = products;
    },
    onExcludedItemUpdated: function onExcludedItemUpdated(groupIndex, products, index) {
      this.discount.exclude_items[groupIndex][index] = products;
    },
    onDiscountConditionUpdated: function onDiscountConditionUpdated(groupIndex, condition, index) {
      this.discount.conditions[groupIndex][index] = condition;
    },
    addNewDateTime: function addNewDateTime(index) {
      this.discount.date_time[index].push(this.initialDateTime());
    },
    onDateTimeItemUpdated: function onDateTimeItemUpdated(groupIndex, dateTime, index) {
      this.discount.date_time[groupIndex][index] = dateTime;
    },
    onDeleteItem: function onDeleteItem(type, index, groupIndex) {
      var items, group;
      switch (type) {
        case 'dateTime':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.date_time);
          group = DiscountViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.discount.date_time = items;
          break;
        case 'condition':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.conditions);
          group = DiscountViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.discount.conditions = items;
          break;
        case 'item':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.items);
          group = DiscountViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.discount.items = items;
          break;
        case 'excluded':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.exclude_items);
          group = DiscountViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.discount.exclude_items = items;
          break;
      }
    },
    onAddGroup: function onAddGroup(type) {
      switch (type) {
        case 'item':
          this.discount.items = [].concat(DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.items), [[this.initialProducts()]]);
          break;
        case 'excluded':
          this.discount.exclude_items = [].concat(DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.exclude_items), [[this.initialProducts()]]);
          break;
        case 'condition':
          this.discount.conditions = [].concat(DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.conditions), [[this.initialCondition()]]);
          break;
        case 'dateTime':
          this.discount.date_time = [].concat(DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.date_time), [[this.initialDateTime()]]);
          break;
      }
    },
    onDeleteGroup: function onDeleteGroup(index, type) {
      var items;
      switch (type) {
        case 'item':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.items);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.discount.items = items;
          break;
        case 'excluded':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.exclude_items);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.discount.exclude_items = items;
          break;
        case 'condition':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.conditions);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.discount.conditions = items;
          break;
        case 'dateTime':
          items = DiscountViewvue_type_script_lang_js_toConsumableArray(this.discount.date_time);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.discount.date_time = items;
          break;
      }
    },
    addNewCondition: function addNewCondition(index) {
      this.discount.conditions[index].push(this.initialCondition());
    },
    addNewItem: function addNewItem(index) {
      this.discount.items[index].push(this.initialProducts());
    },
    addNewExcludedProducts: function addNewExcludedProducts(index) {
      this.discount.exclude_items[index].push(this.initialProducts());
    },
    setToggle: function setToggle(value, prop) {
      var trueValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var falseValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      this.discount = Object.assign({}, this.discount, DiscountViewvue_type_script_lang_js_defineProperty({}, prop, value ? trueValue : falseValue));
    },
    checkErrors: function checkErrors() {
      if (!this.discount.name.trim().length) {
        return this.saveErrors = true;
      } else if (!this.discount.discount_amount.length || 0 > parseFloat(this.discount.discount_amount)) {
        return this.saveErrors = true;
      }
      return this.saveErrors = false;
    },
    saveDiscount: function saveDiscount() {
      var _this = this;
      if (this.checkErrors()) {
        return;
      }
      this.showLoading = true;
      this.savedSuccessfully = false;
      var discount = Object.assign({}, {
        type: DISCOUNT_TYPE,
        id: this.id,
        ordering: this.ordering
      }, this.discount);
      condition_save(discount).then(function (response) {
        if (1 == response.success) {
          if (!_this.id) {
            _this.ordering = parseInt(response.condition.ordering);
            _this.id = parseInt(response.condition.id);
          }
          _this.discount = DiscountViewvue_type_script_lang_js_objectSpread(DiscountViewvue_type_script_lang_js_objectSpread({}, _this.discount), {}, {
            name: response.condition.name || 'discount'
          });
          _this.savedDiscount = _this.discount;
          _this.$store.commit('ADD_CART_DISCOUNT', response.condition);
          _this.showSave = false;
          _this.savedSuccessfully = true;
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
        console.log(error);
      });
    }
  },
  watch: {
    discount: {
      handler: function handler(newDiscount) {
        if (this.id > 0) {
          if (!this.savedDiscount) {
            this.showSave = true;
          } else if (JSON.stringify(newDiscount) !== JSON.stringify(this.savedDiscount)) {
            this.showSave = true;
          }
        }
      },
      deep: true
    }
  },
  validations: {
    discount: {
      name: {
        required: required_default.a
      },
      discount_amount: {
        required: required_default.a,
        minValue: minValue_default()(0)
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/DiscountView.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_DiscountViewvue_type_script_lang_js_ = (DiscountViewvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/DiscountView.vue





/* normalize component */

var DiscountView_component = Object(componentNormalizer["a" /* default */])(
  views_DiscountViewvue_type_script_lang_js_,
  DiscountViewvue_type_template_id_9f94a96e_render,
  DiscountViewvue_type_template_id_9f94a96e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var DiscountView = (DiscountView_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/PricingList.vue?vue&type=template&id=c6fb0f3a&
var PricingListvue_type_template_id_c6fb0f3a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-pricing-list"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Pricing', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":"/pricing/new"}},[_vm._v(_vm._s(_vm.__( 'Add New', 'easy-woocommerce-discounts' )))])],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.pricingList.length),expression:"pricingList.length"}],staticClass:"asnp-flex asnp-flex-col"},[_c('div',{staticClass:"asnp-my-2 asnp-overflow-x-auto sm:asnp-mx-6 lg:asnp-mx-8"},[_c('div',{staticClass:"asnp-py-2 asnp-align-middle asnp-inline-block asnp-min-w-full sm:asnp-px-6 lg:asnp-px-8"},[_c('div',{staticClass:"asnp-shadow asnp-overflow-hidden asnp-border-b asnp-border-gray-200 sm:asnp-rounded-lg"},[_c('table',{staticClass:"asnp-min-w-full asnp-divide-y asnp-divide-gray-200",attrs:{"id":"pricing-list"}},[_c('thead',{staticClass:"asnp-bg-gray-50"},[_c('tr',[_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}}),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'ID',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Name',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Apply Mode',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Status',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Actions',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")])])]),_vm._v(" "),_c('tbody',{directives:[{name:"sortable",rawName:"v-sortable",value:({
								handle: '.reorder-pricing-list',
								onUpdate: _vm.updateOrders,
							}),expression:"{\n\t\t\t\t\t\t\t\thandle: '.reorder-pricing-list',\n\t\t\t\t\t\t\t\tonUpdate: updateOrders,\n\t\t\t\t\t\t\t}"}],staticClass:"asnp-bg-white asnp-divide-y asnp-divide-gray-200"},_vm._l((_vm.pricingList),function(pricing,index){return _c('tr',{key:pricing.id},[_vm._m(0,true),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(pricing.id)+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"hover:asnp-text-indigo-500 focus:asnp-outline-none focus:asnp-shadow-none",attrs:{"to":'/pricing/' + pricing.id}},[_vm._v(_vm._s(pricing.name))])],1),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('select',{directives:[{name:"show",rawName:"v-show",value:('exclude' != pricing.mode),expression:"'exclude' != pricing.mode"}],staticClass:"asnp-select-field",domProps:{"value":pricing.apply_mode},on:{"change":function($event){return _vm.updateData( index, pricing, {
												apply_mode:
													$event.target.value,
											} )}}},[_c('optgroup',{attrs:{"label":_vm.__(
													'Non Exclusive',
													'easy-woocommerce-discounts'
												)}},[_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__(
													'Apply with other applicable rules',
													'easy-woocommerce-discounts'
												)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__(
													'Exclusive',
													'easy-woocommerce-discounts'
												)}},[_c('option',{attrs:{"value":"individually"}},[_vm._v(_vm._s(_vm.__(
													'Apply this rule and disregard other rules',
													'easy-woocommerce-discounts'
												)))]),_vm._v(" "),_c('option',{attrs:{"value":"applicable_not_exists"}},[_vm._v(_vm._s(_vm.__(
														'Apply if other rules are not applicable',
														'easy-woocommerce-discounts'
													)))])])])]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('toggle',{attrs:{"value":_vm.toBool( pricing.status )},on:{"input":function($event){return _vm.updateData( index, pricing, {
												status: $event ? 1 : 0,
											} )}}})],1),_vm._v(" "),_c('td',{staticClass:"asnp-inline-flex asnp-space-x-1 asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/pricing/' + pricing.id,"title":_vm.__(
												'Edit',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-edit",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"title":_vm.__(
												'Duplicate',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.duplicate( pricing.id )}}},[_c('i',{staticClass:"fa fa-copy",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/analytics/' + pricing.id,"title":_vm.__(
												'Analytics',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-bar-chart",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-delete",attrs:{"title":_vm.__(
												'Delete',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.showDeleteWarning( pricing.id )}}},[_c('i',{staticClass:"fa fa-remove",attrs:{"aria-hidden":"true"}})])],1)])}),0)])])])])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.pricingList.length),expression:"! pricingList.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),(_vm.showDeleteModal)?_c('modal',{on:{"apply":function($event){return _vm.deletePricing()},"cancel":function($event){_vm.showDeleteModal = false}}}):_vm._e()],1)}
var PricingListvue_type_template_id_c6fb0f3a_staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('i',{staticClass:"fa fa-reorder reorder-pricing-list",attrs:{"aria-hidden":"true"}})])}]


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/PricingList.vue?vue&type=template&id=c6fb0f3a&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/PricingList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var PricingListvue_type_script_lang_js_ = ({
  name: 'pricing-list',
  data: function data() {
    return {
      pricingList: cloneDeep_default()(this.$store.state.pricingList),
      showLoading: false,
      showDeleteModal: false,
      deleteId: 0
    };
  },
  methods: {
    showDeleteWarning: function showDeleteWarning(id) {
      this.deleteId = id;
      this.showDeleteModal = true;
    },
    deletePricing: function deletePricing() {
      var _this = this;
      this.showDeleteModal = false;
      if (!this.deleteId) {
        return;
      }
      this.showLoading = true;
      condition_deleteItem({
        id: this.deleteId,
        type: PRICING_TYPE
      }).then(function (response) {
        if (1 == response.success) {
          _this.$store.commit('DELETE_PRICING', _this.deleteId);
          _this.pricingList = cloneDeep_default()(_this.$store.state.pricingList);
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
      });
    },
    updateOrders: function updateOrders(event) {
      var _this2 = this;
      this.pricingList.splice(event.newIndex, 0, this.pricingList.splice(event.oldIndex, 1)[0]);
      var conditions = [];
      this.pricingList.forEach(function (value, index) {
        value.ordering = index + 1;
        conditions.push({
          id: value.id,
          ordering: value.ordering
        });
      });
      if (conditions.length) {
        this.showLoading = true;
        reorder({
          conditions: conditions,
          type: PRICING_TYPE
        }).then(function (response) {
          if (1 == response.success && response.conditions) {
            _this2.$store.commit('SET_PRICING_LIST', response.conditions);
            _this2.pricingList = cloneDeep_default()(_this2.$store.state.pricingList);
          }
          _this2.showLoading = false;
        })["catch"](function (error) {
          _this2.showLoading = false;
        });
      }
    },
    updateData: function updateData(index, pricing, data) {
      var _this3 = this;
      this.showLoading = true;
      this.pricingList[index] = Object.assign({}, pricing, data);
      update({
        id: pricing.id,
        type: PRICING_TYPE,
        data: data
      }).then(function (response) {
        if (1 == response.success) {
          _this3.$store.commit('UPDATE_PRICING', response.condition);
        }
        _this3.pricingList = cloneDeep_default()(_this3.$store.state.pricingList);
      })["catch"](function (error) {
        _this3.pricingList[index] = pricing;
      })["finally"](function () {
        _this3.showLoading = false;
      });
    },
    duplicate: function duplicate(id) {
      var _this4 = this;
      this.showLoading = true;
      condition_duplicate({
        id: id,
        type: PRICING_TYPE
      }).then(function (response) {
        if (1 == response.success && response.conditions) {
          _this4.$store.commit('SET_PRICING_LIST', response.conditions);
          _this4.pricingList = cloneDeep_default()(_this4.$store.state.pricingList);
        }
        _this4.showLoading = false;
      })["catch"](function (error) {
        _this4.showLoading = false;
      });
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/PricingList.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_PricingListvue_type_script_lang_js_ = (PricingListvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/PricingList.vue





/* normalize component */

var PricingList_component = Object(componentNormalizer["a" /* default */])(
  views_PricingListvue_type_script_lang_js_,
  PricingListvue_type_template_id_c6fb0f3a_render,
  PricingListvue_type_template_id_c6fb0f3a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var PricingList = (PricingList_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/PricingView.vue?vue&type=template&id=2eb22f43&
var PricingViewvue_type_template_id_2eb22f43_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-pricing-view"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Pricing', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-secondary wccs-page-title-action",attrs:{"to":"/pricing-list","tag":"button"}},[_vm._v(_vm._s(_vm.__( 'Cancel', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary wccs-page-title-action",attrs:{"type":"button"},on:{"click":_vm.savePricing}},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Save', 'easy-woocommerce-discounts' ))+"\n\t\t")])],1),_vm._v(" "),(_vm.saleBadgesAdv)?_c('product-labels'):_vm._e(),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSave),expression:"showSave"}],attrs:{"type":"danger","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Please save changes.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.saveErrors),expression:"saveErrors"}],attrs:{"type":"danger","title":_vm.__( 'Warning!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There are some errors in the form please fix them and save it again.',
					'easy-woocommerce-discounts'
				),"dismissable":true},on:{"dismiss":function($event){_vm.saveErrors = false}}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.savedSuccessfully),expression:"savedSuccessfully"}],attrs:{"type":"success","title":_vm.__( 'Success!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Saved successfully.', 'easy-woocommerce-discounts' ),"dismissable":true},on:{"dismiss":function($event){_vm.savedSuccessfully = false}}})],1),_vm._v(" "),_c('div',{staticClass:"asnp-mt-4 asnp-max-w-2xl asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Name', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.name),expression:"pricing.name"}],staticClass:"asnp-block asnp-text-field",class:{
					'wccs-field-error': _vm.$v.pricing.name.$error,
				},attrs:{"type":"text"},domProps:{"value":(_vm.pricing.name)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.pricing, "name", $event.target.value)},function($event){return _vm.$v.pricing.name.$touch()}]}}),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.pricing.name.required),expression:"! $v.pricing.name.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Status', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.pricing.status )},on:{"input":function($event){return _vm.setToggle( $event, 'status', 1, 0 )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Enable or disable the rule.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Mode', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{staticClass:"asnp-block asnp-select-field",domProps:{"value":_vm.pricing.mode},on:{"change":function($event){return _vm.onModeChange( $event.target.value )}}},[_c('option',{attrs:{"value":"simple"}},[_vm._v(_vm._s(_vm.__( 'Simple', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"bulk"}},[_vm._v(_vm._s(_vm.__( 'Bulk', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"tiered","disabled":""}},[_vm._v(_vm._s(_vm.__( 'Tiered', 'easy-woocommerce-discounts' ) +
					' - ' +
					_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"products_group","disabled":""}},[_vm._v(_vm._s(_vm.__( 'Products group', 'easy-woocommerce-discounts' ) +
					' - ' +
					_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"bogo","disabled":""}},[_vm._v(_vm._s(_vm.__(
						'Buy x Get x - same product',
						'easy-woocommerce-discounts'
					) +
					' - ' +
					_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"purchase_x_receive_y","disabled":""}},[_vm._v(_vm._s(_vm.__(
						'Buy x Get y - different product',
						'easy-woocommerce-discounts'
					) +
					' - ' +
					_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"exclude","disabled":""}},[_vm._v(_vm._s(_vm.__(
						'Exclude products from all rules',
						'easy-woocommerce-discounts'
					) +
					' - ' +
					_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sSimple:%s Just a simple discount that will apply to listed discounted products.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sBulk:%s Adjusts discounted products price based on quantities added to the cart - All units get the highest discount.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sTiered:%s Adjusts discounted products price based on quantities added to the cart - Subsequent units get increasing discount.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sProducts group:%s Adjusts specified products group price.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sPurchase X Receive Y:%s Apply discount to specified number of discounted items when customer adds specified number of listed purchased items to the cart.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sPurchase X Receive Y - same products:%s Same as Purchase X Receive Y but purchased and discounted products are same. Use this mode when purchase and receive products are same.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sExample 1 for Purchase X Receive Y:%s purchase two number of the product to get one free.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sExample 2 for Purchase X Receive Y:%s purchase product X to get %2$s discount on product Y.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sExclude products from all rules:%s excludes selected products from all of pricing rules.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}})]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.isExclude),expression:"! isExclude"}],staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Apply Mode', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.apply_mode),expression:"pricing.apply_mode"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.pricing, "apply_mode", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Non Exclusive', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__(
							'Apply with other applicable rules',
							'easy-woocommerce-discounts'
						)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Exclusive', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"individually"}},[_vm._v(_vm._s(_vm.__(
							'Apply this rule and disregard other rules',
							'easy-woocommerce-discounts'
						)))]),_vm._v(" "),_c('option',{attrs:{"value":"applicable_not_exists"}},[_vm._v(_vm._s(_vm.__(
							'Apply if other rules are not applicable',
							'easy-woocommerce-discounts'
						)))])])])]),_vm._v(" "),(_vm.isBulk || _vm.isTiered || _vm.isPurchase || _vm.isPurchaseSame)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Quantity Based On', 'easy-woocommerce-discounts' )))]),_vm._v(" "),(_vm.isBulk || _vm.isTiered || _vm.isPurchase || _vm.isPurchaseSame)?_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.quantity_based_on),expression:"pricing.quantity_based_on"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.pricing, "quantity_based_on", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Single product', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"single_product"}},[_vm._v(_vm._s(_vm.__( 'Single product', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"single_product_variation","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Single product variation',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"cart_line_item","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Cart line item',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'All products', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"category","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Sum of categories quantities',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"all_products","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Sum of all products quantities',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))])])]):_vm._e(),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sSingle product:%s Quantity is calculated separately for each product.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sSingle product variation:%s Quantity is calculated separately for each product variation, for simple products quantity will calculated based on product.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sCart line item:%s Quantity is calculated separately for each product line in the cart.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sSum of categories quantities:%s Quantity is calculated separately for each category in the cart.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'%sSum of all products quantities:%s Quantity is calculated based on sum of all quantities in the cart.',
							'easy-woocommerce-discounts'
						),
						'<strong>',
						'</strong>'
					)
				)}})]):_vm._e(),_vm._v(" "),(_vm.isBulk)?_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-items-center asnp-w-1/2"},[_c('span',{staticClass:"asnp-field-title asnp-w-1/3"},[_vm._v(_vm._s(_vm.__( 'Display Quantity', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.pricing.display_quantity )},on:{"input":function($event){return _vm.setToggle( $event, 'display_quantity', 'yes', 'no' )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Display quantity column in the quantity table.',
					'easy-woocommerce-discounts'
				)))])]):_vm._e(),_vm._v(" "),(_vm.isBulk)?_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-items-center asnp-w-1/2"},[_c('span',{staticClass:"asnp-field-title asnp-w-1/3"},[_vm._v(_vm._s(_vm.__( 'Display Price', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.pricing.display_price )},on:{"input":function($event){return _vm.setToggle( $event, 'display_price', 'yes', 'no' )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Display price column in the quantity table.',
					'easy-woocommerce-discounts'
				)))])]):_vm._e(),_vm._v(" "),(_vm.isBulk)?_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-items-center asnp-w-1/2"},[_c('span',{staticClass:"asnp-field-title asnp-w-1/3"},[_vm._v(_vm._s(_vm.__( 'Display Discount', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.pricing.display_discount )},on:{"input":function($event){return _vm.setToggle( $event, 'display_discount', 'yes', 'no' )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Display discount column in the quantity table.',
					'easy-woocommerce-discounts'
				)))])]):_vm._e(),_vm._v(" "),(_vm.isTiered)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__(
					'First Discounted Products',
					'easy-woocommerce-discounts'
				)))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.reorder),expression:"pricing.reorder"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.pricing, "reorder", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('option',{attrs:{"value":"desc"}},[_vm._v(_vm._s(_vm.__( 'Expensive Products', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"asc"}},[_vm._v(_vm._s(_vm.__( 'Chepeast Products', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'If discounts are increasing then using "Expensive Products" can help to apply lower discounts on expensive products.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]):_vm._e(),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Message Type', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.message_type),expression:"pricing.message_type"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.pricing, "message_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('option',{attrs:{"value":"text_message"}},[_vm._v(_vm._s(_vm.__( 'Text Message', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"shortcode"}},[_vm._v(_vm._s(_vm.__( 'Shortcode', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isTextMessage),expression:"isTextMessage"}],staticClass:"asnp-space-y-1"},[_c('div',{staticClass:"asnp-inline-flex"},[_c('span',{staticClass:"asnp-field-title asnp-mr-2"},[_vm._v(_vm._s(_vm.__(
						'Message Background Color',
						'easy-woocommerce-discounts'
					)))]),_vm._v(" "),_c('color-picker',{model:{value:(_vm.pricing.message_background_color),callback:function ($$v) {_vm.$set(_vm.pricing, "message_background_color", $$v)},expression:"pricing.message_background_color"}})],1),_vm._v(" "),_c('p',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Background color of the message box, leave it empty to use default background color.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isTextMessage),expression:"isTextMessage"}],staticClass:"asnp-space-y-1"},[_c('div',{staticClass:"asnp-inline-flex"},[_c('span',{staticClass:"asnp-field-title asnp-mr-2"},[_vm._v(_vm._s(_vm.__( 'Message Color', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('color-picker',{model:{value:(_vm.pricing.message_color),callback:function ($$v) {_vm.$set(_vm.pricing, "message_color", $$v)},expression:"pricing.message_color"}})],1),_vm._v(" "),_c('p',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Color of the message in the message box, leave it empty to use default color.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]),_vm._v(" "),(_vm.isPurchase)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Buy Message', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('textarea',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.purchased_message),expression:"pricing.purchased_message"}],staticClass:"asnp-textarea-field",attrs:{"rows":"3"},domProps:{"value":(_vm.pricing.purchased_message)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.pricing, "purchased_message", $event.target.value)}}}),_vm._v(" "),_c('p',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Displayed on the Buy Products page to promote the BOGO deal.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]):_vm._e(),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Message', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('textarea',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.receive_message),expression:"pricing.receive_message"}],staticClass:"asnp-textarea-field",attrs:{"rows":"3"},domProps:{"value":(_vm.pricing.receive_message)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.pricing, "receive_message", $event.target.value)}}}),_vm._v(" "),_c('p',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Displayed on the discounted products page.',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]),_vm._v(" "),(_vm.isPurchase || _vm.isPurchaseSame || _vm.isBOGO || _vm.isProductsGroup)?_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Repeat', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.pricing.repeat )},on:{"input":function($event){return _vm.setToggle( $event, 'repeat' )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.repeatDesc))])]):_vm._e(),_vm._v(" "),(_vm.isSimple || _vm.isProductsGroup)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Adjustment Type', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.discount_type),expression:"pricing.discount_type"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.pricing, "discount_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Discount', 'easy-woocommerce-discounts' )}},[_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isProductsGroup),expression:"isProductsGroup"}],attrs:{"value":"fixed_discount_per_item"}},[_vm._v(_vm._s(_vm.__(
								'Fixed discount per item',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isProductsGroup),expression:"isProductsGroup"}],attrs:{"value":"fixed_discount_per_group"}},[_vm._v(_vm._s(_vm.__(
								'Fixed discount per group',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{attrs:{"value":"percentage_discount"}},[_vm._v(_vm._s(_vm.__(
							'Percentage discount',
							'easy-woocommerce-discounts'
						)))]),_vm._v(" "),_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isSimple),expression:"isSimple"}],attrs:{"value":"price_discount"}},[_vm._v(_vm._s(_vm.__( 'Price discount', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('optgroup',{directives:[{name:"show",rawName:"v-show",value:(_vm.isSimple),expression:"isSimple"}],attrs:{"label":_vm.__( 'Fee', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"percentage_fee","disabled":""}},[_vm._v(_vm._s(_vm.__(
							'Percentage fee',
							'easy-woocommerce-discounts'
						) +
						' - ' +
						_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isSimple),expression:"isSimple"}],attrs:{"value":"price_fee","disabled":""}},[_vm._v(_vm._s(_vm.__( 'Price fee', 'easy-woocommerce-discounts' ) +
						' - ' +
						_vm.__( 'PRO version', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Price', 'easy-woocommerce-discounts' )}},[_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isProductsGroup),expression:"isProductsGroup"}],attrs:{"value":"fixed_price_per_item","disabled":""}},[_vm._v(_vm._s(_vm.__(
								'Fixed price per item',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isProductsGroup),expression:"isProductsGroup"}],attrs:{"value":"fixed_price_per_group","disabled":""}},[_vm._v(_vm._s(_vm.__(
								'Fixed price per group',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.isSimple),expression:"isSimple"}],attrs:{"value":"fixed_price","disabled":""}},[_vm._v(_vm._s(_vm.__(
								'Fixed price',
								'easy-woocommerce-discounts'
							) +
							' - ' +
							_vm.__(
								'PRO version',
								'easy-woocommerce-discounts'
							)))])])])]):_vm._e(),_vm._v(" "),(_vm.isSimple || _vm.isProductsGroup)?_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Adjustment', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.discount),expression:"pricing.discount"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
					'wccs-field-error': _vm.$v.pricing.discount.$error,
				},attrs:{"type":"number"},domProps:{"value":(_vm.pricing.discount)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.pricing, "discount", $event.target.value)},function($event){return _vm.$v.pricing.discount.$touch()}]}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.sprintf(
					_vm.__(
						'Discount amount should be greater than %d.',
						'easy-woocommerce-discounts'
					),
					0
				)))]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.pricing.discount.required),expression:"! $v.pricing.discount.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.pricing.discount.greaterValue),expression:"! $v.pricing.discount.greaterValue"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__(
						'Please enter a valid value.',
						'easy-woocommerce-discounts'
					)))])]):_vm._e(),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Usage Limit', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.pricing.usage_limit),expression:"pricing.usage_limit"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
				},attrs:{"type":"number"},domProps:{"value":(_vm.pricing.usage_limit)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.pricing, "usage_limit", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Leave blank for unlimited usage. To set a usage limit for individual users, please refer to the "User usage limit" condition in the conditions list.',
					'easy-woocommerce-discounts'
				)))])])]),_vm._v(" "),_c('h3',{directives:[{name:"show",rawName:"v-show",value:(_vm.isBulk || _vm.isTiered),expression:"isBulk || isTiered"}],staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Quantities', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('p',{directives:[{name:"show",rawName:"v-show",value:(_vm.isBulk || _vm.isTiered),expression:"isBulk || isTiered"}],staticClass:"asnp-mb-4",domProps:{"innerHTML":_vm._s(
			_vm.sprintf(
				_vm.__(
					'Adjusts discounted products price based on quantities added to the cart.%1$s Set quantities ranges and each range discount amount.%1$s Leave Quantity maximum empty to setting no limit for range.',
					'easy-woocommerce-discounts'
				),
				'<br>'
			)
		)}}),_vm._v(" "),(_vm.isBulk || _vm.isTiered)?_c('pricing-quantity-discount',{attrs:{"quantities":_vm.pricing.quantities}}):_vm._e(),_vm._v(" "),_c('p',{directives:[{name:"show",rawName:"v-show",value:(( _vm.isBulk || _vm.isTiered ) && ! _vm.$v.pricing.quantities.required),expression:"( isBulk || isTiered ) && ! $v.pricing.quantities.required"}],staticClass:"asnp-error-msg asnp-mt-1"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('h3',{staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.discountedItems)+"\n\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-mb-4"},[_vm._v(_vm._s(_vm.discountedItemsDesc))]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.pricing.items.length),expression:"! pricing.items.length"}],attrs:{"type":"danger","title":_vm.__( 'Warning!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),(! _vm.isProductsGroup)?_c('products-select-container',{attrs:{"items":_vm.pricing.items,"keyName":"product","hiddenRows":[ 'quantity' ],"hiddenOptions":[ 'discounted_products' ],"type":"discounted"},on:{"productsUpdated":_vm.onDiscountedItemUpdated,"deleteItem":_vm.onDeleteItem,"itemAdded":_vm.addNewDiscountedProducts,"groupAdded":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}):_vm._e(),_vm._v(" "),_c('h3',{staticClass:"asnp-my-4 asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Excluded Products', 'easy-woocommerce-discounts' ))+"\n\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-mb-4"},[_vm._v("\n\t\t"+_vm._s(_vm.__(
				'Exclude products from this rule.',
				'easy-woocommerce-discounts'
			))+"\n\t")]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.pricing.exclude_items.length),expression:"! pricing.exclude_items.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),_c('products-select-container',{attrs:{"items":_vm.pricing.exclude_items,"keyName":"excludeProduct","hiddenRows":[ 'quantity' ],"hiddenOptions":_vm.excludeItemsHiddenOptions,"type":"excluded"},on:{"productsUpdated":_vm.onExcludedItemUpdated,"deleteItem":_vm.onDeleteItem,"itemAdded":_vm.addNewExcludedProducts,"groupAdded":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Date Time', 'easy-woocommerce-discounts' ))+"\n\t\t\t"),_c('current-time')],1)]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.pricing.date_time.length),expression:"! pricing.date_time.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any date time.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('date-time-container',{attrs:{"items":_vm.pricing.date_time},on:{"dateTimeUpdated":_vm.onDateTimeItemUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewDateTime,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Conditions', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.pricing.conditions.length),expression:"! pricing.conditions.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any condition.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('conditions-container',{attrs:{"items":_vm.pricing.conditions,"ignoreGroups":_vm.ignoreGroups,"ignoreItems":_vm.ignoreItems},on:{"conditionUpdated":_vm.onPricingConditionUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewCondition,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}})],1)}
var PricingViewvue_type_template_id_2eb22f43_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/PricingView.vue?vue&type=template&id=2eb22f43&

// EXTERNAL MODULE: external {"this":["ewd","validators"]}
var external_this_ewd_validators_ = __webpack_require__(67);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/PricingQuantityDiscount.vue?vue&type=template&id=6fb73952&
var PricingQuantityDiscountvue_type_template_id_6fb73952_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('table',{staticClass:"widefat"},[_c('thead',[_c('tr',[_c('th',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'Quantity minimum', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('th',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'Quantity maximum', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('th',[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'Discount type', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('th',[_vm._v(_vm._s(_vm.__( 'Discount', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('th')])]),_vm._v(" "),_c('tbody',[_vm._l((_vm.myQuantities),function(quantity,index){return _c('tr',{key:_vm.getKey( quantity, 'quantity' )},[_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(quantity.min),expression:"quantity.min"}],staticClass:"asnp-text-field",attrs:{"type":"number","placeholder":_vm.__( 'Min', 'easy-woocommerce-discounts' )},domProps:{"value":(quantity.min)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(quantity, "min", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(quantity.max),expression:"quantity.max"}],staticClass:"asnp-text-field",attrs:{"type":"number","placeholder":_vm.__( 'Max - No limit', 'easy-woocommerce-discounts' )},domProps:{"value":(quantity.max)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(quantity, "max", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('select',{directives:[{name:"model",rawName:"v-model",value:(quantity.discount_type),expression:"quantity.discount_type"}],staticClass:"asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(quantity, "discount_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Discount', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"percentage_discount"}},[_vm._v(_vm._s(_vm.__(
								'Percentage discount',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{attrs:{"value":"price_discount"}},[_vm._v(_vm._s(_vm.__(
								'Price discount',
								'easy-woocommerce-discounts'
							)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Price', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"disabled":"","value":"fixed_price"}},[_vm._v(_vm._s(_vm.__(
								'Fixed price',
								'easy-woocommerce-discounts'
							)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Fee', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"disabled":"","value":"percentage_fee"}},[_vm._v(_vm._s(_vm.__(
								'Percentage fee',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{attrs:{"disabled":"","value":"price_fee"}},[_vm._v(_vm._s(_vm.__( 'Price fee', 'easy-woocommerce-discounts' )))])])])]),_vm._v(" "),_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(quantity.discount),expression:"quantity.discount"}],staticClass:"asnp-text-field",attrs:{"type":"number"},domProps:{"value":(quantity.discount)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(quantity, "discount", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('button',{staticClass:"asnp-btn asnp-btn-delete",on:{"click":function($event){return _vm.deleteQuantity( index )}}},[_vm._v("\n\t\t\t\t\t"+_vm._s(_vm.__( 'Delete', 'easy-woocommerce-discounts' ))+"\n\t\t\t\t")])])])}),_vm._v(" "),_c('tr',[_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.newQuantity.min),expression:"newQuantity.min"}],staticClass:"asnp-text-field",attrs:{"type":"number","placeholder":_vm.__( 'Min', 'easy-woocommerce-discounts' )},domProps:{"value":(_vm.newQuantity.min)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.newQuantity, "min", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.newQuantity.max),expression:"newQuantity.max"}],staticClass:"asnp-text-field",attrs:{"type":"number","placeholder":_vm.__( 'Max - No limit', 'easy-woocommerce-discounts' )},domProps:{"value":(_vm.newQuantity.max)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.newQuantity, "max", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.newQuantity.discount_type),expression:"newQuantity.discount_type"}],staticClass:"asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.newQuantity, "discount_type", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Discount', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"percentage_discount"}},[_vm._v(_vm._s(_vm.__(
								'Percentage discount',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{attrs:{"value":"price_discount"}},[_vm._v(_vm._s(_vm.__(
								'Price discount',
								'easy-woocommerce-discounts'
							)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Price', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"disabled":"","value":"fixed_price"}},[_vm._v(_vm._s(_vm.__(
								'Fixed price',
								'easy-woocommerce-discounts'
							)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Fee', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"disabled":"","value":"percentage_fee"}},[_vm._v(_vm._s(_vm.__(
								'Percentage fee',
								'easy-woocommerce-discounts'
							)))]),_vm._v(" "),_c('option',{attrs:{"disabled":"","value":"price_fee"}},[_vm._v(_vm._s(_vm.__( 'Price fee', 'easy-woocommerce-discounts' )))])])])]),_vm._v(" "),_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.newQuantity.discount),expression:"newQuantity.discount"}],staticClass:"asnp-text-field",attrs:{"type":"number"},domProps:{"value":(_vm.newQuantity.discount)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.newQuantity, "discount", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('button',{staticClass:"asnp-btn asnp-btn-primary",on:{"click":_vm.addQuantity}},[_vm._v("\n\t\t\t\t\t"+_vm._s(_vm.__( 'Add', 'easy-woocommerce-discounts' ))+"\n\t\t\t\t")])])])],2)])}
var PricingQuantityDiscountvue_type_template_id_6fb73952_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/PricingQuantityDiscount.vue?vue&type=template&id=6fb73952&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/PricingQuantityDiscount.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var PricingQuantityDiscountvue_type_script_lang_js_ = ({
  name: 'pricing-quantity-discount',
  props: {
    quantities: {
      type: Array
    }
  },
  data: function data() {
    return {
      myQuantities: this.quantities,
      newQuantity: this.initialQuantity()
    };
  },
  methods: {
    addQuantity: function addQuantity() {
      this.myQuantities.push(this.newQuantity);
      this.myQuantities.sort(function (a, b) {
        return a.min - b.min;
      });
      this.newQuantity = this.initialQuantity();
    },
    deleteQuantity: function deleteQuantity(index) {
      this.myQuantities.splice(index, 1);
    },
    initialQuantity: function initialQuantity() {
      return {
        min: '',
        max: '',
        discount_type: 'percentage_discount',
        discount: 0
      };
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/PricingQuantityDiscount.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_PricingQuantityDiscountvue_type_script_lang_js_ = (PricingQuantityDiscountvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/PricingQuantityDiscount.vue





/* normalize component */

var PricingQuantityDiscount_component = Object(componentNormalizer["a" /* default */])(
  components_PricingQuantityDiscountvue_type_script_lang_js_,
  PricingQuantityDiscountvue_type_template_id_6fb73952_render,
  PricingQuantityDiscountvue_type_template_id_6fb73952_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var PricingQuantityDiscount = (PricingQuantityDiscount_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ColorPicker.vue?vue&type=template&id=1587bc71&
var ColorPickervue_type_template_id_1587bc71_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('input',{ref:"input",staticClass:"wccs-colorpicker",attrs:{"type":"text"},domProps:{"value":_vm.value}})}
var ColorPickervue_type_template_id_1587bc71_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ColorPicker.vue?vue&type=template&id=1587bc71&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ColorPicker.vue?vue&type=script&lang=js&
//
//
//
//

/* harmony default export */ var ColorPickervue_type_script_lang_js_ = ({
  name: 'color-picker',
  props: {
    value: {
      type: String,
      value: ''
    }
  },
  mounted: function mounted() {
    this.init();
  },
  methods: {
    init: function init() {
      var vm = this;
      var $el = jQuery(this.$refs.input);
      $el.wpColorPicker({
        hide: true,
        change: function change(event, ui) {
          vm.$emit('input', ui.color.toString());
        }
      });
      jQuery('.wp-picker-clear', $el.closest('.wp-picker-input-wrap')).on('click', function (e) {
        vm.$emit('input', '');
      });
    }
  },
  watch: {
    value: function value(_value) {
      jQuery(this.$refs.input).iris('color', _value);
    }
  },
  destroyed: function destroyed() {
    jQuery(this.$refs.input).off();
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ColorPicker.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ColorPickervue_type_script_lang_js_ = (ColorPickervue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ColorPicker.vue





/* normalize component */

var ColorPicker_component = Object(componentNormalizer["a" /* default */])(
  components_ColorPickervue_type_script_lang_js_,
  ColorPickervue_type_template_id_1587bc71_render,
  ColorPickervue_type_template_id_1587bc71_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ColorPicker = (ColorPicker_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/PricingView.vue?vue&type=script&lang=js&
function PricingViewvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return PricingViewvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, PricingViewvue_type_script_lang_js_typeof(o); }
function PricingViewvue_type_script_lang_js_toConsumableArray(r) { return PricingViewvue_type_script_lang_js_arrayWithoutHoles(r) || PricingViewvue_type_script_lang_js_iterableToArray(r) || PricingViewvue_type_script_lang_js_unsupportedIterableToArray(r) || PricingViewvue_type_script_lang_js_nonIterableSpread(); }
function PricingViewvue_type_script_lang_js_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function PricingViewvue_type_script_lang_js_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return PricingViewvue_type_script_lang_js_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? PricingViewvue_type_script_lang_js_arrayLikeToArray(r, a) : void 0; } }
function PricingViewvue_type_script_lang_js_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function PricingViewvue_type_script_lang_js_arrayWithoutHoles(r) { if (Array.isArray(r)) return PricingViewvue_type_script_lang_js_arrayLikeToArray(r); }
function PricingViewvue_type_script_lang_js_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function PricingViewvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function PricingViewvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? PricingViewvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { PricingViewvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : PricingViewvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function PricingViewvue_type_script_lang_js_defineProperty(e, r, t) { return (r = PricingViewvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function PricingViewvue_type_script_lang_js_toPropertyKey(t) { var i = PricingViewvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == PricingViewvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function PricingViewvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != PricingViewvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != PricingViewvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//













/* harmony default export */ var PricingViewvue_type_script_lang_js_ = ({
  name: 'pricing-view',
  components: {
    DateTimeContainer: DateTimeContainer,
    PricingQuantityDiscount: PricingQuantityDiscount,
    ColorPicker: ColorPicker,
    ProductsSelectItem: ProductsSelectItem,
    ProductsSelectContainer: ProductsSelectContainer,
    ConditionsContainer: ConditionsContainer
  },
  data: function data() {
    var pricing = {
        name: 'Pricing',
        status: 1,
        apply_mode: 'all',
        mode: 'simple',
        date_time: [],
        items: [],
        exclude_items: [],
        conditions: [],
        discount_type: 'percentage_discount',
        discount: '',
        ordering: 0,
        message_type: 'text_message',
        message_background_color: '',
        message_color: '',
        quantity_based_on: 'single_product',
        quantities: [],
        display_quantity: 'yes',
        display_price: 'yes',
        display_discount: 'yes',
        usage_limit: '',
        purchased_message: '',
        receive_message: ''
      },
      id = 'new' !== this.$route.params.id ? parseInt(this.$route.params.id) : 0;
    if (id > 0) {
      for (var i = 0, max = this.$store.state.pricingList.length; i < max; i++) {
        if (id == this.$store.state.pricingList[i].id) {
          var item = cloneDeep_default()(this.$store.state.pricingList[i]);
          pricing = PricingViewvue_type_script_lang_js_objectSpread(PricingViewvue_type_script_lang_js_objectSpread({}, pricing), item);
          break;
        }
      }
    }
    return {
      id: id,
      pricing: pricing,
      ordering: pricing.ordering,
      showSave: false,
      savedSuccessfully: false,
      saveErrors: false,
      showLoading: false,
      ignoreGroups: ['shipping_package', 'shipping_package_items'],
      ignoreItems: ['subtotal_including_tax_excluding_coupons', 'subtotal_excluding_tax_excluding_coupons'],
      excludeItemsHiddenOptions: ['all_products', 'products_not_in_list', 'product_variations_not_in_list', 'recently_viewed_products', 'discounted_products', 'similar_products_to_customer_cart_products']
    };
  },
  methods: {
    onModeChange: function onModeChange(newMode) {
      this.pricing.mode = newMode;
      if (this.isSimple) {
        if (-1 != ['fixed_discount_per_item', 'fixed_discount_per_group', 'fixed_price_per_item', 'fixed_price_per_group'].indexOf(this.pricing.discount_type)) {
          this.pricing.discount_type = 'percentage_discount';
        }
      }
    },
    onDateTimeItemUpdated: function onDateTimeItemUpdated(groupIndex, dateTime, index) {
      this.pricing.date_time[groupIndex][index] = dateTime;
    },
    onDiscountedItemUpdated: function onDiscountedItemUpdated(groupIndex, products) {
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (null == index) {
        this.pricing.items[groupIndex] = products;
      } else {
        this.pricing.items[groupIndex][index] = products;
      }
    },
    onExcludedItemUpdated: function onExcludedItemUpdated(groupIndex, products, index) {
      this.pricing.exclude_items[groupIndex][index] = products;
    },
    onDeleteItem: function onDeleteItem(type, index) {
      var groupIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var items, group;
      switch (type) {
        case 'dateTime':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.date_time);
          group = PricingViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.pricing.date_time = items;
          break;
        case 'discounted':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.items);
          if (null == groupIndex) {
            items = items.filter(function (item, idx) {
              return idx != index;
            });
          } else {
            group = PricingViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
            group = group.filter(function (item, idx) {
              return idx != index;
            });
            if (!group.length) {
              items = items.filter(function (item, idx) {
                return idx != groupIndex;
              });
            } else {
              items[groupIndex] = group;
            }
          }
          this.pricing.items = items;
          break;
        case 'condition':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.conditions);
          group = PricingViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.pricing.conditions = items;
          break;
        case 'purchased':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.purchased_items);
          group = PricingViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.pricing.purchased_items = items;
          break;
        case 'excluded':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.exclude_items);
          group = PricingViewvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.pricing.exclude_items = items;
          break;
        default:
          break;
      }
    },
    onAddGroup: function onAddGroup(type) {
      switch (type) {
        case 'discounted':
          this.pricing.items = [].concat(PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.items), [[this.initialProducts()]]);
          break;
        case 'purchased':
          this.pricing.purchased_items = [].concat(PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.purchased_items), [[this.initialProducts()]]);
          break;
        case 'excluded':
          this.pricing.exclude_items = [].concat(PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.exclude_items), [[this.initialProducts()]]);
          break;
        case 'condition':
          this.pricing.conditions = [].concat(PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.conditions), [[this.initialCondition()]]);
          break;
        case 'dateTime':
          this.pricing.date_time = [].concat(PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.date_time), [[this.initialDateTime()]]);
          break;
      }
    },
    onDeleteGroup: function onDeleteGroup(index, type) {
      var items;
      switch (type) {
        case 'discounted':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.items);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.pricing.items = items;
          break;
        case 'purchased':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.purchased_items);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.pricing.purchased_items = items;
          break;
        case 'excluded':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.exclude_items);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.pricing.exclude_items = items;
          break;
        case 'condition':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.conditions);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.pricing.conditions = items;
          break;
        case 'dateTime':
          items = PricingViewvue_type_script_lang_js_toConsumableArray(this.pricing.date_time);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.pricing.date_time = items;
          break;
      }
    },
    onPricingConditionUpdated: function onPricingConditionUpdated(groupIndex, condition, index) {
      this.pricing.conditions[groupIndex][index] = condition;
    },
    addNewDateTime: function addNewDateTime(index) {
      this.pricing.date_time[index].push(this.initialDateTime());
    },
    addNewDiscountedProducts: function addNewDiscountedProducts() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (null == index) {
        this.pricing.items.push(this.initialProducts());
      } else {
        this.pricing.items[index].push(this.initialProducts());
      }
    },
    addNewExcludedProducts: function addNewExcludedProducts(index) {
      this.pricing.exclude_items[index].push(this.initialProducts());
    },
    addNewPurchasedProducts: function addNewPurchasedProducts(index) {
      this.pricing.purchased_items[index].push(this.initialProducts());
    },
    addNewCondition: function addNewCondition(index) {
      this.pricing.conditions[index].push(this.initialCondition());
    },
    checkErrors: function checkErrors() {
      if (!this.pricing.name.trim().length) {
        return this.saveErrors = true;
      } else if (!this.pricing.items.length) {
        return this.saveErrors = true;
      } else if (this.isSimple) {
        if (!this.pricing.discount.length || parseFloat(this.pricing.discount) <= 0) {
          return this.saveErrors = true;
        }
      } else if (this.isBulk || this.isTiered) {
        if (!this.pricing.quantities || !this.pricing.quantities.length) {
          return this.saveErrors = true;
        }
      }
      return this.saveErrors = false;
    },
    savePricing: function savePricing() {
      var _this = this;
      if (this.checkErrors()) {
        return;
      }
      this.showLoading = true;
      this.savedSuccessfully = false;
      var data = {
        type: PRICING_TYPE,
        status: this.pricing.status,
        apply_mode: this.pricing.apply_mode,
        mode: this.pricing.mode,
        id: this.id,
        name: this.pricing.name,
        items: this.pricing.items,
        exclude_items: this.pricing.exclude_items,
        conditions: this.pricing.conditions,
        date_time: this.pricing.date_time,
        usage_limit: this.pricing.usage_limit,
        ordering: this.ordering,
        message_type: this.pricing.message_type,
        message_background_color: this.pricing.message_background_color,
        message_color: this.pricing.message_color,
        receive_message: this.pricing.receive_message
      };
      if (this.isBulk || this.isTiered) {
        data.quantity_based_on = this.pricing.quantity_based_on;
        data.quantities = this.pricing.quantities;
        if (this.isBulk) {
          data.display_quantity = this.pricing.display_quantity;
          data.display_price = this.pricing.display_price;
          data.display_discount = this.pricing.display_discount;
        }
      } else if (this.isSimple) {
        data.discount_type = this.pricing.discount_type;
        data.discount = this.pricing.discount;
      }
      condition_save(data).then(function (response) {
        if (1 == response.success) {
          if (!_this.id) {
            _this.ordering = parseInt(response.condition.ordering);
            _this.id = parseInt(response.condition.id);
          }
          _this.$store.commit('ADD_PRICING', response.condition);
          _this.showSave = false;
          _this.savedSuccessfully = true;
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
        console.log(error);
      });
    },
    setToggle: function setToggle(value, prop) {
      var trueValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var falseValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      this.pricing = Object.assign({}, this.pricing, PricingViewvue_type_script_lang_js_defineProperty({}, prop, value ? trueValue : falseValue));
    }
  },
  computed: {
    isSimple: function isSimple() {
      return 'simple' === this.pricing.mode;
    },
    isBulk: function isBulk() {
      return 'bulk' === this.pricing.mode;
    },
    isTiered: function isTiered() {
      return 'tiered' === this.pricing.mode;
    },
    isProductsGroup: function isProductsGroup() {
      return 'products_group' === this.pricing.mode;
    },
    isPurchase: function isPurchase() {
      return 'purchase_x_receive_y' === this.pricing.mode;
    },
    isPurchaseSame: function isPurchaseSame() {
      return 'purchase_x_receive_y_same' === this.pricing.mode;
    },
    isBOGO: function isBOGO() {
      return 'bogo' === this.pricing.mode;
    },
    isTextMessage: function isTextMessage() {
      return 'text_message' === this.pricing.message_type;
    },
    isExclude: function isExclude() {
      return 'exclude' === this.pricing.mode;
    },
    discountedItems: function discountedItems() {
      if (this.isSimple || this.isBulk || this.isTiered || this.isPurchase || this.isPurchaseSame || this.isBOGO) {
        return Object(external_this_wp_i18n_["__"])('Discounted products', 'easy-woocommerce-discounts');
      } else if (this.isProductsGroup) {
        return Object(external_this_wp_i18n_["__"])('Products group', 'easy-woocommerce-discounts');
      } else if (this.isExclude) {
        return Object(external_this_wp_i18n_["__"])('Products', 'easy-woocommerce-discounts');
      }
    },
    discountedItemsDesc: function discountedItemsDesc() {
      if (this.isExclude) {
        return Object(external_this_wp_i18n_["__"])('Products that will be excluded from results of products list.', 'easy-woocommerce-discounts');
      }
      return Object(external_this_wp_i18n_["__"])('List of products that will receive this discount.', 'easy-woocommerce-discounts');
    },
    repeatDesc: function repeatDesc() {
      if (this.isProductsGroup) {
        return Object(external_this_wp_i18n_["__"])('Apply this rule again if more than one matching group added to the cart.', 'easy-woocommerce-discounts');
      }
      return Object(external_this_wp_i18n_["__"])('Repeat means that this discount will be applied more than once when possible.', 'easy-woocommerce-discounts');
    }
  },
  watch: {
    pricing: {
      handler: function handler(newPricing) {
        if (this.id > 0) {
          this.showSave = true;
        }
      },
      deep: true
    }
  },
  validations: {
    pricing: {
      name: {
        required: required_default.a
      },
      discount: {
        required: required_default.a,
        greaterValue: Object(external_this_ewd_validators_["greaterValue"])(0)
      },
      quantities: {
        required: required_default.a
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/PricingView.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_PricingViewvue_type_script_lang_js_ = (PricingViewvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/PricingView.vue





/* normalize component */

var PricingView_component = Object(componentNormalizer["a" /* default */])(
  views_PricingViewvue_type_script_lang_js_,
  PricingViewvue_type_template_id_2eb22f43_render,
  PricingViewvue_type_template_id_2eb22f43_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var PricingView = (PricingView_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/CheckoutFeeList.vue?vue&type=template&id=2627b3c5&
var CheckoutFeeListvue_type_template_id_2627b3c5_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-checkout-fee-list"}},[_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Checkout Fees', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('alert',{attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.message,"style-object":{ width: '600px', 'margin-top': '20px' }}})],1)}
var CheckoutFeeListvue_type_template_id_2627b3c5_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/CheckoutFeeList.vue?vue&type=template&id=2627b3c5&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/CheckoutFeeList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var CheckoutFeeListvue_type_script_lang_js_ = ({
  name: 'checkout-fee-list',
  computed: {
    message: function message() {
      return Object(external_this_wp_i18n_["sprintf"])(Object(external_this_wp_i18n_["__"])('This feature is available only in the pro version, %1$s or %2$s.', 'easy-woocommerce-discounts'), '<a href="https://www.asanaplugins.com/product/advanced-woocommerce-dynamic-pricing-discounts/?utm_source=easy-woocommerce-discounts-free&utm_campaign=easy-woocommerce-discounts&utm_medium=link" target="_blank" class="asnp-underline asnp-font-bold">' + Object(external_this_wp_i18n_["__"])('Go Pro', 'easy-woocommerce-discounts') + '</a>', '<a href="http://pricing-and-discounts.asanaplugins.com/" target="_blank" class="asnp-underline asnp-font-bold">' + Object(external_this_wp_i18n_["__"])('Try It Now', 'easy-woocommerce-discounts') + '</a>');
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/CheckoutFeeList.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_CheckoutFeeListvue_type_script_lang_js_ = (CheckoutFeeListvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/CheckoutFeeList.vue





/* normalize component */

var CheckoutFeeList_component = Object(componentNormalizer["a" /* default */])(
  views_CheckoutFeeListvue_type_script_lang_js_,
  CheckoutFeeListvue_type_template_id_2627b3c5_render,
  CheckoutFeeListvue_type_template_id_2627b3c5_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CheckoutFeeList = (CheckoutFeeList_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/ShippingList.vue?vue&type=template&id=72b6c750&
var ShippingListvue_type_template_id_72b6c750_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-shipping-list"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Shipping Methods', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":"/shipping/new"}},[_vm._v(_vm._s(_vm.__( 'Add New', 'easy-woocommerce-discounts' )))])],1),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.shippingList.length),expression:"shippingList.length"}],staticClass:"asnp-flex asnp-flex-col"},[_c('div',{staticClass:"asnp-my-2 asnp-overflow-x-auto sm:asnp-mx-6 lg:asnp-mx-8"},[_c('div',{staticClass:"asnp-py-2 asnp-align-middle asnp-inline-block asnp-min-w-full sm:asnp-px-6 lg:asnp-px-8"},[_c('div',{staticClass:"asnp-shadow asnp-overflow-hidden asnp-border-b asnp-border-gray-200 sm:asnp-rounded-lg"},[_c('table',{staticClass:"asnp-min-w-full asnp-divide-y asnp-divide-gray-200",attrs:{"id":"shipping-list"}},[_c('thead',{staticClass:"asnp-bg-gray-50"},[_c('tr',[_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}}),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'ID',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Name',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Apply Mode',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Status',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-6 asnp-py-3 asnp-text-left asnp-text-xs asnp-font-medium asnp-text-gray-500 asnp-uppercase asnp-tracking-wider",attrs:{"scope":"col"}},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
											'Actions',
											'easy-woocommerce-discounts'
										))+"\n\t\t\t\t\t\t\t\t")])])]),_vm._v(" "),_c('tbody',{directives:[{name:"sortable",rawName:"v-sortable",value:({
								handle: '.reorder-shipping-list',
								onUpdate: _vm.updateOrders,
							}),expression:"{\n\t\t\t\t\t\t\t\thandle: '.reorder-shipping-list',\n\t\t\t\t\t\t\t\tonUpdate: updateOrders,\n\t\t\t\t\t\t\t}"}],staticClass:"asnp-bg-white asnp-divide-y asnp-divide-gray-200"},_vm._l((_vm.shippingList),function(shipping,index){return _c('tr',{key:shipping.id},[_vm._m(0,true),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_vm._v("\n\t\t\t\t\t\t\t\t\t"+_vm._s(shipping.id)+"\n\t\t\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"hover:asnp-text-indigo-500 focus:asnp-outline-none focus:asnp-shadow-none",attrs:{"to":'/shipping/' + shipping.id}},[_vm._v(_vm._s(shipping.name +
											( null !=
												shipping.private_note &&
											shipping.private_note.length
												? ' | ' +
												  shipping.private_note
												: '' )))])],1),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('select',{staticClass:"asnp-select-field",domProps:{"value":shipping.apply_mode},on:{"change":function($event){return _vm.updateData( index, shipping, {
												apply_mode:
													$event.target.value,
											} )}}},[_c('optgroup',{attrs:{"label":_vm.__(
													'Non Exclusive',
													'easy-woocommerce-discounts'
												)}},[_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__(
													'Apply with other applicable rules',
													'easy-woocommerce-discounts'
												)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__(
													'Exclusive',
													'easy-woocommerce-discounts'
												)}},[_c('option',{attrs:{"value":"individually"}},[_vm._v(_vm._s(_vm.__(
													'Apply this rule and disregard other rules',
													'easy-woocommerce-discounts'
												)))]),_vm._v(" "),_c('option',{attrs:{"value":"applicable_not_exists"}},[_vm._v(_vm._s(_vm.__(
														'Apply if other rules are not applicable',
														'easy-woocommerce-discounts'
													)))])])])]),_vm._v(" "),_c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('toggle',{attrs:{"value":_vm.toBool( shipping.status )},on:{"input":function($event){return _vm.updateData( index, shipping, {
												status: $event ? 1 : 0,
											} )}}})],1),_vm._v(" "),_c('td',{staticClass:"asnp-flex asnp-space-x-1 asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/shipping/' + shipping.id,"title":_vm.__(
												'Edit',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-edit",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"title":_vm.__(
												'Duplicate',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.duplicate( shipping.id )}}},[_c('i',{staticClass:"fa fa-copy",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"to":'/analytics/' + shipping.id,"title":_vm.__(
												'Analytics',
												'easy-woocommerce-discounts'
											)}},[_c('i',{staticClass:"fa fa-bar-chart",attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-delete",attrs:{"title":_vm.__(
												'Delete',
												'easy-woocommerce-discounts'
											)},on:{"click":function($event){return _vm.showDeleteWarning( shipping.id )}}},[_c('i',{staticClass:"fa fa-remove",attrs:{"aria-hidden":"true"}})])],1)])}),0)])])])])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.shippingList.length),expression:"! shippingList.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'There is not any item.', 'easy-woocommerce-discounts' ),"style-object":{ width: '600px', 'margin-top': '20px' }}})],1),_vm._v(" "),(_vm.showDeleteModal)?_c('modal',{on:{"apply":function($event){return _vm.deleteItem()},"cancel":function($event){_vm.showDeleteModal = false}}}):_vm._e()],1)}
var ShippingListvue_type_template_id_72b6c750_staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('td',{staticClass:"asnp-px-6 asnp-py-4 asnp-whitespace-nowrap"},[_c('i',{staticClass:"fa fa-reorder reorder-shipping-list",attrs:{"aria-hidden":"true"}})])}]


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ShippingList.vue?vue&type=template&id=72b6c750&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/ShippingList.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var ShippingListvue_type_script_lang_js_ = ({
  name: 'shipping-list',
  data: function data() {
    return {
      shippingList: cloneDeep_default()(this.$store.state.shippingList),
      showLoading: false,
      showDeleteModal: false,
      deleteId: 0
    };
  },
  methods: {
    showDeleteWarning: function showDeleteWarning(id) {
      this.deleteId = id;
      this.showDeleteModal = true;
    },
    deleteItem: function deleteItem() {
      var _this = this;
      this.showDeleteModal = false;
      if (!this.deleteId) {
        return;
      }
      this.showLoading = true;
      condition_deleteItem({
        id: this.deleteId,
        type: SHIPPING_TYPE
      }).then(function (response) {
        if (1 == response.success) {
          _this.$store.commit('DELETE_SHIPPING', _this.deleteId);
          _this.shippingList = cloneDeep_default()(_this.$store.state.shippingList);
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
      });
    },
    updateOrders: function updateOrders(event) {
      var _this2 = this;
      this.shippingList.splice(event.newIndex, 0, this.shippingList.splice(event.oldIndex, 1)[0]);
      var conditions = [];
      this.shippingList.forEach(function (value, index) {
        value.ordering = index + 1;
        conditions.push({
          id: value.id,
          ordering: value.ordering
        });
      });
      if (conditions.length) {
        this.showLoading = true;
        reorder({
          conditions: conditions,
          type: SHIPPING_TYPE
        }).then(function (response) {
          if (1 == response.success && response.conditions) {
            _this2.$store.commit('SET_SHIPPING_LIST', response.conditions);
            _this2.shippingList = cloneDeep_default()(_this2.$store.state.shippingList);
          }
          _this2.showLoading = false;
        })["catch"](function (error) {
          _this2.showLoading = false;
        });
      }
    },
    updateData: function updateData(index, shipping, data) {
      var _this3 = this;
      this.showLoading = true;
      this.shippingList[index] = Object.assign({}, shipping, data);
      update({
        id: shipping.id,
        type: SHIPPING_TYPE,
        data: data
      }).then(function (response) {
        if (1 == response.success) {
          _this3.$store.commit('UPDATE_SHIPPING', response.condition);
        }
        _this3.shippingList = cloneDeep_default()(_this3.$store.state.shippingList);
      })["catch"](function (error) {
        _this3.shippingList[index] = shipping;
      })["finally"](function () {
        _this3.showLoading = false;
      });
    },
    duplicate: function duplicate(id) {
      var _this4 = this;
      this.showLoading = true;
      condition_duplicate({
        id: id,
        type: SHIPPING_TYPE
      }).then(function (response) {
        if (1 == response.success && response.conditions) {
          _this4.$store.commit('SET_SHIPPING_LIST', response.conditions);
          _this4.shippingList = cloneDeep_default()(_this4.$store.state.shippingList);
        }
        _this4.showLoading = false;
      })["catch"](function (error) {
        _this4.showLoading = false;
      });
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ShippingList.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_ShippingListvue_type_script_lang_js_ = (ShippingListvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/ShippingList.vue





/* normalize component */

var ShippingList_component = Object(componentNormalizer["a" /* default */])(
  views_ShippingListvue_type_script_lang_js_,
  ShippingListvue_type_template_id_72b6c750_render,
  ShippingListvue_type_template_id_72b6c750_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ShippingList = (ShippingList_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/Shipping.vue?vue&type=template&id=5cd82ad0&
var Shippingvue_type_template_id_5cd82ad0_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-shipping-view"}},[_c('loading',{attrs:{"show":_vm.showLoading}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-space-x-2"},[_c('h1',{staticClass:"asnp-heading-inline"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Shipping Method', 'easy-woocommerce-discounts' ))+"\n\t\t")]),_vm._v(" "),_c('router-link',{staticClass:"asnp-btn asnp-btn-secondary wccs-page-title-action",attrs:{"to":"/shipping-list","tag":"button"}},[_vm._v(_vm._s(_vm.__( 'Cancel', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('button',{staticClass:"asnp-btn asnp-btn-primary wccs-page-title-action",attrs:{"type":"button"},on:{"click":_vm.save}},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Save', 'easy-woocommerce-discounts' ))+"\n\t\t")])],1),_vm._v(" "),(_vm.saleBadgesAdv)?_c('product-labels'):_vm._e(),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.showSave),expression:"showSave"}],attrs:{"type":"danger","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Please save changes.', 'easy-woocommerce-discounts' )}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.saveErrors),expression:"saveErrors"}],attrs:{"type":"danger","title":_vm.__( 'Warning!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There are some errors in the form please fix them and save it again.',
					'easy-woocommerce-discounts'
				),"dismissable":true},on:{"dismiss":function($event){_vm.saveErrors = false}}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(_vm.savedSuccessfully),expression:"savedSuccessfully"}],attrs:{"type":"success","title":_vm.__( 'Success!', 'easy-woocommerce-discounts' ),"message":_vm.__( 'Saved successfully.', 'easy-woocommerce-discounts' ),"dismissable":true},on:{"dismiss":function($event){_vm.savedSuccessfully = false}}})],1),_vm._v(" "),_c('div',{staticClass:"asnp-mt-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Name', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.name),expression:"shipping.name"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
					'wccs-field-error': _vm.$v.shipping.name.$error,
				},attrs:{"type":"text"},domProps:{"value":(_vm.shipping.name)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "name", $event.target.value)},function($event){return _vm.$v.shipping.name.$touch()}]}}),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.shipping.name.required),expression:"! $v.shipping.name.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Private Note', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.private_note),expression:"shipping.private_note"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"text"},domProps:{"value":(_vm.shipping.private_note)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "private_note", $event.target.value)}}})]),_vm._v(" "),_c('div',{staticClass:"asnp-space-y-1"},[_c('label',{staticClass:"asnp-inline-flex asnp-space-x-2 asnp-items-center"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Status', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('toggle',{attrs:{"value":_vm.toBool( _vm.shipping.status )},on:{"input":function($event){return _vm.setToggle( $event, 'status', 1, 0 )}}})],1),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Enable or disable the rule.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Apply Mode', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.apply_mode),expression:"shipping.apply_mode"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.shipping, "apply_mode", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('optgroup',{attrs:{"label":_vm.__( 'Non Exclusive', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__(
							'Apply with other applicable rules',
							'easy-woocommerce-discounts'
						)))])]),_vm._v(" "),_c('optgroup',{attrs:{"label":_vm.__( 'Exclusive', 'easy-woocommerce-discounts' )}},[_c('option',{attrs:{"value":"individually"}},[_vm._v(_vm._s(_vm.__(
							'Apply this rule and disregard other rules',
							'easy-woocommerce-discounts'
						)))]),_vm._v(" "),_c('option',{attrs:{"value":"applicable_not_exists"}},[_vm._v(_vm._s(_vm.__(
							'Apply if other rules are not applicable',
							'easy-woocommerce-discounts'
						)))])])])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Tax Status', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.tax_status),expression:"shipping.tax_status"}],staticClass:"asnp-block asnp-select-field",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(_vm.shipping, "tax_status", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},[_c('option',{attrs:{"value":"taxable"}},[_vm._v(_vm._s(_vm.__( 'Taxable', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"none"}},[_vm._v(_vm._s(_vm.__( 'None', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Cost', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.cost),expression:"shipping.cost"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
					'wccs-field-error': _vm.$v.shipping.cost.$error,
				},attrs:{"type":"number"},domProps:{"value":(_vm.shipping.cost)},on:{"input":[function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "cost", $event.target.value)},function($event){return _vm.$v.shipping.cost.$touch()}]}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__( 'A base shipping cost.', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('label',{directives:[{name:"show",rawName:"v-show",value:(! _vm.$v.shipping.cost.required),expression:"! $v.shipping.cost.required"}],staticClass:"asnp-error-msg asnp-block"},[_vm._v(_vm._s(_vm.__( 'Field is required.', 'easy-woocommerce-discounts' )))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Cost Per Quantity', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.cost_per_quantity),expression:"shipping.cost_per_quantity"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"text"},domProps:{"value":(_vm.shipping.cost_per_quantity)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "cost_per_quantity", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'Cost for each item quantity in the cart.%1$s Use %2$s a for percentage base amount. e.g: %3$s',
							'easy-woocommerce-discounts'
						),
						'<br>',
						'%',
						'20%'
					)
				)}})]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Cost Per Weight', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.cost_per_weight),expression:"shipping.cost_per_weight"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"text"},domProps:{"value":(_vm.shipping.cost_per_weight)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "cost_per_weight", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'Cost for each item weight in the cart.%1$s Use %2$s for a percentage base amount. e.g: %3$s',
							'easy-woocommerce-discounts'
						),
						'<br>',
						'%',
						'20%'
					)
				)}})]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Fee', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.fee),expression:"shipping.fee"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"text"},domProps:{"value":(_vm.shipping.fee)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "fee", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block",domProps:{"innerHTML":_vm._s(
					_vm.sprintf(
						_vm.__(
							'An additional fee.%1$s Use %2$s for a percentage base amount. e.g: %3$s',
							'easy-woocommerce-discounts'
						),
						'<br>',
						'%',
						'20%'
					)
				)}})]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Minimum Fee', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.min_fee),expression:"shipping.min_fee"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"number"},domProps:{"value":(_vm.shipping.min_fee)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "min_fee", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'A minimum fee amount. Useful when using percentage fee.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Maximum Fee', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.max_fee),expression:"shipping.max_fee"}],staticClass:"asnp-block asnp-text-field",attrs:{"type":"number"},domProps:{"value":(_vm.shipping.max_fee)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "max_fee", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'A maximum fee amount. Useful when using percentage fee.',
					'easy-woocommerce-discounts'
				)))])]),_vm._v(" "),_c('label',{staticClass:"asnp-block asnp-space-y-1"},[_c('span',{staticClass:"asnp-field-title"},[_vm._v(_vm._s(_vm.__( 'Usage Limit', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.shipping.usage_limit),expression:"shipping.usage_limit"}],class:{
					'asnp-block': true,
					'asnp-text-field': true,
				},attrs:{"type":"number"},domProps:{"value":(_vm.shipping.usage_limit)},on:{"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.shipping, "usage_limit", $event.target.value)}}}),_vm._v(" "),_c('label',{staticClass:"asnp-block"},[_vm._v(_vm._s(_vm.__(
					'Leave blank for unlimited usage. To set a usage limit for individual users, please refer to the "User usage limit" condition in the conditions list.',
					'easy-woocommerce-discounts'
				)))])])]),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Date Time', 'easy-woocommerce-discounts' ))+"\n\t\t\t"),_c('current-time')],1)]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.shipping.date_time.length),expression:"! shipping.date_time.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any date time.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('date-time-container',{attrs:{"items":_vm.shipping.date_time},on:{"dateTimeUpdated":_vm.onDateTimeItemUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewDateTime,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}}),_vm._v(" "),_c('div',{staticClass:"asnp-my-4 asnp-max-w-lg asnp-grid asnp-grid-cols-1 asnp-gap-6"},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Conditions', 'easy-woocommerce-discounts' ))+"\n\t\t")])]),_vm._v(" "),_c('transition',{attrs:{"name":"alert-fade","mode":"out-in"}},[_c('alert',{directives:[{name:"show",rawName:"v-show",value:(! _vm.shipping.conditions.length),expression:"! shipping.conditions.length"}],attrs:{"type":"info","title":_vm.__( 'Info!', 'easy-woocommerce-discounts' ),"message":_vm.__(
					'There is not any condition.',
					'easy-woocommerce-discounts'
				)}})],1),_vm._v(" "),_c('conditions-container',{attrs:{"items":_vm.shipping.conditions},on:{"conditionUpdated":_vm.onConditionUpdated,"deleteItem":_vm.onDeleteItem,"addItem":_vm.addNewCondition,"addGroup":_vm.onAddGroup,"deleteGroup":_vm.onDeleteGroup}})],1)}
var Shippingvue_type_template_id_5cd82ad0_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Shipping.vue?vue&type=template&id=5cd82ad0&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/Shipping.vue?vue&type=script&lang=js&
function Shippingvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return Shippingvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Shippingvue_type_script_lang_js_typeof(o); }
function Shippingvue_type_script_lang_js_toConsumableArray(r) { return Shippingvue_type_script_lang_js_arrayWithoutHoles(r) || Shippingvue_type_script_lang_js_iterableToArray(r) || Shippingvue_type_script_lang_js_unsupportedIterableToArray(r) || Shippingvue_type_script_lang_js_nonIterableSpread(); }
function Shippingvue_type_script_lang_js_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function Shippingvue_type_script_lang_js_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return Shippingvue_type_script_lang_js_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? Shippingvue_type_script_lang_js_arrayLikeToArray(r, a) : void 0; } }
function Shippingvue_type_script_lang_js_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function Shippingvue_type_script_lang_js_arrayWithoutHoles(r) { if (Array.isArray(r)) return Shippingvue_type_script_lang_js_arrayLikeToArray(r); }
function Shippingvue_type_script_lang_js_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function Shippingvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function Shippingvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? Shippingvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { Shippingvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : Shippingvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function Shippingvue_type_script_lang_js_defineProperty(e, r, t) { return (r = Shippingvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function Shippingvue_type_script_lang_js_toPropertyKey(t) { var i = Shippingvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == Shippingvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function Shippingvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != Shippingvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != Shippingvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ var Shippingvue_type_script_lang_js_ = ({
  name: 'shipping-view',
  components: {
    DateTimeContainer: DateTimeContainer,
    ConditionsContainer: ConditionsContainer
  },
  data: function data() {
    var shipping = {
        name: 'Shipping',
        private_note: '',
        status: 1,
        apply_mode: 'all',
        date_time: [],
        conditions: [],
        tax_status: 'taxable',
        cost: 0,
        cost_per_quantity: 0,
        cost_per_weight: 0,
        fee: 0,
        min_fee: '',
        max_fee: '',
        usage_limit: '',
        ordering: 0
      },
      id = 'new' !== this.$route.params.id ? parseInt(this.$route.params.id) : 0;
    if (id > 0) {
      for (var i = 0, max = this.$store.state.shippingList.length; i < max; i++) {
        if (id == this.$store.state.shippingList[i].id) {
          var item = cloneDeep_default()(this.$store.state.shippingList[i]);
          shipping = Shippingvue_type_script_lang_js_objectSpread(Shippingvue_type_script_lang_js_objectSpread({}, shipping), item);
          break;
        }
      }
    }
    return {
      id: id,
      shipping: shipping,
      ordering: shipping.ordering,
      showSave: false,
      savedSuccessfully: false,
      saveErrors: false,
      showLoading: false,
      hiddenOptions: ['discounted_products', 'recently_viewed_products', 'similar_products_to_customer_cart_products']
    };
  },
  methods: {
    onConditionUpdated: function onConditionUpdated(groupIndex, condition, index) {
      this.shipping.conditions[groupIndex][index] = condition;
    },
    addNewDateTime: function addNewDateTime(index) {
      this.shipping.date_time[index].push(this.initialDateTime());
    },
    onDateTimeItemUpdated: function onDateTimeItemUpdated(groupIndex, dateTime, index) {
      this.shipping.date_time[groupIndex][index] = dateTime;
    },
    onDeleteItem: function onDeleteItem(type, index, groupIndex) {
      var items, group;
      switch (type) {
        case 'dateTime':
          items = Shippingvue_type_script_lang_js_toConsumableArray(this.shipping.date_time);
          group = Shippingvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.shipping.date_time = items;
          break;
        case 'condition':
          items = Shippingvue_type_script_lang_js_toConsumableArray(this.shipping.conditions);
          group = Shippingvue_type_script_lang_js_toConsumableArray(items[groupIndex]);
          group = group.filter(function (item, idx) {
            return idx != index;
          });
          if (!group.length) {
            items = items.filter(function (item, idx) {
              return idx != groupIndex;
            });
          } else {
            items[groupIndex] = group;
          }
          this.shipping.conditions = items;
          break;
      }
    },
    addNewCondition: function addNewCondition(index) {
      this.shipping.conditions[index].push(this.initialCondition());
    },
    onAddGroup: function onAddGroup(type) {
      switch (type) {
        case 'condition':
          this.shipping.conditions = [].concat(Shippingvue_type_script_lang_js_toConsumableArray(this.shipping.conditions), [[this.initialCondition()]]);
          break;
        case 'dateTime':
          this.shipping.date_time = [].concat(Shippingvue_type_script_lang_js_toConsumableArray(this.shipping.date_time), [[this.initialDateTime()]]);
          break;
      }
    },
    onDeleteGroup: function onDeleteGroup(index, type) {
      var items;
      switch (type) {
        case 'condition':
          items = Shippingvue_type_script_lang_js_toConsumableArray(this.shipping.conditions);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.shipping.conditions = items;
          break;
        case 'dateTime':
          items = Shippingvue_type_script_lang_js_toConsumableArray(this.shipping.date_time);
          items = items.filter(function (item, idx) {
            return idx != index;
          });
          this.shipping.date_time = items;
          break;
      }
    },
    setToggle: function setToggle(value, prop) {
      var trueValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var falseValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      this.shipping = Object.assign({}, this.shipping, Shippingvue_type_script_lang_js_defineProperty({}, prop, value ? trueValue : falseValue));
    },
    checkErrors: function checkErrors() {
      if (!this.shipping.name.trim().length) {
        return this.saveErrors = true;
      } else if (isNaN(this.shipping.cost * 1) || 0 > parseFloat(this.shipping.cost)) {
        return this.saveErrors = true;
      }
      return this.saveErrors = false;
    },
    save: function save() {
      var _this = this;
      if (this.checkErrors()) {
        return;
      }
      this.showLoading = true;
      this.savedSuccessfully = false;
      condition_save({
        type: SHIPPING_TYPE,
        id: this.id,
        date_time: this.shipping.date_time,
        conditions: this.shipping.conditions,
        name: this.shipping.name,
        private_note: this.shipping.private_note,
        status: this.shipping.status,
        apply_mode: this.shipping.apply_mode,
        tax_status: this.shipping.tax_status,
        cost: this.shipping.cost * 1,
        cost_per_quantity: this.shipping.cost_per_quantity,
        cost_per_weight: this.shipping.cost_per_weight,
        fee: this.shipping.fee,
        min_fee: this.shipping.min_fee,
        max_fee: this.shipping.max_fee,
        usage_limit: this.shipping.usage_limit,
        ordering: this.ordering
      }).then(function (response) {
        if (1 == response.success) {
          if (!_this.id) {
            _this.ordering = parseInt(response.condition.ordering);
            _this.id = parseInt(response.condition.id);
          }
          _this.$store.commit('ADD_SHIPPING', response.condition);
          _this.showSave = false;
          _this.savedSuccessfully = true;
        }
        _this.showLoading = false;
      })["catch"](function (error) {
        _this.showLoading = false;
        console.log(error);
      });
    }
  },
  watch: {
    shipping: {
      handler: function handler(value) {
        if (this.id > 0) {
          this.showSave = true;
        }
      },
      deep: true
    }
  },
  validations: {
    shipping: {
      name: {
        required: required_default.a
      },
      cost: {
        required: required_default.a
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Shipping.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_Shippingvue_type_script_lang_js_ = (Shippingvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Shipping.vue





/* normalize component */

var Shipping_component = Object(componentNormalizer["a" /* default */])(
  views_Shippingvue_type_script_lang_js_,
  Shippingvue_type_template_id_5cd82ad0_render,
  Shippingvue_type_template_id_5cd82ad0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Shipping = (Shipping_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/Addons.vue?vue&type=template&id=561dc0c2&
var Addonsvue_type_template_id_561dc0c2_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"wrap",attrs:{"id":"ewd-addons"}},[_c('loading',{attrs:{"show":_vm.isLoading}}),_vm._v(" "),_vm._l((_vm.items),function(item,index){return _c('div',{key:index},[_c('h3',{staticClass:"asnp-text-gray-700 asnp-text-lg asnp-font-semibold"},[_vm._v("\n\t\t\t"+_vm._s(item.title)+"\n\t\t")]),_vm._v(" "),_c('div',{staticClass:"asnp-grid asnp-grid-cols-1 md:asnp-grid-cols-2 xl:asnp-grid-cols-3 asnp-gap-4"},_vm._l((item.items),function(addon){return _c('addon',{key:addon.id,attrs:{"addon":addon}})}),1)])})],2)}
var Addonsvue_type_template_id_561dc0c2_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Addons.vue?vue&type=template&id=561dc0c2&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Addon.vue?vue&type=template&id=bad6cf98&
var Addonvue_type_template_id_bad6cf98_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-max-w-md asnp-bg-white asnp-shadow-lg hover:asnp-shadow-xl asnp-rounded-lg asnp-my-5"},[_c('div',{staticClass:"asnp-py-4 asnp-px-8"},[_c('div',{staticStyle:{"min-height":"180px"}},[_c('a',{staticClass:"asnp-text-gray-700 hover:asnp-text-indigo-700 asnp-text-2xl asnp-font-semibold",attrs:{"href":_vm.addon.url,"target":"_blank"}},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.addon.name)+"\n\t\t\t")]),_vm._v(" "),_c('div',{staticClass:"asnp-mt-2 asnp-font-semibold asnp-text-xl asnp-text-green-500",domProps:{"innerHTML":_vm._s(_vm.price)}}),_vm._v(" "),_c('p',{staticClass:"asnp-mt-2 asnp-text-gray-600"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.addon.desc)+"\n\t\t\t")])]),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-justify-end asnp-mt-4 asnp-uppercase"},[_c('a',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"href":_vm.addon.url,"target":"_blank"}},[_vm._v(_vm._s(_vm.__( 'Buy Now', 'easy-woocommerce-discounts' )))])])])])}
var Addonvue_type_template_id_bad6cf98_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Addon.vue?vue&type=template&id=bad6cf98&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Addon.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Addonvue_type_script_lang_js_ = ({
  name: 'Addon',
  props: {
    addon: {
      type: Object
    }
  },
  computed: {
    price: function price() {
      return '<span><del>$' + this.addon.price + '</del> $' + this.addon.sale_price + '</span>';
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Addon.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Addonvue_type_script_lang_js_ = (Addonvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Addon.vue





/* normalize component */

var Addon_component = Object(componentNormalizer["a" /* default */])(
  components_Addonvue_type_script_lang_js_,
  Addonvue_type_template_id_bad6cf98_render,
  Addonvue_type_template_id_bad6cf98_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Addon = (Addon_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/Addons.vue?vue&type=script&lang=js&
function Addonsvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return Addonsvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Addonsvue_type_script_lang_js_typeof(o); }
function Addonsvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function Addonsvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? Addonsvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { Addonsvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : Addonsvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function Addonsvue_type_script_lang_js_defineProperty(e, r, t) { return (r = Addonsvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function Addonsvue_type_script_lang_js_toPropertyKey(t) { var i = Addonsvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == Addonsvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function Addonsvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != Addonsvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != Addonsvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var Addonsvue_type_script_lang_js_ = ({
  name: 'addons',
  components: {
    Addon: Addon
  },
  mounted: function mounted() {
    this.fetchItems();
  },
  computed: Addonsvue_type_script_lang_js_objectSpread({}, Object(external_Vuex_["mapState"])({
    items: function items(state) {
      return state.addons.items;
    },
    isLoading: function isLoading(state) {
      return state.addons.isFetching;
    }
  })),
  methods: {
    fetchItems: function fetchItems() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.$store.dispatch('addons/fetchItemsIfNeeded', args);
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Addons.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_Addonsvue_type_script_lang_js_ = (Addonsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Addons.vue





/* normalize component */

var Addons_component = Object(componentNormalizer["a" /* default */])(
  views_Addonsvue_type_script_lang_js_,
  Addonsvue_type_template_id_561dc0c2_render,
  Addonsvue_type_template_id_561dc0c2_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Addons = (Addons_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/Analytics.vue?vue&type=template&id=3da28b20&
var Analyticsvue_type_template_id_3da28b20_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-min-h-screen asnp-bg-gradient-to-br asnp-from-gray-50 asnp-to-gray-100",attrs:{"id":"wccs-analytics"}},[_c('div',{staticClass:"asnp-mx-auto asnp-px-4 asnp-pb-8"},[_c('div',{staticClass:"asnp-mb-8"},[_c('h1',{staticClass:"asnp-text-3xl asnp-font-bold asnp-text-gray-600 asnp-mb-2"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Analytics Dashboard',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-text-gray-600"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Comprehensive overview of the rules performance',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]),_vm._v(" "),_c('div',{staticClass:"asnp-radio-group asnp-mb-6"},[_c('div',{staticClass:"asnp-flex asnp-gap-3 asnp-flex-wrap asnp-items-center"},[_vm._l((_vm.rangeOptions),function(option){return _c('label',{key:option.value,staticClass:"asnp-relative asnp-flex asnp-items-center asnp-bg-gray-50 asnp-cursor-pointer asnp-p-4 asnp-rounded-xl asnp-border-2 asnp-transition",class:{
						'asnp-border-blue-600 asnp-bg-blue-50 asnp-shadow-md':
							_vm.range === option.value,
						'asnp-border-gray-200 hover:asnp-border-gray-300 hover:asnp-bg-gray-50':
							_vm.range !== option.value,
					}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.range),expression:"range"}],staticClass:"asnp-sr-only",attrs:{"type":"radio","name":"dateRange"},domProps:{"value":option.value,"checked":_vm._q(_vm.range,option.value)},on:{"change":function($event){_vm.range=option.value}}}),_vm._v(" "),_c('div',{staticClass:"asnp-flex-shrink-0 asnp-w-5 asnp-h-5 asnp-rounded-full asnp-border-2 asnp-mr-3 asnp-flex asnp-items-center asnp-justify-center",class:_vm.range === option.value
								? 'asnp-border-blue-600 asnp-bg-blue-600'
								: 'asnp-border-gray-300'},[(_vm.range === option.value)?_c('div',{staticClass:"asnp-w-2.5 asnp-h-2.5 asnp-rounded-full asnp-bg-white"}):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"asnp-flex-1 asnp-min-w-0"},[_c('span',{staticClass:"asnp-font-medium",class:_vm.range === option.value
									? 'asnp-text-blue-900'
									: 'asnp-text-gray-900'},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(option.label)+"\n\t\t\t\t\t\t")])])])}),_vm._v(" "),_c('date-picker',{directives:[{name:"show",rawName:"v-show",value:(_vm.range === 'custom'),expression:"range === 'custom'"}],attrs:{"date":_vm.customRange.start,"option":_vm.getDateOption( {
							placeholder: _vm.__(
								'Start Date',
								'easy-woocommerce-discounts'
							),
							disabled: _vm.loading,
						} )},model:{value:(_vm.customRange.start),callback:function ($$v) {_vm.$set(_vm.customRange, "start", $$v)},expression:"customRange.start"}}),_vm._v(" "),_c('date-picker',{directives:[{name:"show",rawName:"v-show",value:(_vm.range === 'custom'),expression:"range === 'custom'"}],attrs:{"date":_vm.customRange.end,"option":_vm.getDateOption( {
							placeholder: _vm.__(
								'End Date',
								'easy-woocommerce-discounts'
							),
							disabled: _vm.loading,
						} )},model:{value:(_vm.customRange.end),callback:function ($$v) {_vm.$set(_vm.customRange, "end", $$v)},expression:"customRange.end"}})],2)]),_vm._v(" "),_c('div',{staticClass:"asnp-mb-6"},[_c('label',{staticClass:"asnp-block asnp-text-sm asnp-font-medium asnp-text-gray-700 asnp-mb-2"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'Filter by Rule', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('select2',{attrs:{"is-ajax":true,"className":"asnp-analytics-search-rules","ajax-type":"rules","multiple":false,"minimum-input-length":2,"allowClear":true,"disabled":_vm.loading,"placeholder":_vm.__( 'Search...', 'easy-woocommerce-discounts' )},model:{value:(_vm.rule),callback:function ($$v) {_vm.rule=$$v},expression:"rule"}})],1),_vm._v(" "),_c('div',{staticClass:"asnp-grid asnp-grid-cols-1 md:asnp-grid-cols-2 lg:asnp-grid-cols-4 asnp-gap-6 asnp-mb-8"},[(_vm.loading)?_vm._l((8),function(n){return _c('div',{key:n,staticClass:"asnp-h-28 asnp-bg-white asnp-border-0 asnp-shadow-lg asnp-rounded-2xl asnp-animate-pulse"},[_vm._m(0,true)])}):_vm._l((_vm.metrics),function(metric,index){return _c('MetricCard',_vm._b({key:index},'MetricCard',metric,false))})],2),_vm._v(" "),_c('div',{staticClass:"asnp-mb-8"},[(_vm.loading)?[_vm._m(1)]:[_c('RevenueChart',{attrs:{"chartData":_vm.chartData}})]],2),_vm._v(" "),_c('CampaignTable',{attrs:{"range":_vm.range,"customRange":_vm.customRange}})],1)])}
var Analyticsvue_type_template_id_3da28b20_staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-p-4 asnp-flex asnp-justify-between asnp-items-center"},[_c('div',[_c('div',{staticClass:"asnp-h-5 asnp-w-32 asnp-bg-gray-200 asnp-rounded-md asnp-mb-2 asnp-animate-pulse"}),_vm._v(" "),_c('div',{staticClass:"asnp-h-6 asnp-w-20 asnp-bg-gray-200 asnp-rounded-md asnp-animate-pulse asnp-mt-6"})])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-border-0 asnp-shadow-lg asnp-rounded-2xl asnp-bg-white"},[_c('div',{staticClass:"asnp-p-4 asnp-flex asnp-justify-between asnp-items-center"},[_c('div',[_c('div',{staticClass:"asnp-h-6 asnp-w-40 asnp-bg-gray-200 asnp-rounded-md asnp-mb-2 asnp-animate-pulse"}),_vm._v(" "),_c('div',{staticClass:"asnp-h-4 asnp-w-56 asnp-bg-gray-200 asnp-rounded-md asnp-animate-pulse"})]),_vm._v(" "),_c('div',{staticClass:"asnp-h-8 asnp-w-28 asnp-bg-gray-200 asnp-rounded-md asnp-animate-pulse"})]),_vm._v(" "),_c('div',{staticClass:"asnp-p-4"},[_c('div',{staticClass:"asnp-h-96 asnp-bg-gray-100 asnp-rounded-lg asnp-animate-pulse"})])])}]


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Analytics.vue?vue&type=template&id=3da28b20&

// EXTERNAL MODULE: external {"this":["wp","apiFetch"]}
var external_this_wp_apiFetch_ = __webpack_require__(11);
var external_this_wp_apiFetch_default = /*#__PURE__*/__webpack_require__.n(external_this_wp_apiFetch_);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/api/analytics.js
function analytics_regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return analytics_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (analytics_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, analytics_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, analytics_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), analytics_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", analytics_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), analytics_regeneratorDefine2(u), analytics_regeneratorDefine2(u, o, "Generator"), analytics_regeneratorDefine2(u, n, function () { return this; }), analytics_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (analytics_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function analytics_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } analytics_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { analytics_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, analytics_regeneratorDefine2(e, r, n, t); }
function analytics_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function analytics_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { analytics_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { analytics_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }


var API_ROOT = 'easy-woocommerce-discounts/v1';
var analytics_getTotals = /*#__PURE__*/function () {
  var _ref = analytics_asyncToGenerator(/*#__PURE__*/analytics_regenerator().m(function _callee(data) {
    var query, response, _t;
    return analytics_regenerator().w(function (_context) {
      while (1) switch (_context.p = _context.n) {
        case 0:
          _context.p = 0;
          if (!(!(data !== null && data !== void 0 && data.start_date) && !(data !== null && data !== void 0 && data.end_date))) {
            _context.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Start or end dates are required.', 'easy-woocommerce-discounts'));
        case 1:
          query = '?';
          if (data !== null && data !== void 0 && data.start_date) {
            query += "start_date=".concat(data.start_date, "&");
          }
          if (data !== null && data !== void 0 && data.end_date) {
            query += "end_date=".concat(data.end_date, "&");
          }
          if (data !== null && data !== void 0 && data.rule_id) {
            query += "rule_id=".concat(parseInt(data.rule_id), "&");
          }
          if (data !== null && data !== void 0 && data.range) {
            query += "range=".concat(data.range, "&");
          }
          _context.n = 2;
          return external_this_wp_apiFetch_default()({
            path: "".concat(API_ROOT, "/analytics").concat(query)
          });
        case 2:
          response = _context.v;
          if (!response) {
            _context.n = 3;
            break;
          }
          return _context.a(2, response);
        case 3:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on getting analytics totals.', 'easy-woocommerce-discounts'));
        case 4:
          _context.p = 4;
          _t = _context.v;
          throw _t;
        case 5:
          return _context.a(2);
      }
    }, _callee, null, [[0, 4]]);
  }));
  return function getTotals(_x) {
    return _ref.apply(this, arguments);
  };
}();
var analytics_getChartData = /*#__PURE__*/function () {
  var _ref2 = analytics_asyncToGenerator(/*#__PURE__*/analytics_regenerator().m(function _callee2(data) {
    var query, response, _t2;
    return analytics_regenerator().w(function (_context2) {
      while (1) switch (_context2.p = _context2.n) {
        case 0:
          _context2.p = 0;
          if (!(!(data !== null && data !== void 0 && data.start_date) && !(data !== null && data !== void 0 && data.end_date))) {
            _context2.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Start or end dates are required.', 'easy-woocommerce-discounts'));
        case 1:
          query = '?';
          if (data !== null && data !== void 0 && data.start_date) {
            query += "start_date=".concat(data.start_date, "&");
          }
          if (data !== null && data !== void 0 && data.end_date) {
            query += "end_date=".concat(data.end_date, "&");
          }
          if (data !== null && data !== void 0 && data.rule_id) {
            query += "rule_id=".concat(parseInt(data.rule_id), "&");
          }
          if (data !== null && data !== void 0 && data.range) {
            query += "range=".concat(data.range, "&");
          }
          _context2.n = 2;
          return external_this_wp_apiFetch_default()({
            path: "".concat(API_ROOT, "/analytics/chart").concat(query)
          });
        case 2:
          response = _context2.v;
          if (!response) {
            _context2.n = 3;
            break;
          }
          return _context2.a(2, response);
        case 3:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on getting analytics chart data.', 'easy-woocommerce-discounts'));
        case 4:
          _context2.p = 4;
          _t2 = _context2.v;
          throw _t2;
        case 5:
          return _context2.a(2);
      }
    }, _callee2, null, [[0, 4]]);
  }));
  return function getChartData(_x2) {
    return _ref2.apply(this, arguments);
  };
}();
var getBestPerforming = /*#__PURE__*/function () {
  var _ref3 = analytics_asyncToGenerator(/*#__PURE__*/analytics_regenerator().m(function _callee3(data) {
    var query, response, _t3;
    return analytics_regenerator().w(function (_context3) {
      while (1) switch (_context3.p = _context3.n) {
        case 0:
          _context3.p = 0;
          if (!(!(data !== null && data !== void 0 && data.start_date) && !(data !== null && data !== void 0 && data.end_date))) {
            _context3.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Start or end dates are required.', 'easy-woocommerce-discounts'));
        case 1:
          query = '?';
          if (data !== null && data !== void 0 && data.start_date) {
            query += "start_date=".concat(data.start_date, "&");
          }
          if (data !== null && data !== void 0 && data.end_date) {
            query += "end_date=".concat(data.end_date, "&");
          }
          if (data !== null && data !== void 0 && data.page && !isNaN(data.page * 1) && 0 < data.page * 1) {
            query += "page=".concat(parseInt(data.page), "&");
          }
          if (data !== null && data !== void 0 && data.per_page && !isNaN(data.per_page * 1) && 0 < data.per_page * 1) {
            query += "per_page=".concat(parseInt(data.per_page), "&");
          }
          if (data !== null && data !== void 0 && data.range) {
            query += "range=".concat(data.range, "&");
          }
          _context3.n = 2;
          return external_this_wp_apiFetch_default()({
            path: "".concat(API_ROOT, "/analytics/best-performing").concat(query)
          });
        case 2:
          response = _context3.v;
          if (!response) {
            _context3.n = 3;
            break;
          }
          return _context3.a(2, response);
        case 3:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on getting best performing rules.', 'easy-woocommerce-discounts'));
        case 4:
          _context3.p = 4;
          _t3 = _context3.v;
          throw _t3;
        case 5:
          return _context3.a(2);
      }
    }, _callee3, null, [[0, 4]]);
  }));
  return function getBestPerforming(_x3) {
    return _ref3.apply(this, arguments);
  };
}();
var searchRules = /*#__PURE__*/function () {
  var _ref4 = analytics_asyncToGenerator(/*#__PURE__*/analytics_regenerator().m(function _callee4(data) {
    var query, response, _t4;
    return analytics_regenerator().w(function (_context4) {
      while (1) switch (_context4.p = _context4.n) {
        case 0:
          _context4.p = 0;
          if (!(!(data !== null && data !== void 0 && data.search) || '' === (data === null || data === void 0 ? void 0 : data.search.trim()))) {
            _context4.n = 1;
            break;
          }
          throw new Error(Object(external_this_wp_i18n_["__"])('Please provide a search query.', 'easy-woocommerce-discounts'));
        case 1:
          query = "?search=".concat(data.search, "&");
          if (data !== null && data !== void 0 && data.per_page && !isNaN(data.per_page * 1) && 0 < data.per_page * 1) {
            query += "per_page=".concat(parseInt(data.per_page), "&");
          }
          _context4.n = 2;
          return external_this_wp_apiFetch_default()({
            path: "".concat(API_ROOT, "/analytics/search").concat(query)
          });
        case 2:
          response = _context4.v;
          if (!response) {
            _context4.n = 3;
            break;
          }
          return _context4.a(2, response);
        case 3:
          throw new Error(Object(external_this_wp_i18n_["__"])('There was an error on getting rules.', 'easy-woocommerce-discounts'));
        case 4:
          _context4.p = 4;
          _t4 = _context4.v;
          throw _t4;
        case 5:
          return _context4.a(2);
      }
    }, _callee4, null, [[0, 4]]);
  }));
  return function searchRules(_x4) {
    return _ref4.apply(this, arguments);
  };
}();
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/MetricCard.vue?vue&type=template&id=58aabc1e&
var MetricCardvue_type_template_id_58aabc1e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-relative asnp-overflow-hidden asnp-border-0 asnp-shadow-lg hover:asnp-shadow-xl asnp-transition-all asnp-duration-300 asnp-rounded-2xl asnp-bg-white"},[_c('div',{staticClass:"asnp-absolute asnp-inset-0 asnp-opacity-5 asnp-pointer-events-none",class:_vm.cardGradient}),_vm._v(" "),_c('div',{staticClass:"asnp-p-4 asnp-pb-3"},[_c('div',{staticClass:"asnp-flex asnp-items-center asnp-justify-between"},[_c('p',{staticClass:"asnp-text-sm asnp-font-medium asnp-text-gray-600"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.title)+"\n\t\t\t\t"),(_vm.description)?_c('span',{directives:[{name:"tip",rawName:"v-tip",value:(_vm.description),expression:"description"}],staticClass:"woocommerce-help-tip"}):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"asnp-p-2 asnp-rounded-lg asnp-bg-opacity-80",class:_vm.gradient},[(_vm.icon)?_c('span',{staticClass:"asnp-h-4 asnp-w-4",domProps:{"innerHTML":_vm._s(_vm.icon)}}):_vm._e()])])]),_vm._v(" "),_c('div',{staticClass:"asnp-p-4 asnp-pt-0"},[_c('div',{staticClass:"asnp-space-y-2"},[(_vm.isHtml)?_c('p',{staticClass:"asnp-text-2xl asnp-font-bold asnp-text-gray-900",domProps:{"innerHTML":_vm._s(_vm.value)}}):_c('p',{staticClass:"asnp-text-2xl asnp-font-bold asnp-text-gray-900"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.formattedValue)+"\n\t\t\t")]),_vm._v(" "),(_vm.change)?_c('div',{staticClass:"asnp-flex asnp-items-center asnp-space-x-1"},[(_vm.isPositive)?_c('svg',{staticClass:"asnp-h-3 asnp-w-3 asnp-text-green-500",attrs:{"fill":"none","stroke":"currentColor","viewBox":"0 0 24 24"}},[_c('path',{attrs:{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2","d":"M5 10l7-7 7 7M12 3v18"}})]):_c('svg',{staticClass:"asnp-h-3 asnp-w-3 asnp-text-red-500",attrs:{"fill":"none","stroke":"currentColor","viewBox":"0 0 24 24"}},[_c('path',{attrs:{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2","d":"M19 14l-7 7-7-7M12 21V3"}})]),_vm._v(" "),_c('span',{staticClass:"asnp-text-xs asnp-font-medium",class:_vm.isPositive
							? 'asnp-text-emerald-600'
							: 'asnp-text-red-500'},[_vm._v("\n\t\t\t\t\t"+_vm._s(_vm.change)+"% "+_vm._s(_vm.message)+"\n\t\t\t\t")])]):_vm._e()])])])}
var MetricCardvue_type_template_id_58aabc1e_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/MetricCard.vue?vue&type=template&id=58aabc1e&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/MetricCard.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var MetricCardvue_type_script_lang_js_ = ({
  name: 'MetricCard',
  props: {
    title: String,
    message: String,
    description: String,
    value: [String, Number],
    change: Number,
    changeType: {
      type: String,
      "default": 'positive'
    },
    gradient: {
      type: String,
      "default": 'asnp-bg-white'
    },
    icon: {
      type: String,
      "default": ''
    },
    isPercentage: Boolean
  },
  computed: {
    isPositive: function isPositive() {
      return this.changeType === 'positive';
    },
    cardGradient: function cardGradient() {
      if (this.change === 0) return 'asnp-bg-white';
      if (this.changeType === 'positive') {
        return 'asnp-bg-gradient-to-r asnp-from-green-400 asnp-to-green-700';
      } else if (this.changeType === 'negative') {
        return 'asnp-bg-gradient-to-r asnp-from-red-200 asnp-to-red-400';
      }
      return 'asnp-bg-white';
    },
    isHtml: function isHtml() {
      return typeof this.value === 'string' && /<[^>]+>/.test(this.value);
    },
    formattedValue: function formattedValue() {
      if (this.isHtml) {
        return this.value;
      }
      var num = Number(this.value) || 0;
      if (this.isPercentage) {
        return num.toFixed(2) + '%';
      }
      var formatWithSuffix = function formatWithSuffix(n) {
        if (n === 0) {
          return '0';
        }
        var abs = Math.abs(n);
        if (abs >= 1000000000000) return (n / 1000000000000).toFixed(1).replace(/\.0$/, '') + 'T';
        if (abs >= 1000000000) return (n / 1000000000).toFixed(1).replace(/\.0$/, '') + 'B';
        if (abs >= 1000000) return (n / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
        if (abs >= 1000) return (n / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
        return n.toLocaleString();
      };
      return formatWithSuffix(num);
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/MetricCard.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_MetricCardvue_type_script_lang_js_ = (MetricCardvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/MetricCard.vue





/* normalize component */

var MetricCard_component = Object(componentNormalizer["a" /* default */])(
  components_MetricCardvue_type_script_lang_js_,
  MetricCardvue_type_template_id_58aabc1e_render,
  MetricCardvue_type_template_id_58aabc1e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var MetricCard = (MetricCard_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/RevenueChart.vue?vue&type=template&id=18655a58&
var RevenueChartvue_type_template_id_18655a58_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-border-0 asnp-shadow-lg asnp-rounded-2xl asnp-bg-white"},[_c('div',{staticClass:"asnp-p-4 asnp-flex asnp-justify-between asnp-items-center"},[_c('div',[_c('h2',{staticClass:"asnp-text-xl asnp-font-semibold asnp-text-gray-900"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__( 'Analytics Trend', 'easy-woocommerce-discounts' ))+"\n\t\t\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-text-sm asnp-text-gray-600"},[_vm._v("\n\t\t\t\t"+_vm._s(_vm.__(
						'Select metric to visualize',
						'easy-woocommerce-discounts'
					))+"\n\t\t\t")])]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.selectedMetric),expression:"selectedMetric"}],staticClass:"asnp-border asnp-rounded p-1",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.selectedMetric=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},[_c('option',{attrs:{"value":"discounts"}},[_vm._v(_vm._s(_vm.__( 'Discounts', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"revenue"}},[_vm._v(_vm._s(_vm.__( 'Revenue', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"orders"}},[_vm._v(_vm._s(_vm.__( 'Orders', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"impressions"}},[_vm._v(_vm._s(_vm.__( 'Impressions', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"conversion_rate"}},[_vm._v(_vm._s(_vm.__( 'Conversion Rate', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"rejections"}},[_vm._v(_vm._s(_vm.__( 'Rejections', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('option',{attrs:{"value":"all"}},[_vm._v(_vm._s(_vm.__( 'All Metrics', 'easy-woocommerce-discounts' )))])])]),_vm._v(" "),_c('div',{staticClass:"asnp-p-4"},[_c('canvas',{ref:"chartCanvas",attrs:{"height":"400"}})])])}
var RevenueChartvue_type_template_id_18655a58_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/RevenueChart.vue?vue&type=template&id=18655a58&

// CONCATENATED MODULE: ./node_modules/chart.js/dist/chunks/helpers.segment.mjs
/*!
 * Chart.js v3.9.0
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
function noop() {}
const uid = (function() {
  let id = 0;
  return function() {
    return id++;
  };
}());
function isNullOrUndef(value) {
  return value === null || typeof value === 'undefined';
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100
    : value / dimension;
const toDimension = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100 * dimension
    : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === 'function') {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {merger: _mergerIf});
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
function _deprecated(scope, value, previous, current) {
  if (value !== undefined) {
    console.warn(scope + ': "' + previous +
			'" is deprecated. Please use "' + current + '" instead');
  }
}
const keyResolvers = {
  '': v => v,
  x: o => o.x,
  y: o => o.y
};
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return obj => {
    for (const k of keys) {
      if (k === '') {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function _splitKey(key) {
  const parts = key.split('.');
  const keys = [];
  let tmp = '';
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith('\\')) {
      tmp = tmp.slice(0, -1) + '.';
    } else {
      keys.push(tmp);
      tmp = '';
    }
  }
  return keys;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== 'undefined';
const isFunction = (value) => typeof value === 'function';
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < (-0.5 * PI)) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || (sameAngleIsFullCircle && s === e)
    || (angleToStart > angleToEnd && startToAngle < endToAngle);
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = (lo + hi) >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {lo, hi};
}
const _lookupByKey = (table, key, value, last) =>
  _lookup(table, value, last
    ? index => table[index][key] <= value
    : index => table[index][key] < value);
const _rlookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length
    ? values.slice(start, end)
    : values;
}
const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, '_chartjs', {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = '_onData' + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === 'function') {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set.add(items[i]);
  }
  if (set.size === ilen) {
    return items;
  }
  return Array.from(set);
}

function helpers_segment_fontString(pixelSize, fontStyle, fontFamily) {
  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
const requestAnimFrame = (function() {
  if (typeof window === 'undefined') {
    return function(callback) {
      return callback();
    };
  }
  return window.requestAnimationFrame;
}());
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? 'left' : 'right';
  return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const {iScale, _parsed} = meta;
    const axis = iScale.axis;
    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        _lookupByKey(_parsed, iScale.axis, min).lo,
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),
      0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),
      start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {start, count};
}
function _scaleRangesChanged(meta) {
  const {xScale, yScale, _scaleRanges} = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min
		|| _scaleRanges.xmax !== xScale.max
		|| _scaleRanges.ymin !== yScale.min
		|| _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}

const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => -t * (t - 2),
  easeInOutQuad: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t
    : -0.5 * ((--t) * (t - 2) - 1),
  easeInCubic: t => t * t * t,
  easeOutCubic: t => (t -= 1) * t * t + 1,
  easeInOutCubic: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t
    : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t
    : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t * t
    : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: t => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: t => Math.sin(t * HALF_PI),
  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => atEdge(t) ? t : t < 0.5
    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: t => ((t /= 0.5) < 1)
    ? -0.5 * (Math.sqrt(1 - t * t) - 1)
    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t :
      t < 0.5
        ? 0.5 * elasticIn(t * 2, s, p)
        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
  },
  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < (1 / d)) {
      return m * t * t;
    }
    if (t < (2 / d)) {
      return m * (t -= (1.5 / d)) * t + 0.75;
    }
    if (t < (2.5 / d)) {
      return m * (t -= (2.25 / d)) * t + 0.9375;
    }
    return m * (t -= (2.625 / d)) * t + 0.984375;
  },
  easeInOutBounce: t => (t < 0.5)
    ? effects.easeInBounce(t * 2) * 0.5
    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
};

/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
function helpers_segment_round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(helpers_segment_round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(helpers_segment_round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(helpers_segment_round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(helpers_segment_round(v * 100), 0, 100);
}
const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = [...'0123456789ABCDEF'];
const h1 = b => hex[b & 0xF];
const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === '#') {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
      };
    }
  }
  return ret;
}
const helpers_segment_alpha = (a, f) => a < 255 ? f(a) : '';
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v
    ? '#' + f(v.r) + f(v.g) + f(v.b) + helpers_segment_alpha(v.a, f)
    : undefined;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return ((g - b) / d) + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (
    Array.isArray(a)
      ? f(a[0], a[1], a[2])
      : f(a, b, c)
  ).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === 'hwb') {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === 'hsv') {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255
    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
    : `hsl(${h}, ${s}%, ${l}%)`;
}
const map = {
  x: 'dark',
  Z: 'light',
  Y: 're',
  X: 'blu',
  W: 'gr',
  V: 'medium',
  U: 'slate',
  A: 'ee',
  T: 'ol',
  S: 'or',
  B: 'ra',
  C: 'lateg',
  D: 'ights',
  R: 'in',
  Q: 'turquois',
  E: 'hi',
  P: 'ro',
  O: 'al',
  N: 'le',
  M: 'de',
  L: 'yello',
  F: 'en',
  K: 'ch',
  G: 'arks',
  H: 'ea',
  I: 'ightg',
  J: 'wh'
};
const names$1 = {
  OiceXe: 'f0f8ff',
  antiquewEte: 'faebd7',
  aqua: 'ffff',
  aquamarRe: '7fffd4',
  azuY: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '0',
  blanKedOmond: 'ffebcd',
  Xe: 'ff',
  XeviTet: '8a2be2',
  bPwn: 'a52a2a',
  burlywood: 'deb887',
  caMtXe: '5f9ea0',
  KartYuse: '7fff00',
  KocTate: 'd2691e',
  cSO: 'ff7f50',
  cSnflowerXe: '6495ed',
  cSnsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: 'ffff',
  xXe: '8b',
  xcyan: '8b8b',
  xgTMnPd: 'b8860b',
  xWay: 'a9a9a9',
  xgYF: '6400',
  xgYy: 'a9a9a9',
  xkhaki: 'bdb76b',
  xmagFta: '8b008b',
  xTivegYF: '556b2f',
  xSange: 'ff8c00',
  xScEd: '9932cc',
  xYd: '8b0000',
  xsOmon: 'e9967a',
  xsHgYF: '8fbc8f',
  xUXe: '483d8b',
  xUWay: '2f4f4f',
  xUgYy: '2f4f4f',
  xQe: 'ced1',
  xviTet: '9400d3',
  dAppRk: 'ff1493',
  dApskyXe: 'bfff',
  dimWay: '696969',
  dimgYy: '696969',
  dodgerXe: '1e90ff',
  fiYbrick: 'b22222',
  flSOwEte: 'fffaf0',
  foYstWAn: '228b22',
  fuKsia: 'ff00ff',
  gaRsbSo: 'dcdcdc',
  ghostwEte: 'f8f8ff',
  gTd: 'ffd700',
  gTMnPd: 'daa520',
  Way: '808080',
  gYF: '8000',
  gYFLw: 'adff2f',
  gYy: '808080',
  honeyMw: 'f0fff0',
  hotpRk: 'ff69b4',
  RdianYd: 'cd5c5c',
  Rdigo: '4b0082',
  ivSy: 'fffff0',
  khaki: 'f0e68c',
  lavFMr: 'e6e6fa',
  lavFMrXsh: 'fff0f5',
  lawngYF: '7cfc00',
  NmoncEffon: 'fffacd',
  ZXe: 'add8e6',
  ZcSO: 'f08080',
  Zcyan: 'e0ffff',
  ZgTMnPdLw: 'fafad2',
  ZWay: 'd3d3d3',
  ZgYF: '90ee90',
  ZgYy: 'd3d3d3',
  ZpRk: 'ffb6c1',
  ZsOmon: 'ffa07a',
  ZsHgYF: '20b2aa',
  ZskyXe: '87cefa',
  ZUWay: '778899',
  ZUgYy: '778899',
  ZstAlXe: 'b0c4de',
  ZLw: 'ffffe0',
  lime: 'ff00',
  limegYF: '32cd32',
  lRF: 'faf0e6',
  magFta: 'ff00ff',
  maPon: '800000',
  VaquamarRe: '66cdaa',
  VXe: 'cd',
  VScEd: 'ba55d3',
  VpurpN: '9370db',
  VsHgYF: '3cb371',
  VUXe: '7b68ee',
  VsprRggYF: 'fa9a',
  VQe: '48d1cc',
  VviTetYd: 'c71585',
  midnightXe: '191970',
  mRtcYam: 'f5fffa',
  mistyPse: 'ffe4e1',
  moccasR: 'ffe4b5',
  navajowEte: 'ffdead',
  navy: '80',
  Tdlace: 'fdf5e6',
  Tive: '808000',
  TivedBb: '6b8e23',
  Sange: 'ffa500',
  SangeYd: 'ff4500',
  ScEd: 'da70d6',
  pOegTMnPd: 'eee8aa',
  pOegYF: '98fb98',
  pOeQe: 'afeeee',
  pOeviTetYd: 'db7093',
  papayawEp: 'ffefd5',
  pHKpuff: 'ffdab9',
  peru: 'cd853f',
  pRk: 'ffc0cb',
  plum: 'dda0dd',
  powMrXe: 'b0e0e6',
  purpN: '800080',
  YbeccapurpN: '663399',
  Yd: 'ff0000',
  Psybrown: 'bc8f8f',
  PyOXe: '4169e1',
  saddNbPwn: '8b4513',
  sOmon: 'fa8072',
  sandybPwn: 'f4a460',
  sHgYF: '2e8b57',
  sHshell: 'fff5ee',
  siFna: 'a0522d',
  silver: 'c0c0c0',
  skyXe: '87ceeb',
  UXe: '6a5acd',
  UWay: '708090',
  UgYy: '708090',
  snow: 'fffafa',
  sprRggYF: 'ff7f',
  stAlXe: '4682b4',
  tan: 'd2b48c',
  teO: '8080',
  tEstN: 'd8bfd8',
  tomato: 'ff6347',
  Qe: '40e0d0',
  viTet: 'ee82ee',
  JHt: 'f5deb3',
  wEte: 'ffffff',
  wEtesmoke: 'f5f5f5',
  Lw: 'ffff00',
  LwgYF: '9acd32'
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
  }
  return unpacked;
}
let helpers_segment_names;
function nameParse(str) {
  if (!helpers_segment_names) {
    helpers_segment_names = unpack();
    helpers_segment_names.transparent = [0, 0, 0, 0];
  }
  const a = helpers_segment_names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
function rgbString(v) {
  return v && (
    v.a < 255
      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
      : `rgb(${v.r}, ${v.g}, ${v.b})`
  );
}
const helpers_segment_to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const helpers_segment_from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = helpers_segment_from(b2n(rgb1.r));
  const g = helpers_segment_from(b2n(rgb1.g));
  const b = helpers_segment_from(b2n(rgb1.b));
  return {
    r: n2b(helpers_segment_to(r + t * (helpers_segment_from(b2n(rgb2.r)) - r))),
    g: n2b(helpers_segment_to(g + t * (helpers_segment_from(b2n(rgb2.g)) - g))),
    b: n2b(helpers_segment_to(b + t * (helpers_segment_from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = {r: 0, g: 0, b: 0, a: 255};
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = {r: input[0], g: input[1], b: input[2], a: 255};
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, {r: 0, g: 0, b: 0, a: 1});
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === 'r') {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === 'object') {
      v = fromObject(input);
    } else if (type === 'string') {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : undefined;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : undefined;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : undefined;
  }
  mix(color, weight) {
    if (color) {
      const c1 = this.rgb;
      const c2 = color.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      w2 = 1 - w1;
      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color, t) {
    if (color) {
      this._rgb = interpolate(this._rgb, color._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = helpers_segment_round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
function index_esm(input) {
  return new Color(input);
}

function isPatternOrGradient(value) {
  if (value && typeof value === 'object') {
    const type = value.toString();
    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
  }
  return false;
}
function helpers_segment_color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value)
    ? value
    : index_esm(value).saturate(0.5).darken(0.1).hexString();
}

const overrides = Object.create(null);
const helpers_segment_descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split('.');
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function helpers_segment_set(root, scope, values) {
  if (typeof scope === 'string') {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ''), scope);
}
class Defaults {
  constructor(_descriptors) {
    this.animation = undefined;
    this.backgroundColor = 'rgba(0,0,0,0.1)';
    this.borderColor = 'rgba(0,0,0,0.1)';
    this.color = '#666';
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      'mousemove',
      'mouseout',
      'click',
      'touchstart',
      'touchmove'
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: 'normal',
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = 'x';
    this.interaction = {
      mode: 'nearest',
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = undefined;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors);
  }
  set(scope, values) {
    return helpers_segment_set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return helpers_segment_set(helpers_segment_descriptors, scope, values);
  }
  override(scope, values) {
    return helpers_segment_set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = '_' + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
}
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith('on'),
  _indexable: (name) => name !== 'events',
  hover: {
    _fallback: 'interaction'
  },
  interaction: {
    _scriptable: false,
    _indexable: false,
  }
});

function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + ' ' : '')
		+ (font.weight ? font.weight + ' ' : '')
		+ font.size + 'px '
		+ font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== undefined && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext('2d');
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === 'object') {
    type = style.toString();
    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
  default:
    if (w) {
      ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
    } else {
      ctx.arc(x, y, radius, 0, TAU);
    }
    ctx.closePath();
    break;
  case 'triangle':
    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    ctx.closePath();
    break;
  case 'rectRounded':
    cornerRadius = radius * 0.516;
    size = radius - cornerRadius;
    xOffset = Math.cos(rad + QUARTER_PI) * size;
    yOffset = Math.sin(rad + QUARTER_PI) * size;
    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
    ctx.closePath();
    break;
  case 'rect':
    if (!rotation) {
      size = Math.SQRT1_2 * radius;
      width = w ? w / 2 : size;
      ctx.rect(x - width, y - size, 2 * width, 2 * size);
      break;
    }
    rad += QUARTER_PI;
  case 'rectRot':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + yOffset, y - xOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    ctx.closePath();
    break;
  case 'crossRot':
    rad += QUARTER_PI;
  case 'cross':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'star':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    rad += QUARTER_PI;
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'line':
    xOffset = w ? w / 2 : Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    break;
  case 'dash':
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
    break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&
		point.y > area.top - margin && point.y < area.bottom + margin);
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === 'middle') {
    const midpoint = (previous.x + target.x) / 2.0;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === 'after' !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(
    flip ? previous.cp1x : previous.cp2x,
    flip ? previous.cp1y : previous.cp2y,
    flip ? target.cp2x : target.cp1x,
    flip ? target.cp2y : target.cp1y,
    target.x,
    target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const {x, y, w, h, radius} = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ('' + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === 'normal') {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
  case 'px':
    return value;
  case '%':
    value /= 100;
    break;
  }
  return size * value;
}
const numberOrZero = v => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value)
    ? objProps
      ? prop => valueOrDefault(value[prop], value[props[prop]])
      : prop => value[prop]
    : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === 'string') {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !('' + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = '';
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ''
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === undefined) {
      continue;
    }
    if (context !== undefined && typeof value === 'function') {
      value = value(context);
      cacheable = false;
    }
    if (index !== undefined && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== undefined) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const {min, max} = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}

function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve('_fallback', scopes);
  }
  const cache = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop,
        () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop,
        () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys
        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined
        : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {
  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&
  (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const {_proxy, _context, _subProxy, _stack} = target;
  if (_stack.has(prop)) {
    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter(s => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent
  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set = new Set();
  set.add(value);
  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set), [''], rootScopes, fallback,
    () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value)
        ? createSubResolver(scopes, proxy, prop, value)
        : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
      set.add(key);
    }
  }
  return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const {iScale} = meta;
  const {key = 'r'} = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index = i + start;
    item = data[index];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index)
    };
  }
  return parsed;
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i]
      : !pointAfter ? deltaK[i - 1]
      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0
      : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === 'monotone') {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(
        prev,
        point,
        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
        options.tension
      );
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}

function _isDomSupported() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === '[object ShadowRoot]') {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === 'string') {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf('%') !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = ['top', 'right', 'bottom', 'left'];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? '-' + suffix : '';
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const {offsetX, offsetY} = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {x, y, box};
}
function getRelativePosition(evt, chart) {
  if ('native' in evt) {
    return evt;
  }
  const {canvas, currentDevicePixelRatio} = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === 'border-box';
  const paddings = getPositionedStyle(style, 'padding');
  const borders = getPositionedStyle(style, 'border', 'width');
  const {x, y, box} = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let {width, height} = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === undefined || height === undefined) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
      const containerPadding = getPositionedStyle(containerStyle, 'padding');
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = v => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, 'margin');
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let {width, height} = containerSize;
  if (style.boxSizing === 'content-box') {
    const borders = getPositionedStyle(style, 'border', 'width');
    const paddings = getPositionedStyle(style, 'padding');
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio
      || canvas.height !== deviceHeight
      || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = (function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener('test', null, options);
    window.removeEventListener('test', null, options);
  } catch (e) {
  }
  return passiveSupported;
}());
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : undefined;
}

function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y
    : mode === 'after' ? t < 1 ? p1.y : p2.y
    : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {x: p1.cp2x, y: p1.cp2y};
  const cp2 = {x: p2.cp1x, y: p2.cp1y};
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}

const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === 'center') {
        return align;
      }
      return align === 'right' ? 'left' : 'right';
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    },
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    },
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === 'ltr' || direction === 'rtl') {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue('direction'),
      style.getPropertyPriority('direction'),
    ];
    style.setProperty('direction', direction, 'important');
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== undefined) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty('direction', original[0], original[1]);
  }
}

function propertyFn(property) {
  if (property === 'angle') {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle,
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: x => x
  };
}
function normalizeSegment({start, end, count, loop, style}) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const {property, start: startBound, end: endBound} = bounds;
  const {between, normalize} = propertyFn(property);
  const count = points.length;
  let {start, end, loop} = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {start, end, loop, style: segment.style};
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const {property, start: startBound, end: endBound} = bounds;
  const count = points.length;
  const {compare, between, normalize} = propertyFn(property);
  const {start, end, loop, style} = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({start: subStart, end, loop, count, style}));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {start, end};
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({start: start % count, end: (end - 1) % count, loop});
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({start: start % count, end: last % count, loop});
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({start: s % count, end: e % count, loop: l, style: st});
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: 'segment',
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}



// CONCATENATED MODULE: ./node_modules/chart.js/dist/chart.mjs
/*!
 * Chart.js v3.9.0
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */



class chart_Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = undefined;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach(fn => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, 'progress');
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, 'complete');
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), 'complete');
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = new chart_Animator();

const transparent = 'transparent';
const interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = helpers_segment_color(from || transparent);
    const c1 = c0.valid && helpers_segment_color(to || transparent);
    return c1 && c1.valid
      ? c1.mix(c0, factor).hexString()
      : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
class chart_Animation {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = undefined;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || (elapsed < duration));
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = (elapsed / duration) % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({res, rej});
    });
  }
  _notify(resolved) {
    const method = resolved ? 'res' : 'rej';
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}

const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
const colors = ['color', 'borderColor', 'backgroundColor'];
defaults.set('animation', {
  delay: undefined,
  duration: 1000,
  easing: 'easeOutQuart',
  fn: undefined,
  from: undefined,
  loop: undefined,
  to: undefined,
  type: undefined,
});
const chart_animationOptions = Object.keys(defaults.animation);
defaults.describe('animation', {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
});
defaults.set('animations', {
  colors: {
    type: 'color',
    properties: colors
  },
  numbers: {
    type: 'number',
    properties: numbers
  },
});
defaults.describe('animations', {
  _fallback: 'animation',
});
defaults.set('transitions', {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: 'transparent'
      },
      visible: {
        type: 'boolean',
        duration: 0
      },
    }
  },
  hide: {
    animations: {
      colors: {
        to: 'transparent'
      },
      visible: {
        type: 'boolean',
        easing: 'linear',
        fn: v => v | 0
      },
    }
  }
});
class chart_Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach(key => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of chart_animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === '$') {
        continue;
      }
      if (prop === 'options') {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new chart_Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});
  }
  return options;
}

function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === undefined ? allowedOverflow : 0;
  const max = opts.max === undefined ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === 'single';
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || (stacked === undefined && meta.stack !== undefined);
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const {min, max, minDefined, maxDefined} = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if ((positive && value > 0) || (!positive && value < 0)) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const {chart, _cachedMeta: meta} = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const {iScale, vScale, index: datasetIndex} = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const {[iAxis]: index, [vAxis]: value} = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent,
    {
      active: false,
      dataset: undefined,
      datasetIndex: index,
      index,
      mode: 'default',
      type: 'dataset'
    }
  );
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: undefined,
    raw: undefined,
    element,
    index,
    mode: 'default',
    type: 'data'
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked
  && {keys: getSortedDatasetIndices(chart, true), values: null};
class chart_DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = undefined;
    this._parsing = false;
    this._data = undefined;
    this._objectData = undefined;
    this._sharedOptions = undefined;
    this._drawStart = undefined;
    this._drawCount = undefined;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = undefined;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale
      ? meta.vScale
      : meta.iScale;
  }
  reset() {
    this._update('reset');
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const {_cachedMeta: meta, _data: data} = this;
    const {iScale, _stacked} = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, {mode});
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || 'default');
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {}
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || (elements.length - start);
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? 'active' : 'default';
    return index === undefined && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(mode)
      : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context ||
        (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context ||
        (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = 'default', index) {
    const active = mode === 'active';
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + '-' + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new chart_Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {sharedOptions, includeOptions};
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: (!active && this.getSharedOptions(options)) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, 'reset');
    }
  }
  updateElements(element, start, count, mode) {}
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(['_insertElements', this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(['_removeElements', start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(['_insertElements', start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length]);
  }
}
chart_DatasetController.defaults = {};
chart_DatasetController.prototype.datasetElementType = null;
chart_DatasetController.prototype.dataElementType = null;

function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = undefined;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - (size / 2)
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = 'left';
    end = 'right';
  } else {
    reverse = properties.base < properties.y;
    start = 'bottom';
    end = 'top';
  }
  if (reverse) {
    top = 'end';
    bottom = 'start';
  } else {
    top = 'start';
    bottom = 'end';
  }
  return {start, end, reverse, top, bottom};
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};
    return;
  }
  const {start, end, reverse, top, bottom} = borderProps(properties);
  if (edge === 'middle' && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, {inflateAmount}, ratio) {
  properties.inflateAmount = inflateAmount === 'auto'
    ? ratio === 1 ? 0.33 : 0
    : inflateAmount;
}
class chart_BarController extends chart_DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {iScale, vScale} = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom)
      ? '[' + custom.start + ', ' + custom.end + ']'
      : '' + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === 'reset';
    const {index, _cachedMeta: {vScale}} = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const {iScale} = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type)
      .filter(meta => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== undefined && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||
				(stacked === undefined && meta.stack === undefined)) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(undefined);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(undefined, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = (name !== undefined)
      ? stacks.indexOf(name)
      : -1;
    return (index === -1)
      ? stacks.length - 1
      : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === 'flex'
        ? computeFlexCategoryTraits(index, ruler, options, stackCount)
        : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
chart_BarController.id = 'bar';
chart_BarController.defaults = {
  datasetElementType: false,
  dataElementType: 'bar',
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'base', 'width', 'height']
    }
  }
};
chart_BarController.overrides = {
  scales: {
    _index_: {
      type: 'category',
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: 'linear',
      beginAtZero: true,
    }
  }
};

class chart_BubbleController extends chart_DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {xScale, yScale} = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale} = this._cachedMeta;
    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {$shared: false});
    }
    const radius = values.radius;
    if (mode !== 'active') {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
chart_BubbleController.id = 'bubble';
chart_BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: 'point',
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'borderWidth', 'radius']
    }
  }
};
chart_BubbleController.overrides = {
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        }
      }
    }
  }
};

function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {ratioX, ratioY, offsetX, offsetY};
}
class chart_DoughnutController extends chart_DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.offsetX = undefined;
    this.offsetY = undefined;
  }
  linkScales() {}
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i) => +data[i];
      if (isObject(data[start])) {
        const {key = 'value'} = this._parsing;
        getter = (i) => +resolveObjectKey(data[i], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min,
    };
  }
  update(mode) {
    const chart = this.chart;
    const {chartArea} = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const {circumference, rotation} = this._getRotationExtents();
    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== 'inner') {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
chart_DoughnutController.id = 'doughnut';
chart_DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
    },
  },
  cutout: '50%',
  rotation: 0,
  circumference: 360,
  radius: '100%',
  spacing: 0,
  indexAxis: 'r',
};
chart_DoughnutController.descriptors = {
  _scriptable: (name) => name !== 'spacing',
  _indexable: (name) => name !== 'spacing',
};
chart_DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ': ' + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};

class chart_LineController extends chart_DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const {dataset: line, data: points = [], _dataset} = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, undefined, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {spanGaps, segment} = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
chart_LineController.id = 'line';
chart_LineController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  showLine: true,
  spanGaps: false,
};
chart_LineController.overrides = {
  scales: {
    _index_: {
      type: 'category',
    },
    _value_: {
      type: 'linear',
    },
  }
};

class chart_PolarAreaController extends chart_DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = undefined;
    this.outerRadius = undefined;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
    meta.data.forEach((element, index) => {
      const parsed = this.getParsed(index).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - (radiusLength * this.index);
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index)
      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)
      : 0;
  }
}
chart_PolarAreaController.id = 'polarArea';
chart_PolarAreaController.defaults = {
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
    },
  },
  indexAxis: 'r',
  startAngle: 0,
};
chart_PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: 'radialLinear',
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};

class PieController extends chart_DoughnutController {
}
PieController.id = 'pie';
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: '100%'
};

class chart_RadarController extends chart_DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: '' + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== 'resize') {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, undefined, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === 'reset';
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
chart_RadarController.id = 'radar';
chart_RadarController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  indexAxis: 'r',
  showLine: true,
  elements: {
    line: {
      fill: 'start'
    }
  },
};
chart_RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: 'radialLinear',
    }
  }
};

class chart_Element {
  constructor() {
    this.x = undefined;
    this.y = undefined;
    this.active = false;
    this.options = undefined;
    this.$animations = undefined;
  }
  tooltipPosition(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach(prop => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
chart_Element.defaults = {};
chart_Element.defaultRoutes = undefined;

const formatters = {
  values(value) {
    return isArray(value) ? value : '' + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e+15) {
        notation = 'scientific';
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return '';
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {formatters};

defaults.set('scale', {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: 'ticks',
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0.0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: '',
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: '',
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: 'center',
    crossAlign: 'near',
    showLabelBackdrop: false,
    backdropColor: 'rgba(255, 255, 255, 0.75)',
    backdropPadding: 2,
  }
});
defaults.route('scale.ticks', 'color', '', 'color');
defaults.route('scale.grid', 'color', '', 'borderColor');
defaults.route('scale.grid', 'borderColor', '', 'borderColor');
defaults.route('scale.title', 'color', '', 'color');
defaults.describe('scale', {
  _fallback: false,
  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',
});
defaults.describe('scales', {
  _fallback: 'scale',
});
defaults.describe('scale.ticks', {
  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',
  _indexable: (name) => name !== 'backdropPadding',
});

function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    chart_skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      chart_skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    chart_skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  chart_skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function chart_skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}

const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return (lines * font.lineHeight) + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: 'scale'
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: 'tick'
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const {top, left, bottom, right, chart} = scale;
  const {chartArea, scales} = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === 'center') {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === 'center') {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === 'left' ? -HALF_PI : HALF_PI;
  }
  return {titleX, titleY, maxWidth, rotation};
}
class chart_Scale extends chart_Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = undefined;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.paddingTop = undefined;
    this.paddingBottom = undefined;
    this.paddingLeft = undefined;
    this.paddingRight = undefined;
    this.axis = undefined;
    this.labelRotation = undefined;
    this.min = undefined;
    this.max = undefined;
    this._range = undefined;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = undefined;
    this._endPixel = undefined;
    this._reversePixels = false;
    this._userMax = undefined;
    this._userMin = undefined;
    this._suggestedMax = undefined;
    this._suggestedMin = undefined;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = undefined;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let {min, max, minDefined, maxDefined} = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {min, max};
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const {beginAtZero, grace, ticks: tickOpts} = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal()
      ? this.width + margins.left + margins.right
      : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits');
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits');
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks');
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks');
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid)
				- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(
        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
      ));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {}
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const {first, last, widest, highest} = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const {ticks: {align, padding}, position} = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== 'top' && this.axis === 'x';
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === 'start') {
        paddingRight = last.width;
      } else if (align === 'end') {
        paddingLeft = first.width;
      } else if (align !== 'inner') {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === 'start') {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === 'end') {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const {axis, position} = this.options;
    return position === 'top' || position === 'bottom' || axis === 'x';
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const {ctx, _longestTextCache: caches} = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights,
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {}
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const {min, max} = this;
    return min < 0 && max < 0 ? max :
      min > 0 && max > 0 ? min :
      0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context ||
				(tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context ||
			(this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal()
      ? h * cos > w * sin ? w / cos : h / sin
      : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== 'auto') {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const {grid, position} = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === 'top') {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === 'bottom') {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === 'left') {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === 'right') {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === 'x') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === 'y') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndex.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === undefined) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset,
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const {position, ticks: optionTicks} = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const {align, crossAlign, padding, mirror} = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = 'middle';
    if (position === 'top') {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'bottom') {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'left') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === 'right') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === 'x') {
      if (position === 'center') {
        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === 'y') {
      if (position === 'center') {
        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === 'y') {
      if (align === 'start') {
        textBaseline = 'top';
      } else if (align === 'end') {
        textBaseline = 'bottom';
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === 'inner') {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? 'right' : 'left';
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? 'left' : 'right';
          } else {
            tickTextAlign = 'center';
          }
        }
        if (position === 'top') {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
        case 'middle':
          top -= height / 2;
          break;
        case 'bottom':
          top -= height;
          break;
        }
        switch (textAlign) {
        case 'center':
          left -= width / 2;
          break;
        case 'right':
          left -= width;
          break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor,
        };
      }
      items.push({
        rotation,
        label,
        font,
        color,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign: tickTextAlign,
        textBaseline,
        translation: [x, y],
        backdrop,
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const {position, ticks} = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === 'top' ? 'left' : 'right';
    }
    let align = 'center';
    if (ticks.align === 'start') {
      align = 'left';
    } else if (ticks.align === 'end') {
      align = 'right';
    } else if (ticks.align === 'inner') {
      align = 'inner';
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const {position, ticks: {crossAlign, mirror, padding}} = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === 'left') {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += (widest / 2);
        } else {
          textAlign = 'right';
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x = this.left;
        }
      }
    } else if (position === 'right') {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x = this.right;
        }
      }
    } else {
      textAlign = 'right';
    }
    return {textAlign, x};
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === 'left' || position === 'right') {
      return {top: 0, left: this.left, bottom: chart.height, right: this.right};
    } if (position === 'top' || position === 'bottom') {
      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};
    }
  }
  drawBackground() {
    const {ctx, options: {backgroundColor}, left, top, width, height} = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex(t => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine(
            {x: item.x1, y: item.y1},
            {x: item.x2, y: item.y2},
            item
          );
        }
        if (grid.drawTicks) {
          drawLine(
            {x: item.tx1, y: item.ty1},
            {x: item.tx2, y: item.ty2},
            {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            }
          );
        }
      }
    }
  }
  drawBorder() {
    const {chart, ctx, options: {grid}} = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const {ctx, options: {position, title, reverse}} = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === 'bottom' || position === 'center' || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== chart_Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + 'AxisID';
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}

class chart_TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + '.' + id;
    if (!id) {
      throw new Error('class does not have id: ' + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach(property => {
    const propertyParts = property.split('.');
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join('.');
    const parts = routes[property].split('.');
    const targetName = parts.pop();
    const targetScope = parts.join('.');
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return 'id' in proto && 'defaults' in proto;
}

class chart_Registry {
  constructor() {
    this.controllers = new chart_TypedRegistry(chart_DatasetController, 'datasets', true);
    this.elements = new chart_TypedRegistry(chart_Element, 'elements');
    this.plugins = new chart_TypedRegistry(Object, 'plugins');
    this.scales = new chart_TypedRegistry(chart_Scale, 'scales');
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each('register', args);
  }
  remove(...args) {
    this._each('unregister', args);
  }
  addControllers(...args) {
    this._each('register', args, this.controllers);
  }
  addElements(...args) {
    this._each('register', args, this.elements);
  }
  addPlugins(...args) {
    this._each('register', args, this.plugins);
  }
  addScales(...args) {
    this._each('register', args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, 'controller');
  }
  getElement(id) {
    return this._get(id, this.elements, 'element');
  }
  getPlugin(id) {
    return this._get(id, this.plugins, 'plugin');
  }
  getScale(id) {
    return this._get(id, this.scales, 'scale');
  }
  removeControllers(...args) {
    this._each('unregister', args, this.controllers);
  }
  removeElements(...args) {
    this._each('unregister', args, this.elements);
  }
  removePlugins(...args) {
    this._each('unregister', args, this.plugins);
  }
  removeScales(...args) {
    this._each('unregister', args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach(arg => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {
        this._exec(method, reg, arg);
      } else {
        each(arg, item => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry, component) {
    const camelMethod = _capitalize(method);
    callback(component['before' + camelMethod], [], component);
    registry[method](component);
    callback(component['after' + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === undefined) {
      throw new Error('"' + id + '" is not a registered ' + type + '.');
    }
    return item;
  }
}
var chart_registry = new chart_Registry();

class chart_ScatterController extends chart_DatasetController {
  update(mode) {
    const meta = this._cachedMeta;
    const {data: points = []} = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const {dataset: line, _dataset} = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, undefined, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const {showLine} = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = chart_registry.getElement('line');
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {spanGaps, segment} = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
}
chart_ScatterController.id = 'scatter';
chart_ScatterController.defaults = {
  datasetElementType: false,
  dataElementType: 'point',
  showLine: false,
  fill: false
};
chart_ScatterController.overrides = {
  interaction: {
    mode: 'point'
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(item) {
          return '(' + item.label + ', ' + item.formattedValue + ')';
        }
      }
    }
  },
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  }
};

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: chart_BarController,
BubbleController: chart_BubbleController,
DoughnutController: chart_DoughnutController,
LineController: chart_LineController,
PolarAreaController: chart_PolarAreaController,
PieController: PieController,
RadarController: chart_RadarController,
ScatterController: chart_ScatterController
});

function chart_abstract() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
class DateAdapter {
  constructor(options) {
    this.options = options || {};
  }
  init(chartOptions) {}
  formats() {
    return chart_abstract();
  }
  parse(value, format) {
    return chart_abstract();
  }
  format(timestamp, format) {
    return chart_abstract();
  }
  add(timestamp, amount, unit) {
    return chart_abstract();
  }
  diff(a, b, unit) {
    return chart_abstract();
  }
  startOf(timestamp, unit, weekday) {
    return chart_abstract();
  }
  endOf(timestamp, unit) {
    return chart_abstract();
  }
}
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};

function binarySearch(metaset, axis, value, intersect) {
  const {controller, data, _sorted} = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === 'function' && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {lo: start.lo, hi: end.hi};
      }
    }
  }
  return {lo: 0, hi: data.length - 1};
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const {index, data} = metasets[i];
    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf('x') !== -1;
  const useY = axis.indexOf('y') !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);
    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({element, datasetIndex, index});
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{element, datasetIndex, index}];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({element, datasetIndex, index});
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === 'r' && !intersect
    ? getNearestRadialItems(chart, position, axis, useFinalPosition)
    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({element, datasetIndex, index});
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'x';
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)
        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({element, datasetIndex: meta.index, index});
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :
        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({element: data[i], datasetIndex, index: i});
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
    }
  }
};

const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
function filterByPosition(array, position) {
  return array.filter(v => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ?
      v0.index - v1.index :
      v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({position: pos, options: {stack, stackWeight = 1}} = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && (pos + stack),
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts) {
  const stacks = {};
  for (const wrap of layouts) {
    const {stack, pos, stackWeight} = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts, params) {
  const stacks = buildStacks(layouts);
  const {vBoxMaxWidth, hBoxMaxHeight} = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts.length; i < ilen; ++i) {
    layout = layouts[i];
    const {fullSize} = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const {pos, box} = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {size: 0, count: 1};
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal
    ? {same: widthChanged, other: heightChanged}
    : {same: heightChanged, other: widthChanged};
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos('top');
  chartArea.x += updatePos('left');
  updatePos('right');
  updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions) {
    const margin = {left: 0, top: 0, right: 0, bottom: 0};
    positions.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal
    ? marginForPositions(['left', 'right'])
    : marginForPositions(['top', 'bottom']);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(
      layout.width || chartArea.w,
      layout.height || chartArea.h,
      getMargins(layout.horizontal, chartArea)
    );
    const {same, other} = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let {x, y} = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};
    const weight = (layout.stackWeight / stack.weight) || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set('layout', {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, box => {
      if (typeof box.beforeLayout === 'function') {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>
      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w,
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});
    });
  }
};

class BasePlatform {
  acquireContext(canvas, aspectRatio) {}
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {}
  removeEventListener(chart, type, listener) {}
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}

class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext('2d') || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}

const EXPANDO_KEY = '$chartjs';
const EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};
const isNullOrEmpty = value => value === null || value === '';
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute('height');
  const renderWidth = canvas.getAttribute('width');
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || 'block';
  style.boxSizing = style.boxSizing || 'border-box';
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, 'width');
    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === '') {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, 'height');
      if (displayHeight !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const {x, y} = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null,
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener('resize', onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener('resize', onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === 'resize') {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
class chart_DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext('2d');
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ['height', 'width'].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = undefined;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
}

function _detectPlatform(canvas) {
  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {
    return BasicPlatform;
  }
  return chart_DomPlatform;
}

class chart_PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === 'beforeInit') {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, 'install');
    }
    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors, chart, hook, args);
    if (hook === 'afterDestroy') {
      this._notify(descriptors, chart, 'stop');
      this._notify(this._init, chart, 'uninstall');
    }
    return result;
  }
  _notify(descriptors, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = undefined;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors = this._cache;
    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
    this._notify(diff(descriptors, previousDescriptors), chart, 'start');
  }
}
function allPlugins(config) {
  const localIds = {};
  const plugins = [];
  const keys = Object.keys(chart_registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(chart_registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {plugins, localIds};
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, {plugins, localIds}, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, {plugin, local}, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [''], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}

function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === '_index_') {
    axis = indexAxis;
  } else if (id === '_value_') {
    axis = indexAxis === 'x' ? 'y' : 'x';
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? '_index_' : '_value_';
}
function axisFromPosition(position) {
  if (position === 'top' || position === 'bottom') {
    return 'x';
  }
  if (position === 'left' || position === 'right') {
    return 'y';
  }
}
function determineAxis(id, scaleOptions) {
  if (id === 'x' || id === 'y') {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {scales: {}};
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales = Object.create(null);
  Object.keys(configScales).forEach(id => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach(dataset => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach(defaultID => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
      scales[id] = scales[id] || Object.create(null);
      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach(key => {
    const scale = scales[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== undefined) {
    set.add(opts);
  }
};
class chart_Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType,
      () => [[
        `datasets.${datasetType}`,
        ''
      ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`,
      () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`,
        ],
        [
          `datasets.${datasetType}`,
          ''
        ]
      ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`,
      () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ''
      ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`,
      () => [[
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || [],
      ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const {options, type} = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach(keys => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach(key => addIfFound(scopes, mainScope, key));
      }
      keys.forEach(key => addIfFound(scopes, options, key));
      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach(key => addIfFound(scopes, defaults, key));
      keys.forEach(key => addIfFound(scopes, helpers_segment_descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const {options, type} = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {type},
      defaults,
      helpers_segment_descriptors
    ];
  }
  resolveNamedOptions(scopes, names, context, prefixes = ['']) {
    const result = {$shared: true};
    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context)
      ? _attachContext(resolver, context, undefined, descriptorDefaults)
      : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = value => isObject(value)
  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names) {
  const {isScriptable, isIndexable} = _descriptors(proxy);
  for (const prop of names) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if ((scriptable && (isFunction(value) || hasFunction(value)))
      || (indexable && isArray(value))) {
      return true;
    }
  }
  return false;
}

var version = "3.9.0";

const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
function positionIsHorizontal(position, axis) {
  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1]
      ? a[l2] - b[l2]
      : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins('afterRender');
  callback(animationOptions && animationOptions.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === 'string') {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === 'mouseout') {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
class chart_Chart {
  constructor(item, userConfig) {
    const config = this.config = new chart_Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error(
        'Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' +
				' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.'
      );
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = undefined;
    this.boxes = [];
    this.currentDevicePixelRatio = undefined;
    this.chartArea = undefined;
    this._active = [];
    this._lastEvent = undefined;
    this._listeners = {};
    this._responsiveListeners = undefined;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new chart_PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = undefined;
    this.$context = undefined;
    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, 'complete', onAnimationsComplete);
    animator.listen(this, 'progress', onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins('beforeInit');
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins('afterInit');
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {width, height};
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? 'resize' : 'attach';
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins('resize', {size: newSize});
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(
        Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === 'r';
          const isHorizontal = axis === 'x';
          return {
            options: scaleOptions,
            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
          };
        })
      );
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = chart_registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
  }
  _removeUnreferencedMetasets() {
    const {_metasets: metasets, data: {datasets}} = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter(x => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = '' + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = chart_registry.getController(type);
        const {datasetElementType, dataElementType} = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: chart_registry.getElement(dataElementType),
          datasetElementType: datasetElementType && chart_registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins('reset');
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins('beforeElementsUpdate');
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const {controller} = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins('afterUpdate', {mode});
    this._layers.sort(compare2Level('z', '_idx'));
    const {_active, _lastEvent} = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const {_hiddenIndices} = this;
    const changes = this._getUniformDataChanges() || [];
    for (const {method, start, count} of changes) {
      const move = method === '_removeElements' ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(
      _dataChanges
        .filter(c => c[0] === idx)
        .map((c, i) => i + ',' + c.splice(1).join(','))
    );
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet)
      .map(c => c.split(','))
      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === 'chartArea') {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins('afterLayout');
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);
    }
    this.notifyPlugins('afterDatasetsUpdate', {mode});
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {meta, index, mode, cancelable: true};
    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins('afterDatasetUpdate', args);
  }
  render() {
    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({chart: this});
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const {width, height} = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins('afterDraw');
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins('afterDatasetsDraw');
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins('afterDatasetDraw', args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === 'function') {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter(x => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? 'show' : 'hide';
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(undefined, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {visible});
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins('beforeDestroy');
    const {canvas, ctx} = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins('destroy');
    delete instances[this.id];
    this.notifyPlugins('afterDestroy');
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const _remove = (type, listener) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove('attach', attached);
      this.attached = true;
      this.resize();
      _add('resize', listener);
      _add('detach', detached);
    };
    detached = () => {
      this.attached = false;
      _remove('resize', listener);
      this._stop();
      this._resize(0, 0);
      _add('attach', attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = undefined;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? 'set' : 'remove';
    let meta, item, i, ilen;
    if (mode === 'dataset') {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller['_' + prefix + 'DatasetHoverStyle']();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('No dataset found at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins('afterEvent', args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const {_active: lastActive = [], options} = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
const invalidatePlugins = () => each(chart_Chart.instances, (chart) => chart._plugins.invalidate());
const enumerable = true;
Object.defineProperties(chart_Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: chart_registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      chart_registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      chart_registry.remove(...items);
      invalidatePlugins();
    }
  }
});

function clipArc(ctx, element, endAngle) {
  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta),
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const {fullCircles, startAngle, circumference} = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const {x, y, startAngle, pixelMargin, fullCircles} = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
  const {options} = element;
  const {borderWidth, borderJoinStyle} = options;
  const inner = options.borderAlign === 'inner';
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || 'round';
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || 'bevel';
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.stroke();
}
class chart_ArcElement extends chart_Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.circumference = undefined;
    this.startAngle = undefined;
    this.endAngle = undefined;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(['x', 'y'], useFinalPosition);
    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});
    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference'
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return (betweenAngles && withinRadius);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
      'x',
      'y',
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference',
    ], useFinalPosition);
    const {offset, spacing} = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const {options, circumference} = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
    ctx.restore();
  }
}
chart_ArcElement.id = 'arc';
chart_ArcElement.defaults = {
  borderAlign: 'center',
  borderColor: '#fff',
  borderJoinStyle: undefined,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: undefined,
  circular: true,
};
chart_ArcElement.defaultRoutes = {
  backgroundColor: 'backgroundColor'
};

function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
  const {start: segmentStart, end: segmentEnd} = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const {points, options} = line;
  const {count, start, loop, ilen} = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let {move = true, reverse} = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const {count, start, ilen} = pathVars(points, segment, params);
  const {move = true, reverse} = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const {segments, options} = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class chart_LineElement extends chart_Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = undefined;
    this._chart = undefined;
    this._loop = undefined;
    this._fullLoop = undefined;
    this._path = undefined;
    this._points = undefined;
    this._segments = undefined;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {property, start: value, end: value});
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const {start, end} = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || (this.points.length - start);
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = undefined;
    }
  }
}
chart_LineElement.id = 'line';
chart_LineElement.defaults = {
  borderCapStyle: 'butt',
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: 'miter',
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: 'default',
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0,
};
chart_LineElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};
chart_LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== 'borderDash' && name !== 'fill',
};

function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const {[axis]: value} = el.getProps([axis], useFinalPosition);
  return (Math.abs(pos - value) < options.radius + options.hitRadius);
}
class chart_PointElement extends chart_Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.parsed = undefined;
    this.skip = undefined;
    this.stop = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, 'x', useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, 'y', useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
chart_PointElement.id = 'point';
chart_PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: 'circle',
  radius: 3,
  rotation: 0
};
chart_PointElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

function getBarBounds(bar, useFinalPosition) {
  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {left, top, right, bottom};
}
function skipOrLimit(skip, value, min, max) {
  return skip ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip.top, o.top, 0, maxH),
    r: skipOrLimit(skip.right, o.right, 0, maxW),
    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds
		&& (skipX || _isBetween(x, bounds.left, bounds.right))
		&& (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class chart_BarElement extends chart_Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.horizontal = undefined;
    this.base = undefined;
    this.width = undefined;
    this.height = undefined;
    this.inflateAmount = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const {inflateAmount, options: {borderColor, backgroundColor}} = this;
    const {inner, outer} = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill('evenodd');
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === 'x' ? this.width / 2 : this.height / 2;
  }
}
chart_BarElement.id = 'bar';
chart_BarElement.defaults = {
  borderSkipped: 'start',
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: 'auto',
  pointStyle: undefined
};
chart_BarElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

var chart_elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: chart_ArcElement,
LineElement: chart_LineElement,
PointElement: chart_PointElement,
BarElement: chart_BarElement
});

function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const {x: pointAx, y: pointAy} = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs(
        (pointAx - avgX) * (data[j].y - pointAy) -
        (pointAx - data[j].x) * (avgY - pointAy)
      );
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX,
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, 'data', {value: data});
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const {iScale} = meta;
  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {start, count};
}
var plugin_decimation = {
  id: 'decimation',
  defaults: {
    algorithm: 'min-max',
    enabled: false,
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const {_data, indexAxis} = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, 'data', {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
      case 'lttb':
        decimated = lttbDecimation(data, start, count, availableWidth, options);
        break;
      case 'min-max':
        decimated = minMaxDecimation(data, start, count, availableWidth);
        break;
      default:
        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};

function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let {start, end} = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === 'angle') {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {property, start, end};
}
function _pointsFromSegments(boundary, line) {
  const {x = null, y = null} = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({start, end}) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({x: first.x, y});
      points.push({x: last.x, y});
    } else if (x !== null) {
      points.push({x, y: first.y});
      points.push({x, y: last.y});
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (;end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}

function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new chart_LineElement({
    points,
    options: {tension: 0},
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}

function _resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if (isObject(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill[0], index, target, count);
  }
  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
  if (firstCh === '-' || firstCh === '+') {
    target = index + target;
  }
  if (target === index || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill, scale) {
  let pixel = null;
  if (fill === 'start') {
    pixel = scale.bottom;
  } else if (fill === 'end') {
    pixel = scale.top;
  } else if (isObject(fill)) {
    pixel = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill, scale, startValue) {
  let value;
  if (fill === 'start') {
    value = startValue;
  } else if (fill === 'end') {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill === undefined) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return 'origin';
  }
  return fill;
}

function _buildStackLine(source) {
  const {scale, index, line} = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new chart_LineElement({points, options: {}});
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas('line');
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const {first, last, point} = findPoint(line, sourcePoint, 'x');
    if (!point || (first && last)) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {first, last, point};
}

class chart_simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const {x, y, radius} = this;
    bounds = bounds || {start: 0, end: TAU};
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const {x, y, radius} = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}

function _getTarget(source) {
  const {chart, fill, line} = source;
  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === 'stack') {
    return _buildStackLine(source);
  }
  if (fill === 'shape') {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof chart_simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const {scale = {}, fill} = source;
  const pixel = _getTargetPixel(fill, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const {scale, fill} = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill, scale, start);
  const target = [];
  if (options.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new chart_simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}

function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const {line, scale, axis} = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color = lineOpts.backgroundColor;
  const {above = color, below = color} = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {line, target, above, below, area, scale, axis});
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const {line, target, above, below, area, scale} = cfg;
  const property = line._loop ? 'angle' : cfg.axis;
  ctx.save();
  if (property === 'x' && below !== above) {
    clipVertical(ctx, target, area.top);
    chart_fill(ctx, {line, target, color: above, scale, property});
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  chart_fill(ctx, {line, target, color: below, scale, property});
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const {segments, points} = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const {start, end} = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function chart_fill(ctx, cfg) {
  const {line, target, property, color, scale} = cfg;
  const segments = _segments(line, target, property);
  for (const {source: src, target: tgt, start, end} of segments) {
    const {style: {backgroundColor = color} = {}} = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? 'evenodd' : 'nonzero');
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const {top, bottom} = scale.chart.chartArea;
  const {property, start, end} = bounds || {};
  if (property === 'x') {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}

var chart_index = {
  id: 'filler',
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof chart_LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line,
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw = options.drawTime === 'beforeDraw';
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== 'beforeDatasetsDraw') {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: 'beforeDatasetDraw'
  }
};

const getBoxSize = (labelOpts, fontSize) => {
  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class chart_Legend extends chart_Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = undefined;
    this.columnSizes = undefined;
    this.lineWidths = undefined;
    this.maxHeight = undefined;
    this.maxWidth = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.height = undefined;
    this.width = undefined;
    this._margins = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const {options, ctx} = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const {ctx, maxWidth, options: {labels: {padding}}} = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const {ctx, maxHeight, options: {labels: {padding}}} = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({width: currentColWidth, height: currentColHeight});
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({width: currentColWidth, height: currentColHeight});
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom';
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const {options: opts, columnSizes, lineWidths, ctx} = this;
    const {align, labels: labelOpts} = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const {color: fontColor, padding} = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign('left');
    ctx.textBaseline = 'middle';
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some(v => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius,
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right)
      && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)
          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === 'mousemove' || e.type === 'mouseout') {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
}
function isListened(type, opts) {
  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === 'click' || type === 'mouseup')) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: 'legend',
  _element: chart_Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new chart_Legend({ctx: chart.ctx, options, chart});
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: 'top',
    align: 'center',
    fullSize: true,
    reverse: false,
    weight: 1000,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: 'center',
      text: '',
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith('on'),
    labels: {
      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),
    }
  },
};

class chart_Title extends chart_Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  }
  _drawArgs(offset) {
    const {top, left, bottom, right, options} = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === 'left') {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {titleX, titleY, maxWidth, rotation};
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new chart_Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: 'title',
  _element: chart_Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'bold',
    },
    fullSize: true,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const chart_map = new WeakMap();
var plugin_subtitle = {
  id: 'subtitle',
  start(chart, _args, options) {
    const title = new chart_Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    chart_map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, chart_map.get(chart));
    chart_map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = chart_map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'normal',
    },
    fullSize: true,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }
  return str;
}
function createTooltipItem(chart, item) {
  const {element, datasetIndex, index} = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const {label, value} = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const {body, footer, title} = tooltip;
  const {boxWidth, boxHeight} = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight
			+ (titleLineCount - 1) * options.titleSpacing
			+ options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight
			+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight
			+ (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop
			+ footerLineCount * footerFont.lineHeight
			+ (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {width, height};
}
function determineYAlign(chart, size) {
  const {y, height} = size;
  if (y < height / 2) {
    return 'top';
  } else if (y > (chart.height - height / 2)) {
    return 'bottom';
  }
  return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const {x, width} = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === 'left' && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === 'right' && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const {x, width} = size;
  const {width: chartWidth, chartArea: {left, right}} = chart;
  let xAlign = 'center';
  if (yAlign === 'center') {
    xAlign = x <= (left + right) / 2 ? 'left' : 'right';
  } else if (x <= width / 2) {
    xAlign = 'left';
  } else if (x >= chartWidth - width / 2) {
    xAlign = 'right';
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = 'center';
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let {x, width} = size;
  if (xAlign === 'right') {
    x -= width;
  } else if (xAlign === 'center') {
    x -= (width / 2);
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let {y, height} = size;
  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= height + paddingAndSize;
  } else {
    y -= (height / 2);
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const {caretSize, caretPadding, cornerRadius} = options;
  const {xAlign, yAlign} = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === 'right') {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === 'center'
    ? tooltip.x + tooltip.width / 2
    : align === 'right'
      ? tooltip.x + tooltip.width - padding.right
      : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: 'tooltip'
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
class chart_Tooltip extends chart_Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = undefined;
    this._size = undefined;
    this._cachedAnimations = undefined;
    this._tooltipItems = [];
    this.$animations = undefined;
    this.$context = undefined;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = undefined;
    this.title = undefined;
    this.beforeBody = undefined;
    this.body = undefined;
    this.afterBody = undefined;
    this.footer = undefined;
    this.xAlign = undefined;
    this.yAlign = undefined;
    this.x = undefined;
    this.y = undefined;
    this.height = undefined;
    this.width = undefined;
    this.caretX = undefined;
    this.caretY = undefined;
    this.labelColors = undefined;
    this.labelPointStyles = undefined;
    this.labelTextColors = undefined;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = undefined;
    this.$context = undefined;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new chart_Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context ||
			(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const {callbacks} = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const {callbacks} = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const {callbacks} = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = undefined;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {chart: this.chart, tooltip: this, replay});
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const {xAlign, yAlign} = this;
    const {caretSize, cornerRadius} = options;
    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
    const {x: ptX, y: ptY} = tooltipPoint;
    const {width, height} = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === 'center') {
      y2 = ptY + (height / 2);
      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === 'left') {
        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);
      } else if (xAlign === 'right') {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {x1, x2, x3, y1, y2, y3};
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = 'middle';
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const {boxHeight, boxWidth, boxPadding} = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, 'left', options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : (labelColors.borderWidth || 1);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius,
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius,
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const {body} = this;
    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = 'middle';
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'
      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)
      : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = 'middle';
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const {xAlign, yAlign} = this;
    const {x, y} = pt;
    const {width, height} = tooltipSize;
    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === 'top') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === 'bottom') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('Cannot find a dataset at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const {caretX, caretY, options} = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
chart_Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: 'tooltip',
  _element: chart_Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new chart_Tooltip({chart, options});
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins('afterTooltipDraw', args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: {
      weight: 'bold',
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {
    },
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: 'bold',
    },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: true,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: 'easeOutQuart',
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
      },
      opacity: {
        easing: 'linear',
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === 'dataset') {
            return item.dataset.label || '';
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return '';
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
          label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0,
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation,
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    }
  },
  defaultRoutes: {
    bodyFont: 'font',
    footerFont: 'font',
    titleFont: 'font'
  },
  descriptors: {
    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false,
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: 'animation'
    }
  },
  additionalOptionScopes: ['interaction']
};

var chart_plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Decimation: plugin_decimation,
Filler: chart_index,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === 'string') {
    index = labels.push(raw) - 1;
    addedLabels.unshift({index, label: raw});
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
class chart_CategoryScale extends chart_Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = undefined;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const {index, label} of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index
      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const {minDefined, maxDefined} = this.getUserBounds();
    let {min, max} = this.getMinMax(true);
    if (this.options.bounds === 'ticks') {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({value});
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== 'number') {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
chart_CategoryScale.id = 'category';
chart_CategoryScale.defaults = {
  ticks: {
    callback: chart_CategoryScale.prototype.getLabelForValue
  }
};

function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const {min: rmin, max: rmax} = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{value: rmin}, {value: rmax}];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === 'ticks') {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(
    _decimalPlaces(spacing),
    _decimalPlaces(niceMin)
  );
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({value: min});
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({value: max});
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({value: niceMax});
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
  const length = 0.75 * minSpacing * ('' + value).length;
  return Math.min(minSpacing / ratio, length);
}
class chart_LinearScaleBase extends chart_Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._endValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const {beginAtZero} = this.options;
    const {minDefined, maxDefined} = this.getUserBounds();
    let {min, max} = this;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let {maxTicksLimit, stepSize} = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1000) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1000;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}

class chart_LinearScale extends chart_LinearScaleBase {
  determineDataLimits() {
    const {min, max} = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
chart_LinearScale.id = 'linear';
chart_LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};

function isMajor(tickVal) {
  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({value: tickVal, major: isMajor(tickVal)});
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || (exp === endExp && significand < endSignificand));
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({value: lastTick, major: isMajor(tickVal)});
  return ticks;
}
class chart_LogarithmicScale extends chart_Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = chart_LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return undefined;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const {min, max} = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const {minDefined, maxDefined} = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, +1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, +1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === undefined
      ? '0'
      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === undefined || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min
      ? 0
      : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
chart_LogarithmicScale.id = 'logarithmic';
chart_LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};

function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - (size / 2),
      end: pos + (size / 2)
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(
    orig.l - limits.l,
    limits.r - orig.r,
    orig.t - limits.t,
    limits.b - orig.b
  );
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return 'center';
  } else if (angle < 180) {
    return 'left';
  }
  return 'right';
}
function leftForTextAlign(x, w, align) {
  if (align === 'right') {
    x -= w;
  } else if (align === 'center') {
    x -= (w / 2);
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= (h / 2);
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const {ctx, options: {pointLabels}} = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
    const {backdropColor} = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius,
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
    renderText(
      ctx,
      scale._pointLabels[i],
      x,
      y + (plFont.lineHeight / 2),
      plFont,
      {
        color: optsAtIndex.color,
        textAlign: textAlign,
        textBaseline: 'middle'
      }
    );
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const {ctx} = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const {color, lineWidth} = gridLineOpts;
  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: 'pointLabel'
  });
}
class chart_RadialLinearScale extends chart_LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = undefined;
    this.yCenter = undefined;
    this.drawingArea = undefined;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const {min, max} = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    chart_LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels()
      .map((value, index) => {
        const label = callback(this.options.pointLabels.callback, [value, index], this);
        return label || label === 0 ? label : '';
      })
      .filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const {left, top, right, bottom} = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom,
    };
  }
  drawBackground() {
    const {backgroundColor, grid: {circular}} = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const {angleLines, grid} = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const {color, lineWidth} = optsAtIndex;
        if (!lineWidth || !color) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {}
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(
          -width / 2 - padding.left,
          -offset - tickFont.size / 2 - padding.top,
          width + padding.width,
          tickFont.size + padding.height
        );
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
      });
    });
    ctx.restore();
  }
  drawTitle() {}
}
chart_RadialLinearScale.id = 'radialLinear';
chart_RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: 'chartArea',
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0.0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: undefined,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
chart_RadialLinearScale.defaultRoutes = {
  'angleLines.color': 'borderColor',
  'pointLabels.color': 'color',
  'ticks.color': 'color'
};
chart_RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: 'grid'
  }
};

const INTERVALS = {
  millisecond: {common: true, size: 1, steps: 1000},
  second: {common: true, size: 1000, steps: 60},
  minute: {common: true, size: 60000, steps: 60},
  hour: {common: true, size: 3600000, steps: 24},
  day: {common: true, size: 86400000, steps: 30},
  week: {common: false, size: 604800000, steps: 4},
  month: {common: true, size: 2.628e9, steps: 12},
  quarter: {common: false, size: 7.884e9, steps: 4},
  year: {common: true, size: 3.154e10}
};
const UNITS = (Object.keys(INTERVALS));
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const {parser, round, isoWeekday} = scale._parseOpts;
  let value = input;
  if (typeof parser === 'function') {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === 'string'
      ? adapter.parse(value, parser)
      : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round) {
    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)
      ? adapter.startOf(value, 'isoWeek', isoWeekday)
      : adapter.startOf(value, round);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const {lo, hi} = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class chart_TimeScale extends chart_Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = 'day';
    this._majorUnit = undefined;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = undefined;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === undefined) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || 'day';
    let {min, max, minDefined, maxDefined} = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {min, max};
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === 'ticks' && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip
      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))
      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined
      : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map(tick => +tick.value));
    }
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {start, end, factor: 1 / (start + 1 + end)};
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
    }
    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === 'ticks' || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return (this._cache.data = metas[0].controller.getAllParsedValues(this));
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return (this._cache.data = this.normalize(timestamps));
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
chart_TimeScale.id = 'time';
chart_TimeScale.defaults = {
  bounds: 'data',
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: 'millisecond',
    displayFormats: {}
  },
  ticks: {
    source: 'auto',
    major: {
      enabled: false
    }
  }
};

function chart_interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({lo, hi} = _lookupByKey(table, 'pos', val));
    }
    ({pos: prevSource, time: prevTarget} = table[lo]);
    ({pos: nextSource, time: nextTarget} = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({lo, hi} = _lookupByKey(table, 'time', val));
    }
    ({time: prevSource, pos: prevTarget} = table[lo]);
    ({time: nextSource, pos: nextTarget} = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends chart_TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = undefined;
    this._tableRange = undefined;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = chart_interpolate(table, this.min);
    this._tableRange = chart_interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const {min, max} = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {time: min, pos: 0},
        {time: max, pos: 1}
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({time: curr, pos: i / (ilen - 1)});
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (chart_interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return chart_interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
TimeSeriesScale.id = 'timeseries';
TimeSeriesScale.defaults = chart_TimeScale.defaults;

var chart_scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: chart_CategoryScale,
LinearScale: chart_LinearScale,
LogarithmicScale: chart_LogarithmicScale,
RadialLinearScale: chart_RadialLinearScale,
TimeScale: chart_TimeScale,
TimeSeriesScale: TimeSeriesScale
});

const registerables = [
  controllers,
  chart_elements,
  chart_plugins,
  chart_scales,
];



// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/RevenueChart.vue?vue&type=script&lang=js&
function RevenueChartvue_type_script_lang_js_toConsumableArray(r) { return RevenueChartvue_type_script_lang_js_arrayWithoutHoles(r) || RevenueChartvue_type_script_lang_js_iterableToArray(r) || RevenueChartvue_type_script_lang_js_unsupportedIterableToArray(r) || RevenueChartvue_type_script_lang_js_nonIterableSpread(); }
function RevenueChartvue_type_script_lang_js_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function RevenueChartvue_type_script_lang_js_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return RevenueChartvue_type_script_lang_js_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? RevenueChartvue_type_script_lang_js_arrayLikeToArray(r, a) : void 0; } }
function RevenueChartvue_type_script_lang_js_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function RevenueChartvue_type_script_lang_js_arrayWithoutHoles(r) { if (Array.isArray(r)) return RevenueChartvue_type_script_lang_js_arrayLikeToArray(r); }
function RevenueChartvue_type_script_lang_js_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


chart_Chart.register.apply(chart_Chart, RevenueChartvue_type_script_lang_js_toConsumableArray(registerables));
/* harmony default export */ var RevenueChartvue_type_script_lang_js_ = ({
  name: 'RevenueChart',
  props: {
    chartData: {
      type: Array,
      "default": function _default() {
        return [];
      }
    }
  },
  data: function data() {
    return {
      chart: null,
      // to store Chart.js instance
      selectedMetric: 'discounts' // reactive property used in v-model
    };
  },
  mounted: function mounted() {
    this.renderChart();
  },
  watch: {
    chartData: {
      handler: function handler() {
        this.renderChart();
      },
      deep: true
    },
    selectedMetric: function selectedMetric() {
      this.renderChart();
    }
  },
  methods: {
    renderChart: function renderChart() {
      var _this = this;
      if (this.chart) this.chart.destroy();
      var ctx = this.$refs.chartCanvas.getContext('2d');
      var labels = this.chartData.map(function (item) {
        return item.label;
      });
      var metricMap = {
        discounts: {
          label: this.__('Discounts', 'easy-woocommerce-discounts'),
          color: 'rgba(59, 130, 246, 1)',
          fill: true
        },
        revenue: {
          label: this.__('Revenue', 'easy-woocommerce-discounts'),
          color: 'rgba(79, 70, 229, 1)',
          fill: true
        },
        orders: {
          label: this.__('Orders', 'easy-woocommerce-discounts'),
          color: 'rgba(16, 185, 129, 1)',
          fill: true
        },
        impressions: {
          label: this.__('Impressions', 'easy-woocommerce-discounts'),
          color: 'rgba(234, 179, 8, 1)',
          fill: true
        },
        rejections: {
          label: this.__('Rejections', 'easy-woocommerce-discounts'),
          color: 'rgba(197, 142, 229, 1)',
          fill: true
        },
        conversion_rate: {
          label: this.__('Conversion Rate (%)', 'easy-woocommerce-discounts'),
          color: 'rgba(239, 68, 68, 1)',
          fill: true
        }
      };
      var datasets = [];
      if (this.selectedMetric === 'all') {
        datasets = Object.keys(metricMap).map(function (key) {
          var config = metricMap[key];
          return {
            label: config.label,
            data: _this.chartData.map(function (item) {
              var _item$key;
              return (_item$key = item[key]) !== null && _item$key !== void 0 ? _item$key : 0;
            }),
            backgroundColor: config.fill ? config.color.replace('1)', '0.1)') : 'transparent',
            borderColor: config.color,
            borderWidth: 2,
            pointBackgroundColor: config.color,
            fill: false,
            tension: 0.3
          };
        });
      } else {
        var config = metricMap[this.selectedMetric];
        datasets = [{
          label: config.label,
          data: this.chartData.map(function (item) {
            var _item$_this$selectedM;
            return (_item$_this$selectedM = item[_this.selectedMetric]) !== null && _item$_this$selectedM !== void 0 ? _item$_this$selectedM : 0;
          }),
          backgroundColor: config.fill ? config.color.replace('1)', '0.1)') : 'transparent',
          borderColor: config.color,
          borderWidth: 2,
          pointBackgroundColor: config.color,
          fill: config.fill,
          tension: 0.3
        }];
      }
      this.chart = new chart_Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function (value) {
                  if ('revenue' === this.selectedMetric || 'discounts' === this.selectedMetric) {
                    return '$' + value.toLocaleString();
                  } else if (this.selectedMetric === 'conversion_rate') {
                    return value + '%';
                  }
                  return value;
                }.bind(this)
              }
            }
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/RevenueChart.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_RevenueChartvue_type_script_lang_js_ = (RevenueChartvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/RevenueChart.vue





/* normalize component */

var RevenueChart_component = Object(componentNormalizer["a" /* default */])(
  components_RevenueChartvue_type_script_lang_js_,
  RevenueChartvue_type_template_id_18655a58_render,
  RevenueChartvue_type_template_id_18655a58_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var RevenueChart = (RevenueChart_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/CampaignTable.vue?vue&type=template&id=c4cecfac&
var CampaignTablevue_type_template_id_c4cecfac_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-border-0 asnp-shadow-lg asnp-rounded-2xl asnp-bg-white"},[_c('div',{staticClass:"asnp-p-4"},[_c('h2',{staticClass:"asnp-text-xl asnp-font-semibold asnp-text-gray-900"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__(
					'Best Performing Campaigns',
					'easy-woocommerce-discounts'
				))+"\n\t\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-text-sm asnp-text-gray-600"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__(
					'Performance metrics for marketing campaigns',
					'easy-woocommerce-discounts'
				))+"\n\t\t")])]),_vm._v(" "),(_vm.loading || _vm.campaigns.length)?_c('div',{staticClass:"asnp-p-4"},[_c('div',{staticClass:"asnp-rounded-lg asnp-border asnp-border-gray-100 asnp-overflow-hidden"},[_c('table',{staticClass:"asnp-min-w-full asnp-divide-y asnp-divide-gray-200 asnp-text-sm"},[_c('thead',{staticClass:"asnp-bg-gray-50"},[_c('tr',[_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Campaign',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Impressions',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Conversions',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Conv. Rate',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Discounts',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__( 'Fees', 'easy-woocommerce-discounts' ))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Shipping Discounts',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('th',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-left asnp-font-medium asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Free Shippings',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")])])]),_vm._v(" "),_c('tbody',{staticClass:"asnp-divide-y asnp-divide-gray-100"},[(_vm.loading)?_vm._l((_vm.per_page),function(i){return _c('tr',{key:i},_vm._l((8),function(col){return _c('th',{key:col,staticClass:"asnp-px-4 asnp-py-2"},[_c('div',{staticClass:"asnp-h-4 asnp-bg-gray-200 asnp-rounded-md asnp-w-24 asnp-animate-pulse"})])}),0)}):_vm._l((_vm.campaigns),function(campaign,index){return _c('tr',{key:index,staticClass:"hover:asnp-bg-gray-50 asnp-transition-colors"},[_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-font-medium asnp-text-gray-900"},[_c('router-link',{staticClass:"hover:asnp-text-indigo-500 focus:asnp-outline-none focus:asnp-shadow-none",attrs:{"to":'cart-discount' === campaign.type
										? '/discount/' + campaign.rule_id
										: '/' +
										  campaign.type +
										  '/' +
										  campaign.rule_id}},[_vm._v(_vm._s(campaign.name))])],1),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(parseInt(
									campaign.impressions
								).toLocaleString())+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-text-gray-700"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(parseInt( campaign.orders ).toLocaleString())+"\n\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-font-medium asnp-text-emerald-600"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(parseFloat( campaign.conversion_rate ))+"%\n\t\t\t\t\t\t")]),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-font-medium asnp-text-blue-600",domProps:{"innerHTML":_vm._s(_vm.renderValue( campaign.discounts ))}}),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-font-medium asnp-text-blue-600",domProps:{"innerHTML":_vm._s(_vm.renderValue( campaign.fees ))}}),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-font-semibold asnp-text-gray-900",domProps:{"innerHTML":_vm._s(
								_vm.renderValue( campaign.shipping_discounts )
							)}}),_vm._v(" "),_c('td',{staticClass:"asnp-px-4 asnp-py-2 asnp-font-medium asnp-text-blue-600",domProps:{"innerHTML":_vm._s(_vm.renderValue( campaign.free_shippings ))}})])})],2)])]),_vm._v(" "),(1 < _vm.pages)?_c('Pagination',{attrs:{"current":_vm.page,"total":_vm.pages,"nextText":_vm.__( 'Next', 'easy-woocommerce-discounts' ),"prevText":_vm.__( 'Prev', 'easy-woocommerce-discounts' ),"disabled":_vm.loading},on:{"setPage":function ( p ) { return ( _vm.page = p ); }}}):_vm._e()],1):_c('p',{staticClass:"asnp-p-4"},[_vm._v("\n\t\t"+_vm._s(_vm.__(
				'There is no data available.',
				'easy-woocommerce-discounts'
			))+"\n\t")])])}
var CampaignTablevue_type_template_id_c4cecfac_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/CampaignTable.vue?vue&type=template&id=c4cecfac&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Pagination/index.vue?vue&type=template&id=1ba6050f&scoped=true&
var Paginationvue_type_template_id_1ba6050f_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.total)?_c('div',{staticClass:"asnp-product-pagination asnp-flex asnp-justify-center asnp-items-center asnp-px-4 asnp-pt-4"},[_vm._l((_vm.pages),function(p){return _c('Page',{key:p.key,class:p.className,attrs:{"is-current":p.isCurrent,"page-key":p.key,"onClick":p.onClick,"disabled":_vm.disabled}},[_vm._v("\n\t\t"+_vm._s(p.text)+"\n\t")])}),_vm._v(" "),_c('span',{staticClass:"asnp-text-gray-500 asnp-px-2"},[_vm._v("\n\t\t"+_vm._s(_vm.__( 'Page', 'easy-woocommerce-discounts' ))+"\n\t\t"+_vm._s(_vm.current)+"\n\t\t"+_vm._s(_vm.__( 'of', 'easy-woocommerce-discounts' ))+"\n\t\t"+_vm._s(_vm.total)+"\n\t")])],2):_vm._e()}
var Paginationvue_type_template_id_1ba6050f_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Pagination/index.vue?vue&type=template&id=1ba6050f&scoped=true&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Pagination/Page.vue?vue&type=template&id=ab3c075e&
var Pagevue_type_template_id_ab3c075e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{class:_vm.buttonClass,attrs:{"disabled":_vm.disabled},on:{"click":_vm.onClick}},[(_vm.pageKey === 'prev')?_c('span',{staticClass:"dashicons dashicons-arrow-left-alt2"}):_vm._e(),_vm._v(" "),_vm._t("default"),_vm._v(" "),(_vm.pageKey === 'next')?_c('span',{staticClass:"dashicons dashicons-arrow-right-alt2"}):_vm._e()],2)}
var Pagevue_type_template_id_ab3c075e_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Pagination/Page.vue?vue&type=template&id=ab3c075e&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Pagination/Page.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Pagevue_type_script_lang_js_ = ({
  name: 'Page',
  props: {
    isCurrent: {
      type: Boolean,
      "default": false
    },
    pageKey: {
      type: [String, Number],
      required: true
    },
    onClick: {
      type: Function,
      required: true
    },
    className: {
      type: String,
      "default": ''
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  computed: {
    buttonClass: function buttonClass() {
      return this.isCurrent ? "".concat(this.className, " current") : this.className;
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Pagination/Page.vue?vue&type=script&lang=js&
 /* harmony default export */ var Pagination_Pagevue_type_script_lang_js_ = (Pagevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Pagination/Page.vue





/* normalize component */

var Page_component = Object(componentNormalizer["a" /* default */])(
  Pagination_Pagevue_type_script_lang_js_,
  Pagevue_type_template_id_ab3c075e_render,
  Pagevue_type_template_id_ab3c075e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Page = (Page_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Pagination/index.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var Paginationvue_type_script_lang_js_ = ({
  name: 'Pagination',
  components: {
    Page: Page
  },
  props: {
    current: {
      type: Number,
      required: true
    },
    total: {
      type: Number,
      required: true
    },
    endSize: {
      type: Number,
      "default": 1
    },
    midSize: {
      type: Number,
      "default": 2
    },
    nextText: {
      type: String,
      "default": 'Next'
    },
    prevText: {
      type: String,
      "default": 'Prev'
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  computed: {
    pages: function pages() {
      var _this = this;
      var endSize = this.endSize < 1 ? 1 : this.endSize;
      var midSize = this.midSize < 0 ? 2 : this.midSize;
      var pages = [];
      var dots = false;
      if (this.current > 1) {
        pages.push({
          isCurrent: false,
          key: 'prev',
          onClick: function onClick() {
            return _this.$emit('setPage', _this.current - 1);
          },
          className: 'asnp-pagination-prev',
          text: this.prevText
        });
      }
      var _loop = function _loop(n) {
        var isCurrent = n === _this.current;
        if (isCurrent) {
          dots = true;
          pages.push({
            isCurrent: true,
            key: n,
            onClick: function onClick() {
              return _this.$emit('setPage', n);
            },
            className: 'asnp-pages',
            text: n
          });
        } else {
          if (n <= endSize || n >= _this.current - midSize && n <= _this.current + midSize || n > _this.total - endSize) {
            pages.push({
              isLink: true,
              key: n,
              onClick: function onClick() {
                return _this.$emit('setPage', n);
              },
              className: 'asnp-pages',
              text: n
            });
            dots = true;
          } else if (dots) {
            pages.push({
              isDots: true,
              key: "dots-".concat(n),
              onClick: function onClick() {},
              className: 'asnp-pages',
              text: '...'
            });
            dots = false;
          }
        }
      };
      for (var n = 1; n <= this.total; n++) {
        _loop(n);
      }
      if (this.current < this.total) {
        pages.push({
          isCurrent: false,
          key: 'next',
          onClick: function onClick() {
            return _this.$emit('setPage', _this.current + 1);
          },
          className: 'asnp-pagination-next',
          text: this.nextText
        });
      }
      return pages;
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Pagination/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Paginationvue_type_script_lang_js_ = (Paginationvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/components/Pagination/index.vue?vue&type=style&index=0&id=1ba6050f&lang=scss&scoped=true&
var Paginationvue_type_style_index_0_id_1ba6050f_lang_scss_scoped_true_ = __webpack_require__(141);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Pagination/index.vue






/* normalize component */

var Pagination_component = Object(componentNormalizer["a" /* default */])(
  components_Paginationvue_type_script_lang_js_,
  Paginationvue_type_template_id_1ba6050f_scoped_true_render,
  Paginationvue_type_template_id_1ba6050f_scoped_true_staticRenderFns,
  false,
  null,
  "1ba6050f",
  null
  
)

/* harmony default export */ var Pagination = (Pagination_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/CampaignTable.vue?vue&type=script&lang=js&
function CampaignTablevue_type_script_lang_js_regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return CampaignTablevue_type_script_lang_js_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (CampaignTablevue_type_script_lang_js_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, CampaignTablevue_type_script_lang_js_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, CampaignTablevue_type_script_lang_js_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), CampaignTablevue_type_script_lang_js_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", CampaignTablevue_type_script_lang_js_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), CampaignTablevue_type_script_lang_js_regeneratorDefine2(u), CampaignTablevue_type_script_lang_js_regeneratorDefine2(u, o, "Generator"), CampaignTablevue_type_script_lang_js_regeneratorDefine2(u, n, function () { return this; }), CampaignTablevue_type_script_lang_js_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (CampaignTablevue_type_script_lang_js_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function CampaignTablevue_type_script_lang_js_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } CampaignTablevue_type_script_lang_js_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { CampaignTablevue_type_script_lang_js_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, CampaignTablevue_type_script_lang_js_regeneratorDefine2(e, r, n, t); }
function CampaignTablevue_type_script_lang_js_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function CampaignTablevue_type_script_lang_js_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { CampaignTablevue_type_script_lang_js_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { CampaignTablevue_type_script_lang_js_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var CampaignTablevue_type_script_lang_js_ = ({
  name: 'CampaignTable',
  components: {
    Pagination: Pagination
  },
  data: function data() {
    return {
      page: 1,
      per_page: 10,
      pages: 1,
      campaigns: [],
      loading: false
    };
  },
  props: {
    range: {
      type: String,
      "default": 'last_week'
    },
    customRange: {
      type: Object,
      "default": function _default() {
        return {
          start: {
            time: ''
          },
          end: {
            time: ''
          }
        };
      }
    }
  },
  mounted: function mounted() {
    this.getCampaigns();
  },
  methods: {
    isHtml: function isHtml(value) {
      return typeof value === 'string' && /<[^>]+>/.test(value);
    },
    renderValue: function renderValue(value) {
      return this.isHtml(value) ? value : value;
    },
    getCampaigns: function getCampaigns() {
      var _arguments = arguments,
        _this = this;
      return CampaignTablevue_type_script_lang_js_asyncToGenerator(/*#__PURE__*/CampaignTablevue_type_script_lang_js_regenerator().m(function _callee() {
        var page, params, response, _t;
        return CampaignTablevue_type_script_lang_js_regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              page = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : 1;
              _context.p = 1;
              params = _this.getDateRange(_this.range, _this.customRange);
              if (!(!(params !== null && params !== void 0 && params.start_date) || !(params !== null && params !== void 0 && params.end_date))) {
                _context.n = 2;
                break;
              }
              return _context.a(2);
            case 2:
              params.page = 0 < page ? page : 1;
              params.per_page = _this.per_page;
              _this.loading = true;
              _context.n = 3;
              return getBestPerforming(params);
            case 3:
              response = _context.v;
              if (response) {
                _this.campaigns = (response === null || response === void 0 ? void 0 : response.items) || [];
                _this.pages = (response === null || response === void 0 ? void 0 : response.pages) || 1;
                _this.page = params.page * 1;
              } else {
                _this.campaigns = [];
                _this.page = 1;
                _this.pages = 1;
              }
              _this.loading = false;
              _context.n = 5;
              break;
            case 4:
              _context.p = 4;
              _t = _context.v;
            case 5:
              return _context.a(2);
          }
        }, _callee, null, [[1, 4]]);
      }))();
    }
  },
  watch: {
    range: function range(value) {
      if (this.loading) {
        return;
      }
      if ('custom' === value) {
        var _this$customRange, _this$customRange$sta, _this$customRange2, _this$customRange2$en;
        if (!((_this$customRange = this.customRange) !== null && _this$customRange !== void 0 && (_this$customRange$sta = _this$customRange.start) !== null && _this$customRange$sta !== void 0 && _this$customRange$sta.time) || !((_this$customRange2 = this.customRange) !== null && _this$customRange2 !== void 0 && (_this$customRange2$en = _this$customRange2.end) !== null && _this$customRange2$en !== void 0 && _this$customRange2$en.time)) {
          return;
        }
      }
      this.getCampaigns(1);
    },
    customRange: {
      handler: function handler() {
        var _this$customRange$sta2, _this$customRange$end;
        if ((_this$customRange$sta2 = this.customRange.start) !== null && _this$customRange$sta2 !== void 0 && _this$customRange$sta2.time && (_this$customRange$end = this.customRange.end) !== null && _this$customRange$end !== void 0 && _this$customRange$end.time) {
          this.getCampaigns(1);
        }
      },
      deep: true
    },
    page: function page(value) {
      if (!this.loading) {
        this.getCampaigns(value);
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/CampaignTable.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_CampaignTablevue_type_script_lang_js_ = (CampaignTablevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/CampaignTable.vue





/* normalize component */

var CampaignTable_component = Object(componentNormalizer["a" /* default */])(
  components_CampaignTablevue_type_script_lang_js_,
  CampaignTablevue_type_template_id_c4cecfac_render,
  CampaignTablevue_type_template_id_c4cecfac_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CampaignTable = (CampaignTable_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/views/Analytics.vue?vue&type=script&lang=js&
function Analyticsvue_type_script_lang_js_regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return Analyticsvue_type_script_lang_js_regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (Analyticsvue_type_script_lang_js_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, Analyticsvue_type_script_lang_js_regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, Analyticsvue_type_script_lang_js_regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), Analyticsvue_type_script_lang_js_regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", Analyticsvue_type_script_lang_js_regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), Analyticsvue_type_script_lang_js_regeneratorDefine2(u), Analyticsvue_type_script_lang_js_regeneratorDefine2(u, o, "Generator"), Analyticsvue_type_script_lang_js_regeneratorDefine2(u, n, function () { return this; }), Analyticsvue_type_script_lang_js_regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (Analyticsvue_type_script_lang_js_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function Analyticsvue_type_script_lang_js_regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } Analyticsvue_type_script_lang_js_regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { Analyticsvue_type_script_lang_js_regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, Analyticsvue_type_script_lang_js_regeneratorDefine2(e, r, n, t); }
function Analyticsvue_type_script_lang_js_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function Analyticsvue_type_script_lang_js_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { Analyticsvue_type_script_lang_js_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { Analyticsvue_type_script_lang_js_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//







/* harmony default export */ var Analyticsvue_type_script_lang_js_ = ({
  name: 'analytics',
  components: {
    MetricCard: MetricCard,
    RevenueChart: RevenueChart,
    CampaignTable: CampaignTable,
    Select2: Select2
  },
  mixins: [DateTimeMixin],
  data: function data() {
    var _this$$route, _this$$route$params;
    var rule = (_this$$route = this.$route) !== null && _this$$route !== void 0 && (_this$$route$params = _this$$route.params) !== null && _this$$route$params !== void 0 && _this$$route$params.id ? parseInt(this.$route.params.id) : null;
    return {
      totals: {},
      chartData: [],
      loading: false,
      range: 'last_week',
      rule: rule,
      rangeOptions: [{
        label: this.__('Today', 'easy-woocommerce-discounts'),
        value: 'today'
      }, {
        label: this.__('Last 7 Days', 'easy-woocommerce-discounts'),
        value: 'last_week'
      }, {
        label: this.__('This Month', 'easy-woocommerce-discounts'),
        value: 'this_month'
      }, {
        label: this.__('Last Month', 'easy-woocommerce-discounts'),
        value: 'last_month'
      }, {
        label: this.__('This Year', 'easy-woocommerce-discounts'),
        value: 'this_year'
      }, {
        label: this.__('Last Year', 'easy-woocommerce-discounts'),
        value: 'last_year'
      }, {
        label: this.__('Custom', 'easy-woocommerce-discounts'),
        value: 'custom'
      }],
      customRange: {
        start: {
          time: ''
        },
        end: {
          time: ''
        }
      }
    };
  },
  mounted: function mounted() {
    this.getAnalytics();
  },
  computed: {
    metrics: function metrics() {
      var _this = this;
      var config = {
        // --- Sales Performance ---
        revenue: {
          title: this.__('Total Sales', 'easy-woocommerce-discounts'),
          description: this.__('Total sales made by rules/rule', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-green-500 asnp-to-green-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" ><line x1="12" x2="12" y1="2" y2="22"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>'
        },
        net_revenue: {
          title: this.__('Net Sales', 'easy-woocommerce-discounts'),
          description: this.__('Net sales made by rules/rule', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-green-500 asnp-to-green-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" ><line x1="12" x2="12" y1="2" y2="22"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>'
        },
        orders: {
          title: this.__('Orders', 'easy-woocommerce-discounts'),
          description: this.__('Orders placed with rules/rule', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-blue-500 asnp-to-blue-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-text-icon lucide-file-text"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/></svg>'
        },
        avg_order_value: {
          title: this.__('Average Order Value', 'easy-woocommerce-discounts'),
          description: this.__('Average order value made by rules/rule', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-green-400 asnp-to-green-500',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" ><line x1="12" x2="12" y1="2" y2="22"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>'
        },
        conversion_rate: {
          title: this.__('Conversion Rate', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-purple-500 asnp-to-purple-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" ><line x1="19" x2="5" y1="5" y2="19"/><circle cx="6.5" cy="6.5" r="2.5"/><circle cx="17.5" cy="17.5" r="2.5"/></svg>'
        },
        // --- Discounts & Promotions ---
        discounts: {
          title: this.__('Total Discounts', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-red-500 asnp-to-red-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-tags-icon lucide-tags"><path d="M13.172 2a2 2 0 0 1 1.414.586l6.71 6.71a2.4 2.4 0 0 1 0 3.408l-4.592 4.592a2.4 2.4 0 0 1-3.408 0l-6.71-6.71A2 2 0 0 1 6 9.172V3a1 1 0 0 1 1-1z"/><path d="M2 7v6.172a2 2 0 0 0 .586 1.414l6.71 6.71a2.4 2.4 0 0 0 3.191.193"/><circle cx="10.5" cy="6.5" r=".5" fill="currentColor"/></svg>'
        },
        items_discounted: {
          title: this.__('Items Discounted', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-indigo-500 asnp-to-indigo-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-tag-icon lucide-tag"><path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"/><circle cx="7.5" cy="7.5" r=".5" fill="currentColor"/></svg>'
        },
        shipping_discounts: {
          title: this.__('Shipping Discounts', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-rose-500 asnp-to-rose-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-truck-icon lucide-truck"><path d="M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2"/><path d="M15 18H9"/><path d="M19 18h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.624l-3.48-4.35A1 1 0 0 0 17.52 8H14"/><circle cx="17" cy="18" r="2"/><circle cx="7" cy="18" r="2"/></svg>'
        },
        free_shippings: {
          title: this.__('Free Shippings', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-purple-500 asnp-to-purple-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-truck-electric-icon lucide-truck-electric"><path d="M14 19V7a2 2 0 0 0-2-2H9"/><path d="M15 19H9"/><path d="M19 19h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.62L18.3 9.38a1 1 0 0 0-.78-.38H14"/><path d="M2 13v5a1 1 0 0 0 1 1h2"/><path d="M4 3 2.15 5.15a.495.495 0 0 0 .35.86h2.15a.47.47 0 0 1 .35.86L3 9.02"/><circle cx="17" cy="19" r="2"/><circle cx="7" cy="19" r="2"/></svg>'
        },
        // --- Costs ---
        fees: {
          title: this.__('Fees', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-yellow-500 asnp-to-yellow-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>'
        },
        // --- Customer Journey ---
        impressions: {
          title: this.__('Impressions', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-rose-400 asnp-to-rose-500',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sparkles-icon lucide-sparkles"><path d="M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z"/><path d="M20 2v4"/><path d="M22 4h-4"/><circle cx="4" cy="20" r="2"/></svg>'
        },
        add_to_cart: {
          title: this.__('Add to Cart', 'easy-woocommerce-discounts'),
          description: this.__('Rules/Rule applied to the cart count', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-purple-500 asnp-to-purple-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shopping-basket-icon lucide-shopping-basket"><path d="m15 11-1 9"/><path d="m19 11-4-7"/><path d="M2 11h20"/><path d="m3.5 11 1.6 7.4a2 2 0 0 0 2 1.6h9.8a2 2 0 0 0 2-1.6l1.7-7.4"/><path d="M4.5 15.5h15"/><path d="m5 11 4-7"/><path d="m9 11 1 9"/></svg>'
        },
        checkouts: {
          title: this.__('Checkouts', 'easy-woocommerce-discounts'),
          description: this.__('Rules/Rule applied to the checkout count', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-indigo-500 asnp-to-indigo-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shopping-cart-icon lucide-shopping-cart"><circle cx="8" cy="21" r="1"/><circle cx="19" cy="21" r="1"/><path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12"/></svg>'
        },
        rejections: {
          title: this.__('Rejections', 'easy-woocommerce-discounts'),
          gradient: 'asnp-bg-gradient-to-r asnp-from-gray-500 asnp-to-gray-600',
          icon: '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>'
        }
      };
      return Object.keys(config).map(function (key) {
        var _this$totals, _this$totals2, _this$totals2$growth, _this$totals3, _this$totals3$growth, _this$totals4, _this$totals4$growth;
        var c = config[key];
        return {
          title: c.title,
          value: ((_this$totals = _this.totals) === null || _this$totals === void 0 ? void 0 : _this$totals[key]) || 0.0,
          change: parseFloat(((_this$totals2 = _this.totals) === null || _this$totals2 === void 0 ? void 0 : (_this$totals2$growth = _this$totals2.growth) === null || _this$totals2$growth === void 0 ? void 0 : _this$totals2$growth[key]) || 0),
          message: ((_this$totals3 = _this.totals) === null || _this$totals3 === void 0 ? void 0 : (_this$totals3$growth = _this$totals3.growth) === null || _this$totals3$growth === void 0 ? void 0 : _this$totals3$growth.message) || '',
          changeType: parseFloat(((_this$totals4 = _this.totals) === null || _this$totals4 === void 0 ? void 0 : (_this$totals4$growth = _this$totals4.growth) === null || _this$totals4$growth === void 0 ? void 0 : _this$totals4$growth[key]) || 0) >= 0 ? 'positive' : 'negative',
          gradient: c.gradient || 'asnp-bg-white',
          icon: c.icon || '',
          isPercentage: key === 'conversion_rate',
          description: (c === null || c === void 0 ? void 0 : c.description) || ''
        };
      });
    }
  },
  methods: {
    getAnalytics: function getAnalytics() {
      var _this2 = this;
      return Analyticsvue_type_script_lang_js_asyncToGenerator(/*#__PURE__*/Analyticsvue_type_script_lang_js_regenerator().m(function _callee() {
        var params, _t;
        return Analyticsvue_type_script_lang_js_regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              params = _this2.getDateRange(_this2.range, _this2.customRange);
              if (!(!(params !== null && params !== void 0 && params.start_date) || !(params !== null && params !== void 0 && params.end_date))) {
                _context.n = 1;
                break;
              }
              return _context.a(2);
            case 1:
              if (_this2.rule && 0 < _this2.rule) {
                params.rule_id = _this2.rule;
              }
              _this2.loading = true;
              _context.n = 2;
              return _this2.getTotals(params);
            case 2:
              _context.n = 3;
              return _this2.getChartData(params);
            case 3:
              _context.n = 5;
              break;
            case 4:
              _context.p = 4;
              _t = _context.v;
              _this2.$store.commit('message/setMessage', {
                message: _t.message,
                type: 'error'
              });
            case 5:
              _context.p = 5;
              _this2.loading = false;
              return _context.f(5);
            case 6:
              return _context.a(2);
          }
        }, _callee, null, [[0, 4, 5, 6]]);
      }))();
    },
    getTotals: function getTotals(params) {
      var _this3 = this;
      return Analyticsvue_type_script_lang_js_asyncToGenerator(/*#__PURE__*/Analyticsvue_type_script_lang_js_regenerator().m(function _callee2() {
        var response;
        return Analyticsvue_type_script_lang_js_regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return analytics_getTotals(params);
            case 1:
              response = _context2.v;
              if (response) {
                _this3.totals = response;
              } else {
                _this3.totals = {};
              }
            case 2:
              return _context2.a(2);
          }
        }, _callee2);
      }))();
    },
    getChartData: function getChartData(params) {
      var _this4 = this;
      return Analyticsvue_type_script_lang_js_asyncToGenerator(/*#__PURE__*/Analyticsvue_type_script_lang_js_regenerator().m(function _callee3() {
        var response;
        return Analyticsvue_type_script_lang_js_regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return analytics_getChartData(params);
            case 1:
              response = _context3.v;
              if (response) {
                _this4.chartData = Object.keys(response).map(function (date) {
                  var _response$date, _response$date2, _response$date3, _response$date4, _response$date5, _response$date6, _response$date7;
                  return {
                    label: date,
                    revenue: ((_response$date = response[date]) === null || _response$date === void 0 ? void 0 : _response$date.revenue) || 0,
                    orders: ((_response$date2 = response[date]) === null || _response$date2 === void 0 ? void 0 : _response$date2.orders) || 0,
                    impressions: ((_response$date3 = response[date]) === null || _response$date3 === void 0 ? void 0 : _response$date3.impressions) || 0,
                    rejections: ((_response$date4 = response[date]) === null || _response$date4 === void 0 ? void 0 : _response$date4.rejections) || 0,
                    discounts: ((_response$date5 = response[date]) === null || _response$date5 === void 0 ? void 0 : _response$date5.discounts) || 0,
                    conversion_rate: (_response$date6 = response[date]) !== null && _response$date6 !== void 0 && _response$date6.orders && (_response$date7 = response[date]) !== null && _response$date7 !== void 0 && _response$date7.impressions ? (response[date].orders / response[date].impressions * 100).toFixed(2) : 0
                  };
                });
              } else {
                _this4.chartData = [];
              }
            case 2:
              return _context3.a(2);
          }
        }, _callee3);
      }))();
    }
  },
  watch: {
    range: function range(value) {
      if ('custom' === value) {
        var _this$customRange, _this$customRange$sta, _this$customRange2, _this$customRange2$en;
        if (!((_this$customRange = this.customRange) !== null && _this$customRange !== void 0 && (_this$customRange$sta = _this$customRange.start) !== null && _this$customRange$sta !== void 0 && _this$customRange$sta.time) || !((_this$customRange2 = this.customRange) !== null && _this$customRange2 !== void 0 && (_this$customRange2$en = _this$customRange2.end) !== null && _this$customRange2$en !== void 0 && _this$customRange2$en.time)) {
          return this.$store.commit('message/setMessage', {
            message: this.__('Please set a start and end date.', 'easy-woocommerce-discounts'),
            type: 'info'
          });
        }
      }
      this.getAnalytics();
    },
    customRange: {
      handler: function handler() {
        var _this$customRange$sta2, _this$customRange$end;
        if ((_this$customRange$sta2 = this.customRange.start) !== null && _this$customRange$sta2 !== void 0 && _this$customRange$sta2.time && (_this$customRange$end = this.customRange.end) !== null && _this$customRange$end !== void 0 && _this$customRange$end.time) {
          this.getAnalytics();
        }
      },
      deep: true
    },
    rule: function rule() {
      this.getAnalytics();
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Analytics.vue?vue&type=script&lang=js&
 /* harmony default export */ var views_Analyticsvue_type_script_lang_js_ = (Analyticsvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/views/Analytics.vue?vue&type=style&index=0&lang=scss&
var Analyticsvue_type_style_index_0_lang_scss_ = __webpack_require__(142);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/views/Analytics.vue






/* normalize component */

var Analytics_component = Object(componentNormalizer["a" /* default */])(
  views_Analyticsvue_type_script_lang_js_,
  Analyticsvue_type_template_id_3da28b20_render,
  Analyticsvue_type_template_id_3da28b20_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Analytics = (Analytics_component.exports);
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/router/index.js















// import GoPro from '../views/GoPro.vue';

external_Vue_default.a.use(external_VueRouter_default.a);
var router_registerRoutes = function registerRoutes() {
  var routes = Object(external_this_wp_hooks_["applyFilters"])('wccs_routes', [{
    path: '/',
    name: 'home',
    component: DiscountList
  }, {
    path: '/products-list',
    name: 'products-list',
    component: ProductsList
  }, {
    path: '/products/:id',
    name: 'products',
    component: ProductsView
  }, {
    path: '/discount-list',
    name: 'discount-list',
    component: DiscountList
  }, {
    path: '/discount/:id',
    name: 'discount',
    component: DiscountView
  }, {
    path: '/pricing-list',
    name: 'pricing-list',
    component: PricingList
  }, {
    path: '/pricing/:id',
    name: 'pricing',
    component: PricingView
  }, {
    path: '/checkout-fee-list',
    name: 'checkout-fee-list',
    component: CheckoutFeeList
  }, {
    path: '/shipping-list',
    name: 'shipping-list',
    component: ShippingList
  }, {
    path: '/shipping/:id',
    name: 'shipping',
    component: Shipping
  }, {
    path: '/addons',
    name: 'addons',
    component: Addons
  }, {
    path: '/analytics',
    name: 'analytics',
    component: Analytics
  }, {
    path: '/analytics/:id',
    name: 'analytics',
    component: Analytics
  }
  // {
  // 	path: '/go-pro',
  // 	name: 'go-pro',
  // 	component: GoPro,
  // },
  ]);
  routes.map(function (route) {
    Object(external_this_ewd_pages_["registerRoute"])(route);
  });
};
router_registerRoutes();
/* harmony default export */ var router = (new external_VueRouter_default.a({
  routes: Object(external_this_ewd_pages_["getRoutes"])()
}));
// EXTERNAL MODULE: external "vuelidate"
var external_vuelidate_ = __webpack_require__(68);
var external_vuelidate_default = /*#__PURE__*/__webpack_require__.n(external_vuelidate_);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/App.vue?vue&type=template&id=ed0c929a&
var Appvue_type_template_id_ed0c929a_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-app",attrs:{"id":"wc-conditions-app"}},[_c('div',{staticClass:"asnp-bg-white"},[_c('nav',{staticClass:"asnp-flex asnp-flex-col md:asnp-flex-row"},[_vm._l((_vm.tabs),function(tab){return _c('router-link',{key:tab.name,staticClass:"asnp-nav-tab-item",attrs:{"to":tab.route,"active-class":"asnp-nav-tab-active","exact":'/' === tab.route}},[_vm._v(_vm._s(tab.name))])}),_vm._v(" "),_c('a',{staticClass:"asnp-nav-go-pro",attrs:{"href":"https://www.asanaplugins.com/product/woocommerce-dynamic-pricing-and-discounts-plugin/?utm_source=easy-woocommerce-discounts-free&utm_campaign=easy-woocommerce-discounts&utm_medium=link","target":"_blank"}},[_vm._v(_vm._s(_vm.__(
						'Go PRO UP to 75% OFF',
						'easy-woocommerce-discount'
					)))]),_vm._v(" "),_c('a',{staticClass:"asnp-nav-rose",attrs:{"href":"https://pricing-and-discounts.asanaplugins.com/","target":"_blank"}},[_vm._v(_vm._s(_vm.__( 'Try PRO', 'easy-woocommerce-discount' )))]),_vm._v(" "),_c('a',{staticClass:"asnp-nav-tab-action",attrs:{"href":"https://wordpress.org/support/plugin/easy-woocommerce-discounts/","target":"_blank"}},[_vm._v(_vm._s(_vm.__( 'Need help?', 'easy-woocommerce-discount' )))]),_vm._v(" "),_c('a',{staticClass:"asnp-nav-tab-action",attrs:{"href":"https://wordpress.org/support/plugin/easy-woocommerce-discounts/","target":"_blank"}},[_vm._v(_vm._s(_vm.__( 'Have an Idea?', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('a',{staticClass:"asnp-nav-tab-action",attrs:{"href":"https://wordpress.org/plugins/easy-woocommerce-discounts/reviews/","target":"_blank"}},[_vm._v(_vm._s(_vm.__( '5-Star Review', 'easy-woocommerce-discounts' )))])],2)]),_vm._v(" "),_c('black-friday'),_vm._v(" "),_c('Snackbar'),_vm._v(" "),_c('transition',{attrs:{"name":"fade","mode":"out-in"}},[_c('router-view',{staticClass:"asnp-view"})],1)],1)}
var Appvue_type_template_id_ed0c929a_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/App.vue?vue&type=template&id=ed0c929a&

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Snackbar/index.vue?vue&type=template&id=7885c5dd&
var Snackbarvue_type_template_id_7885c5dd_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.show && _vm.message.length)?_c('div',{staticClass:"asnp-snackbar asnp-flex asnp-flex-col asnp-justify-center asnp-fixed"},[_c('div',{staticClass:"asnp-flex asnp-items-center asnp-w-full asnp-max-w-xs asnp-p-4 asnp-mb-4 asnp-text-gray-500 asnp-bg-white asnp-rounded-lg asnp-shadow",attrs:{"id":"toast-success","role":"alert"}},[_c('div',{class:_vm.classes},[_c('svg',{staticClass:"asnp-w-5 asnp-h-5",attrs:{"fill":"currentColor","viewBox":"0 0 20 20","xmlns":"http://www.w3.org/2000/svg"}},[_c('path',{attrs:{"fillRule":"evenodd","d":_vm.path,"clipRule":"evenodd"}})])]),_vm._v(" "),_c('div',{staticClass:"asnp-ml-3 asnp-text-sm asnp-font-normal"},[_vm._v("\n\t\t\t"+_vm._s(_vm.message)+"\n\t\t")])])]):_vm._e()}
var Snackbarvue_type_template_id_7885c5dd_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Snackbar/index.vue?vue&type=template&id=7885c5dd&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Snackbar/index.vue?vue&type=script&lang=js&
function Snackbarvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return Snackbarvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Snackbarvue_type_script_lang_js_typeof(o); }
function Snackbarvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function Snackbarvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? Snackbarvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { Snackbarvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : Snackbarvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function Snackbarvue_type_script_lang_js_defineProperty(e, r, t) { return (r = Snackbarvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function Snackbarvue_type_script_lang_js_toPropertyKey(t) { var i = Snackbarvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == Snackbarvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function Snackbarvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != Snackbarvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != Snackbarvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var Snackbarvue_type_script_lang_js_ = ({
  name: 'Snackbar',
  computed: Snackbarvue_type_script_lang_js_objectSpread(Snackbarvue_type_script_lang_js_objectSpread({}, Object(external_Vuex_["mapState"])({
    message: function message(state) {
      return state.message.message;
    },
    type: function type(state) {
      return state.message.type;
    },
    show: function show(state) {
      return state.message.show;
    }
  })), {}, {
    classes: function classes() {
      var value = 'asnp-inline-flex asnp-items-center asnp-justify-center asnp-flex-shrink-0 asnp-w-8 asnp-h-8 asnp-rounded-lg';
      switch (this.type) {
        case 'error':
          value += ' asnp-text-red-500 asnp-bg-red-100';
          break;
        case 'info':
          value += ' asnp-text-blue-500 asnp-bg-blue-100';
          break;
        default:
          value += ' asnp-text-green-500 asnp-bg-green-100';
          break;
      }
      return value;
    },
    path: function path() {
      var value = 'M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z';
      switch (this.type) {
        case 'error':
          value = 'M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z';
          break;
        case 'info':
          value = 'M12 10C11.7348 10 11.4804 10.1054 11.2929 10.2929C11.1054 10.4804 11 10.7348 11 11V17C11 17.2652 11.1054 17.5196 11.2929 17.7071C11.4804 17.8946 11.7348 18 12 18C12.2652 18 12.5196 17.8946 12.7071 17.7071C12.8946 17.5196 13 17.2652 13 17V11C13 10.7348 12.8946 10.4804 12.7071 10.2929C12.5196 10.1054 12.2652 10 12 10ZM12 6C11.7528 6 11.5111 6.07331 11.3055 6.21066C11.1 6.34801 10.9398 6.54324 10.8452 6.77165C10.7505 7.00005 10.7258 7.25139 10.774 7.49386C10.8223 7.73634 10.9413 7.95907 11.1161 8.13388C11.2909 8.3087 11.5137 8.42775 11.7561 8.47598C11.9986 8.52421 12.2499 8.49946 12.4784 8.40485C12.7068 8.31024 12.902 8.15002 13.0393 7.94446C13.1767 7.7389 13.25 7.49723 13.25 7.25C13.25 6.91848 13.1183 6.60054 12.8839 6.36612C12.6495 6.1317 12.3315 6 12 6V6Z';
          break;
      }
      return value;
    }
  }),
  watch: {
    show: function show(value) {
      var _this = this;
      if (value) {
        setTimeout(function () {
          _this.$store.commit('message/hideMessage');
        }, 2000);
      }
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Snackbar/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Snackbarvue_type_script_lang_js_ = (Snackbarvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/components/Snackbar/index.vue?vue&type=style&index=0&lang=scss&
var Snackbarvue_type_style_index_0_lang_scss_ = __webpack_require__(143);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Snackbar/index.vue






/* normalize component */

var Snackbar_component = Object(componentNormalizer["a" /* default */])(
  components_Snackbarvue_type_script_lang_js_,
  Snackbarvue_type_template_id_7885c5dd_render,
  Snackbarvue_type_template_id_7885c5dd_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Snackbar = (Snackbar_component.exports);
// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/App.vue?vue&type=script&lang=js&
function Appvue_type_script_lang_js_typeof(o) { "@babel/helpers - typeof"; return Appvue_type_script_lang_js_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Appvue_type_script_lang_js_typeof(o); }
function Appvue_type_script_lang_js_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function Appvue_type_script_lang_js_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? Appvue_type_script_lang_js_ownKeys(Object(t), !0).forEach(function (r) { Appvue_type_script_lang_js_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : Appvue_type_script_lang_js_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function Appvue_type_script_lang_js_defineProperty(e, r, t) { return (r = Appvue_type_script_lang_js_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function Appvue_type_script_lang_js_toPropertyKey(t) { var i = Appvue_type_script_lang_js_toPrimitive(t, "string"); return "symbol" == Appvue_type_script_lang_js_typeof(i) ? i : i + ""; }
function Appvue_type_script_lang_js_toPrimitive(t, r) { if ("object" != Appvue_type_script_lang_js_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != Appvue_type_script_lang_js_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//











var Appvue_type_script_lang_js_registerTabs = function registerTabs() {
  var tabs = Object(external_this_wp_hooks_["applyFilters"])('wccs_tabs', [{
    name: 'Discounts',
    route: '/',
    component: DiscountList
  }, {
    name: 'Pricing',
    route: '/pricing-list',
    component: PricingList
  }, {
    name: 'Shipping Methods',
    route: '/shipping-list',
    component: ShippingList
  }, {
    name: 'Checkout Fees',
    route: '/checkout-fee-list',
    component: CheckoutFeeList
  }]);
  tabs.map(function (tab) {
    return Object(external_this_ewd_pages_["registerTab"])(tab);
  });

  // Last tabs of the plugin.
  Object(external_this_ewd_pages_["registerTab"])({
    name: 'Analytics',
    route: '/analytics',
    component: Analytics
  });
  Object(external_this_ewd_pages_["registerTab"])({
    name: 'Products',
    route: '/products-list',
    component: ProductsList
  });
  Object(external_this_ewd_pages_["registerTab"])({
    name: 'Addons',
    route: '/addons',
    component: Addons
  });
};
Appvue_type_script_lang_js_registerTabs();
var components = Appvue_type_script_lang_js_objectSpread(Appvue_type_script_lang_js_objectSpread({}, {
  Snackbar: Snackbar
}), Object(external_this_ewd_pages_["getTabComponents"])());
/* harmony default export */ var Appvue_type_script_lang_js_ = ({
  name: 'app',
  components: components,
  computed: {
    tabs: function tabs() {
      return Object(external_this_ewd_pages_["getTabs"])();
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/App.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_Appvue_type_script_lang_js_ = (Appvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/App.vue





/* normalize component */

var App_component = Object(componentNormalizer["a" /* default */])(
  src_Appvue_type_script_lang_js_,
  Appvue_type_template_id_ed0c929a_render,
  Appvue_type_template_id_ed0c929a_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var App = (App_component.exports);
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/plugins/Sortable.js
var Sortable = window.Sortable;
/* harmony default export */ var plugins_Sortable = ({
  install: function install(app, options) {
    app.directive('sortable', {
      bind: function bind(el, binding, vnode, oldVnode) {
        options = binding.value || {};
        var sortable = new Sortable(el, options);
        var vm = vnode.context;
        if (binding.arg && !vm.sortable) {
          vm.sortable = {};
        }

        //  Throw an error if the given ID is not unique
        if (binding.arg && vm.sortable[binding.arg]) {
          console.warn("[vue-sortable] cannot set already defined sortable id: '" + binding.arg + "'");
        } else if (binding.arg) {
          vm.sortable[binding.arg] = sortable;
        }
      }
    });
  }
});
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Alert.vue?vue&type=template&id=aa34235c&
var Alertvue_type_template_id_aa34235c_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-border asnp-w-full md:asnp-w-3/4 xl:asnp-w-1/2 asnp-my-4 asnp-px-4 asnp-py-3 asnp-rounded asnp-relative",class:_vm.alertClass,attrs:{"role":"alert"}},[_c('strong',{staticClass:"asnp-font-bold"},[_vm._v(_vm._s(_vm.title))]),_vm._v(" "),_c('span',{staticClass:"asnp-block sm:asnp-inline",domProps:{"innerHTML":_vm._s(_vm.message)}}),_vm._v(" "),(_vm.dismissable)?_c('span',{staticClass:"asnp-absolute asnp-top-0 asnp-bottom-0 asnp-right-0 asnp-px-4 asnp-py-3",attrs:{"data-dismiss":"alert"},on:{"click":_vm.dismiss}},[_c('svg',{staticClass:"asnp-fill-current asnp-h-6 asnp-w-6",class:_vm.textClass,attrs:{"role":"button","xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 20 20"}},[_c('title',[_vm._v(_vm._s(_vm.__( 'Close', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('path',{attrs:{"d":"M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"}})])]):_vm._e()])}
var Alertvue_type_template_id_aa34235c_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Alert.vue?vue&type=template&id=aa34235c&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Alert.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Alertvue_type_script_lang_js_ = ({
  name: 'alert',
  props: {
    type: {
      type: String
    },
    title: {
      type: String
    },
    message: {
      type: String
    },
    dismissable: {
      type: Boolean,
      "default": false
    }
  },
  methods: {
    dismiss: function dismiss() {
      this.$emit('dismiss');
    }
  },
  computed: {
    alertClass: function alertClass() {
      switch (this.type.toLowerCase()) {
        case 'warning':
        case 'error':
        case 'danger':
          return 'asnp-bg-rose-100 asnp-border-rose-400 asnp-text-rose-700';
        case 'success':
          return 'asnp-bg-green-100 asnp-border-green-400 asnp-text-green-700';
      }
      return 'asnp-bg-blue-100 asnp-border-blue-400 asnp-text-blue-700';
    },
    textClass: function textClass() {
      switch (this.type.toLowerCase()) {
        case 'warning':
        case 'error':
        case 'danger':
          return 'asnp-text-rose-500';
        case 'success':
          return 'asnp-text-green-500';
      }
      return 'asnp-text-blue-500';
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Alert.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Alertvue_type_script_lang_js_ = (Alertvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Alert.vue





/* normalize component */

var Alert_component = Object(componentNormalizer["a" /* default */])(
  components_Alertvue_type_script_lang_js_,
  Alertvue_type_template_id_aa34235c_render,
  Alertvue_type_template_id_aa34235c_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Alert = (Alert_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Loading.vue?vue&type=template&id=729e0af0&
var Loadingvue_type_template_id_729e0af0_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.show),expression:"show"}],attrs:{"id":"wccs-loading"}},[_vm._m(0)])}
var Loadingvue_type_template_id_729e0af0_staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"wccs-spinner"}},[_c('i',{staticClass:"fa fa-spinner fa-pulse fa-3x fa-fw margin-bottom asnp-text-indigo-600"})])}]


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Loading.vue?vue&type=template&id=729e0af0&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Loading.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Loadingvue_type_script_lang_js_ = ({
  name: 'loading',
  props: {
    show: {
      type: Boolean,
      "default": false
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Loading.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Loadingvue_type_script_lang_js_ = (Loadingvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Loading.vue





/* normalize component */

var Loading_component = Object(componentNormalizer["a" /* default */])(
  components_Loadingvue_type_script_lang_js_,
  Loadingvue_type_template_id_729e0af0_render,
  Loadingvue_type_template_id_729e0af0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Loading = (Loading_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Modal.vue?vue&type=template&id=2fafe3c5&
var Modalvue_type_template_id_2fafe3c5_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":"asnp-modal"}},[_c('div',{staticClass:"asnp-modal-mask"},[_c('div',{staticClass:"asnp-modal-wrapper"},[_c('div',{staticClass:"asnp-modal-container"},[_c('div',{staticClass:"asnp-modal-header"},[_vm._t("header",[_c('h3',{staticClass:"asnp-modal-warning-header"},[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Warning!',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")])])],2),_vm._v(" "),_c('div',{staticClass:"asnp-modal-body"},[_vm._t("body",[_c('p',[_vm._v("\n\t\t\t\t\t\t\t"+_vm._s(_vm.__(
									'Are you sure to delete?',
									'easy-woocommerce-discounts'
								))+"\n\t\t\t\t\t\t")])])],2),_vm._v(" "),_c('div',{staticClass:"asnp-modal-footer"},[_vm._t("footer",[_c('div',{staticClass:"asnp-modal-footer-buttons"},[_c('button',{staticClass:"asnp-modal-default-button asnp-btn asnp-btn-delete",on:{"click":function($event){return _vm.$emit( 'apply' )}}},[_vm._v("\n\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
										'Yes',
										'easy-woocommerce-discounts'
									))+"\n\t\t\t\t\t\t\t")]),_vm._v(" "),_c('button',{staticClass:"asnp-modal-default-button asnp-btn asnp-btn-secondary",on:{"click":function($event){return _vm.$emit( 'cancel' )}}},[_vm._v("\n\t\t\t\t\t\t\t\t"+_vm._s(_vm.__(
										'Cancel',
										'easy-woocommerce-discounts'
									))+"\n\t\t\t\t\t\t\t")])]),_vm._v(" "),_c('div',{staticClass:"clear"})])],2)])])])])}
var Modalvue_type_template_id_2fafe3c5_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Modal.vue?vue&type=template&id=2fafe3c5&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Modal.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Modalvue_type_script_lang_js_ = ({
  name: 'modal'
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Modal.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Modalvue_type_script_lang_js_ = (Modalvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Modal.vue





/* normalize component */

var Modal_component = Object(componentNormalizer["a" /* default */])(
  components_Modalvue_type_script_lang_js_,
  Modalvue_type_template_id_2fafe3c5_render,
  Modalvue_type_template_id_2fafe3c5_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Modal = (Modal_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Toggle.vue?vue&type=template&id=3eba7d93&
var Togglevue_type_template_id_3eba7d93_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-w-14 asnp-h-6 asnp-flex asnp-items-center asnp-bg-gray-300 asnp-rounded-full asnp-p-1 asnp-duration-300 asnp-cursor-pointer",class:{ 'asnp-bg-green-500': _vm.value },attrs:{"aria-checked":_vm.value.toString()},on:{"click":_vm.toggle}},[_c('div',{staticClass:"asnp-bg-white asnp-w-5 asnp-h-5 asnp-rounded-full asnp-shadow-md asnp-transform asnp-duration-300",class:{ 'asnp-translate-x-7': _vm.value }})])}
var Togglevue_type_template_id_3eba7d93_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Toggle.vue?vue&type=template&id=3eba7d93&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/Toggle.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var Togglevue_type_script_lang_js_ = ({
  name: 'toggle',
  props: {
    value: {
      type: Boolean,
      "default": false
    }
  },
  methods: {
    toggle: function toggle() {
      this.$emit('input', !this.value);
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Toggle.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Togglevue_type_script_lang_js_ = (Togglevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/Toggle.vue





/* normalize component */

var Toggle_component = Object(componentNormalizer["a" /* default */])(
  components_Togglevue_type_script_lang_js_,
  Togglevue_type_template_id_3eba7d93_render,
  Togglevue_type_template_id_3eba7d93_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Toggle = (Toggle_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/CurrentTime.vue?vue&type=template&id=47d7e870&
var CurrentTimevue_type_template_id_47d7e870_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{staticClass:"asnp-current-time"})}
var CurrentTimevue_type_template_id_47d7e870_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/CurrentTime.vue?vue&type=template&id=47d7e870&

// EXTERNAL MODULE: external {"this":["ewd","shared"]}
var external_this_ewd_shared_ = __webpack_require__(26);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/CurrentTime.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//


/* harmony default export */ var CurrentTimevue_type_script_lang_js_ = ({
  name: 'current-time',
  mounted: function mounted() {
    Object(external_this_ewd_shared_["showCurrentTime"])();
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/CurrentTime.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_CurrentTimevue_type_script_lang_js_ = (CurrentTimevue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/CurrentTime.vue





/* normalize component */

var CurrentTime_component = Object(componentNormalizer["a" /* default */])(
  components_CurrentTimevue_type_script_lang_js_,
  CurrentTimevue_type_template_id_47d7e870_render,
  CurrentTimevue_type_template_id_47d7e870_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CurrentTime = (CurrentTime_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductLabels.vue?vue&type=template&id=16e80af7&
var ProductLabelsvue_type_template_id_16e80af7_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"asnp-max-w-md asnp-hidden xl:asnp-block asnp-float-right asnp-bg-white asnp-shadow-lg hover:asnp-shadow-xl asnp-rounded-lg asnp-my-5"},[_c('div',{staticClass:"asnp-py-4 asnp-px-4"},[_vm._m(0),_vm._v(" "),_c('div',{staticClass:"asnp-flex asnp-justify-end asnp-space-x-2 asnp-mt-4 asnp-uppercase"},[_c('a',{staticClass:"asnp-btn",attrs:{"href":"https://wordpress.org/plugins/easy-sale-badges-for-woocommerce/","target":"_blank"}},[_vm._v(_vm._s(_vm.__( 'Download Free', 'easy-woocommerce-discounts' )))]),_vm._v(" "),_c('a',{staticClass:"asnp-btn asnp-btn-primary",attrs:{"href":"https://www.asanaplugins.com/product/woocommerce-sale-badges-and-product-labels/","target":"_blank"}},[_vm._v(_vm._s(_vm.__( 'Buy Pro', 'easy-woocommerce-discounts' )))])])])])}
var ProductLabelsvue_type_template_id_16e80af7_staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('a',{staticClass:"asnp-text-gray-700 hover:asnp-text-indigo-700 asnp-text-2xl asnp-font-semibold",attrs:{"href":"https://www.asanaplugins.com/product/woocommerce-sale-badges-and-product-labels/","target":"_blank"}},[_vm._v("\n\t\t\t\tSale Badges and Product Labels\n\t\t\t")]),_vm._v(" "),_c('p',{staticClass:"asnp-mt-2 asnp-text-gray-600"},[_vm._v("\n\t\t\t\tThe WooCommerce Sale Badges and Product Labels plugin\n\t\t\t\tenhances your store appeal by offering custom badges and\n\t\t\t\tcountdown timers. Add beautiful sale badges and product\n\t\t\t\tlabels to your discount and pricing rules.\n\t\t\t")])])}]


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductLabels.vue?vue&type=template&id=16e80af7&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/ProductLabels.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var ProductLabelsvue_type_script_lang_js_ = ({
  name: 'product-labels'
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductLabels.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_ProductLabelsvue_type_script_lang_js_ = (ProductLabelsvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/ProductLabels.vue





/* normalize component */

var ProductLabels_component = Object(componentNormalizer["a" /* default */])(
  components_ProductLabelsvue_type_script_lang_js_,
  ProductLabelsvue_type_template_id_16e80af7_render,
  ProductLabelsvue_type_template_id_16e80af7_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ProductLabels = (ProductLabels_component.exports);
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/BlackFriday.vue?vue&type=template&id=8cfb4572&
var BlackFridayvue_type_template_id_8cfb4572_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.show && _vm.activeEvent)?_c('div',{staticClass:"asnp-m-4 asnp-relative"},[_c('a',{staticClass:"focus:asnp-shadow-none focus:asnp-outline-none",attrs:{"href":"https://www.asanaplugins.com/product/woocommerce-dynamic-pricing-and-discounts-plugin/?utm_source=easy-woocommerce-discounts-free&utm_campaign=black-friday&utm_medium=link","target":"_blank"}},[_c('img',{staticClass:"asnp-rounded",attrs:{"src":_vm.imagesUrl + _vm.activeEvent.image,"alt":_vm.activeEvent.alt}})]),_vm._v(" "),_c('button',{staticClass:"notice-dismiss focus:asnp-shadow-none focus:asnp-outline-none",attrs:{"type":"button"},on:{"click":_vm.closeBanner}},[_c('span',{staticClass:"screen-reader-text"},[_vm._v("\n\t\t\t"+_vm._s(_vm.__( 'Maybe Later', 'asnp-easy-product-bundles' ))+"\n\t\t")])])]):_vm._e()}
var BlackFridayvue_type_template_id_8cfb4572_staticRenderFns = []


// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/BlackFriday.vue?vue&type=template&id=8cfb4572&

// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./admin/vue/wc-conditions/src/components/BlackFriday.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var BlackFridayvue_type_script_lang_js_ = ({
  name: 'black-friday',
  data: function data() {
    return {
      show: true,
      events: [{
        name: 'Black Friday',
        start: '11-20',
        end: '11-30',
        image: 'black-friday.png',
        alt: 'Black Friday Sale'
      }, {
        name: 'Cyber Monday',
        start: '12-01',
        end: '12-10',
        image: 'black-friday.png',
        alt: 'Cyber Monday Mega Sale'
      }, {
        name: 'Christmas Sale',
        start: '12-11',
        end: '12-31',
        image: 'christmas.png',
        alt: 'Christmas Offer'
      }]
    };
  },
  mounted: function mounted() {
    var closeDate = localStorage.getItem('closeBannerDate');
    if (!closeDate) {
      return;
    }
    var nowDate = new Date();
    closeDate = new Date(closeDate);
    if (nowDate - closeDate < 24 * 60 * 60 * 1000) {
      this.show = false;
    }
  },
  computed: {
    activeEvent: function activeEvent() {
      var today = new Date();
      var year = today.getFullYear();
      return this.events.find(function (event) {
        var start = new Date("".concat(year, "-").concat(event.start, "T00:00:00"));
        var end = new Date("".concat(year, "-").concat(event.end, "T23:59:59"));
        return today >= start && today <= end;
      });
    }
  },
  methods: {
    closeBanner: function closeBanner() {
      this.show = false;
      var closeDate = new Date();
      localStorage.setItem('closeBannerDate', closeDate.toISOString());
    }
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/BlackFriday.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_BlackFridayvue_type_script_lang_js_ = (BlackFridayvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/components/BlackFriday.vue





/* normalize component */

var BlackFriday_component = Object(componentNormalizer["a" /* default */])(
  components_BlackFridayvue_type_script_lang_js_,
  BlackFridayvue_type_template_id_8cfb4572_render,
  BlackFridayvue_type_template_id_8cfb4572_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var BlackFriday = (BlackFriday_component.exports);
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/plugins/Components.js



















/* harmony default export */ var Components = ({
  install: function install(app, options) {
    app.component(Alert.name, Alert);
    app.component(ColorPicker.name, ColorPicker);
    app.component(Loading.name, Loading);
    app.component(DateTimeItem.name, DateTimeItem);
    app.component(Condition.name, Condition);
    app.component(ConditionItem.name, ConditionItem);
    app.component(Select2.name, Select2);
    app.component(Modal.name, Modal);
    app.component(PricingQuantityDiscount.name, PricingQuantityDiscount);
    app.component(ProductsSelect.name, ProductsSelect);
    app.component(ProductsSelectItem.name, ProductsSelectItem);
    app.component('date-picker', vue_datepicker["default"]);
    app.component(Toggle.name, Toggle);
    app.component(ProductsSelectContainer.name, ProductsSelectContainer);
    app.component(ConditionsContainer.name, ConditionsContainer);
    app.component(DateTimeContainer.name, DateTimeContainer);
    app.component(CurrentTime.name, CurrentTime);
    app.component(ProductLabels.name, ProductLabels);
    app.component(BlackFriday.name, BlackFriday);
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/plugins/I18n.js

/* harmony default export */ var I18n = ({
  install: function install(app, options) {
    /* app.config.globalProperties.__ = ( text, domain ) => {
    	return __( text, domain );
    }; */
    app.prototype.__ = function (text, domain) {
      return Object(external_this_wp_i18n_["__"])(text, domain);
    };
    app.prototype.sprintf = function (format) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return external_this_wp_i18n_["sprintf"].apply(void 0, [format].concat(args));
    };
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/plugins/Globals.js
/* harmony default export */ var Globals = ({
  install: function install(app, options) {
    var id = 0;
    app.mixin({
      computed: {
        wccsNonce: function wccsNonce() {
          return wcConditions.nonce;
        },
        wccsSettings: function wccsSettings() {
          return wcConditions.settings;
        },
        wcRoles: function wcRoles() {
          return wcConditions.roles;
        },
        wcCapabilities: function wcCapabilities() {
          return wcConditions.capabilities;
        },
        wcCountries: function wcCountries() {
          return wcConditions.countries;
        },
        wcStates: function wcStates() {
          return wcConditions.states;
        },
        wcZones: function wcZones() {
          return wcConditions.zones;
        },
        wcPaymentMethods: function wcPaymentMethods() {
          return wcConditions.paymentMethods;
        },
        wcShippingClasses: function wcShippingClasses() {
          return wcConditions.shippingClasses;
        },
        saleBadgesAdv: function saleBadgesAdv() {
          return 'undefined' !== typeof wcConditions.saleBadgesAdv && 1 == wcConditions.saleBadgesAdv;
        },
        imagesUrl: function imagesUrl() {
          var _wcConditions;
          if ((_wcConditions = wcConditions) !== null && _wcConditions !== void 0 && _wcConditions.pluginUrl) {
            return wcConditions.pluginUrl + 'admin/images/';
          }
          return '';
        },
        wcSubscriptions: function wcSubscriptions() {
          var _wcConditions2;
          return this.toBool((_wcConditions2 = wcConditions) === null || _wcConditions2 === void 0 ? void 0 : _wcConditions2.wcSubscriptions);
        }
      },
      methods: {
        slideDown: function slideDown(el, done) {
          jQuery(el).slideDown('slow');
        },
        slideUp: function slideUp(el, done) {
          jQuery(el).slideUp('slow');
        },
        getKey: function getKey(item) {
          var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'item';
          if (item.id) {
            return type + '-' + item.id;
          }
          item.id = ++id + Date.now();
          return type + '-' + item.id;
        },
        toBool: function toBool(value) {
          if ('boolean' === typeof value) {
            return value;
          } else if ('number' === typeof value) {
            return 1 === value;
          }
          return '1' === value || 'true' === value.toLowerCase() || 'yes' === value.toLowerCase() || 'enabled' === value.toLowerCase() || 'on' === value.toLowerCase();
        },
        initialCondition: function initialCondition() {
          return {
            condition: 'subtotal_including_tax',
            customers: '',
            roles: '',
            union_type: 'at_least_one_of',
            yes_no: 'yes',
            select_type: 'selected',
            math_operation_type: 'less_than',
            products: '',
            categories: '',
            variations: '',
            tags: '',
            shipping_classes: '',
            time_type: 'all_time',
            number_value_1: 1,
            number_value_2: '',
            number_union_type: 2,
            current: 'day',
            start: {
              time: ''
            },
            end: {
              time: ''
            },
            meta_field_key: '',
            meta_field_condition: 'empty',
            meta_field_value: '',
            attributes: '',
            coupon_condition: 'at_least_one_of_any',
            coupons: '',
            before_after: 'before',
            string_operation_type: 'equal_to',
            string_value: '',
            taxonomies: '',
            match: 'match',
            email: '',
            shipping_methods_search_by: 'type',
            shipping_methods: '',
            shipping_methods_by_title: ''
          };
        },
        initialDateTime: function initialDateTime() {
          return {
            type: 'date',
            start: {
              time: ''
            },
            end: {
              time: ''
            },
            start_time: '00:00',
            end_time: '00:00',
            date: {
              time: ''
            },
            days: ''
          };
        },
        initialProducts: function initialProducts() {
          return {
            item: 'products_in_list',
            products: '',
            variations: '',
            categories: '',
            tags: '',
            attributes: '',
            taxonomies: '',
            union_type: 'at_least_one_of',
            after: {
              time: ''
            },
            limit: '12',
            top_filter_period: 'month',
            time_type: 'date',
            number_value_1: 1,
            current: 'day',
            start: {
              time: ''
            },
            end: {
              time: ''
            },
            quantity: '',
            meta_field_key: '',
            meta_field_condition: 'empty',
            meta_field_value: '',
            math_operation_type: 'less_than',
            number_value_2: '',
            yes_no: 'yes'
          };
        },
        urlCouponsEnabled: function urlCouponsEnabled() {
          return null != wcConditions.urlCouponsEnabled && this.toBool(wcConditions.urlCouponsEnabled);
        },
        getDateRange: function getDateRange() {
          var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'last_week';
          var customRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          if ('custom' === range) {
            var _customRange$start, _customRange$end, _customRange$start2, _customRange$end2, _customRange$start3, _customRange$end3;
            if (!customRange) {
              throw new Error('Custom date range requires parameters.');
            }
            if (!(customRange !== null && customRange !== void 0 && (_customRange$start = customRange.start) !== null && _customRange$start !== void 0 && _customRange$start.time)) {
              throw new Error('Please set a start date.');
            }
            if (!(customRange !== null && customRange !== void 0 && (_customRange$end = customRange.end) !== null && _customRange$end !== void 0 && _customRange$end.time)) {
              throw new Error('Please set an end date.');
            }
            var startDate = new Date(customRange === null || customRange === void 0 ? void 0 : (_customRange$start2 = customRange.start) === null || _customRange$start2 === void 0 ? void 0 : _customRange$start2.time);
            var endDate = new Date(customRange === null || customRange === void 0 ? void 0 : (_customRange$end2 = customRange.end) === null || _customRange$end2 === void 0 ? void 0 : _customRange$end2.time);
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
              throw new Error('Invalid date(s) provided.');
            }
            if (startDate > endDate) {
              throw new Error('Start date must be before or equal to end date.');
            }
            return {
              start_date: (customRange === null || customRange === void 0 ? void 0 : (_customRange$start3 = customRange.start) === null || _customRange$start3 === void 0 ? void 0 : _customRange$start3.time) || '',
              end_date: (customRange === null || customRange === void 0 ? void 0 : (_customRange$end3 = customRange.end) === null || _customRange$end3 === void 0 ? void 0 : _customRange$end3.time) || '',
              range: range
            };
          }
          var today = new Date();
          today.setHours(0, 0, 0, 0);
          var format = function format(d) {
            var y = d.getFullYear();
            var m = String(d.getMonth() + 1).padStart(2, '0');
            var day = String(d.getDate()).padStart(2, '0');
            return "".concat(y, "-").concat(m, "-").concat(day);
          };
          var result = {
            start_date: '',
            end_date: '',
            range: range
          };
          switch (range) {
            case 'today':
              result.start_date = result.end_date = format(today);
              break;
            case 'this_month':
              {
                var first = new Date(today.getFullYear(), today.getMonth(), 1);
                result.start_date = format(first);
                result.end_date = format(today);
                break;
              }
            case 'last_month':
              {
                var _first = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                var last = new Date(today.getFullYear(), today.getMonth(), 0);
                result.start_date = format(_first);
                result.end_date = format(last);
                break;
              }
            case 'this_year':
              {
                var _first2 = new Date(today.getFullYear(), 0, 1);
                result.start_date = format(_first2);
                result.end_date = format(today);
                break;
              }
            case 'last_year':
              {
                var firstPrevYear = new Date(today.getFullYear() - 1, 0, 1);
                var lastPrevYear = new Date(today.getFullYear() - 1, 11, 31);
                result.start_date = format(firstPrevYear);
                result.end_date = format(lastPrevYear);
                break;
              }
            case 'last_week':
            default:
              {
                var sevenDaysAgo = new Date(today);
                sevenDaysAgo.setDate(today.getDate() - 7);
                result.start_date = format(sevenDaysAgo);
                result.end_date = format(today);
              }
          }
          return result;
        }
      }
    });
  }
});
// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/plugins/TipTip.js

/* harmony default export */ var TipTip = ({
  install: function install(Vue) {
    Vue.directive('tip', {
      inserted: function inserted(el, binding) {
        initTip(el, binding);
      },
      componentUpdated: function componentUpdated(el, binding) {
        // Re-initialize if tooltip text changes
        initTip(el, binding);
      }
    });
  }
});
function initTip(el, binding) {
  var $ = external_jQuery_default.a;
  if (typeof $.fn.tipTip === 'undefined') {
    // TipTip may not be ready yet  try again shortly
    setTimeout(function () {
      return initTip(el, binding);
    }, 100);
    return;
  }

  // Tooltip text: either data-tip attr or directive value
  var tipText = binding.value || el.getAttribute('data-tip');
  if (!tipText) return;

  // Set data-tip for WooCommerce consistency
  $(el).attr('data-tip', tipText);

  // Remove any existing tipTip instance elements
  $('.tipTip, .tiptip_holder, .tiptip_arrow').remove();

  // Initialize WooCommerce TipTip
  $(el).tipTip({
    attribute: 'data-tip',
    fadeIn: 50,
    fadeOut: 50,
    delay: 200,
    keepAlive: true,
    defaultPosition: 'top'
  });
}
// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/assets/css/tailwind.scss
var tailwind = __webpack_require__(144);

// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/assets/css/components.scss
var css_components = __webpack_require__(145);

// EXTERNAL MODULE: ./admin/vue/wc-conditions/src/assets/css/conditions.scss
var css_conditions = __webpack_require__(146);

// CONCATENATED MODULE: ./admin/vue/wc-conditions/src/main.js
// The following line loads the standalone build of Vue instead of the runtime-only build,
// so you don't have to do: import Vue from 'vue/dist/vue'
// This is done with the browser options. For the config, see package.json












// Styles.



Object(external_this_ewd_shared_["initCurrentTime"])();
external_Vue_default.a.use(external_vuelidate_default.a);
external_Vue_default.a.use(plugins_Sortable);
external_Vue_default.a.use(Components);
external_Vue_default.a.use(I18n);
external_Vue_default.a.use(Globals);
external_Vue_default.a.use(TipTip);
var store = createStore(wcConditions.productsList, wcConditions.discountList, wcConditions.pricingList, wcConditions.shippingList);
(function () {
  new external_Vue_default.a({
    el: '#wc-conditions-app',
    router: router,
    store: store,
    render: function render(h) {
      return h(App);
    }
  });
})();

/***/ })
/******/ ]);